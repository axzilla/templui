package popover

import (
	"github.com/axzilla/templui/internal/utils"
	"strconv"
)

type Placement string

const (
	PlacementTop         Placement = "top"
	PlacementTopStart    Placement = "top-start"
	PlacementTopEnd      Placement = "top-end"
	PlacementRight       Placement = "right"
	PlacementRightStart  Placement = "right-start"
	PlacementRightEnd    Placement = "right-end"
	PlacementBottom      Placement = "bottom"
	PlacementBottomStart Placement = "bottom-start"
	PlacementBottomEnd   Placement = "bottom-end"
	PlacementLeft        Placement = "left"
	PlacementLeftStart   Placement = "left-start"
	PlacementLeftEnd     Placement = "left-end"
)

type TriggerType string

const (
	TriggerTypeHover TriggerType = "hover"
	TriggerTypeClick TriggerType = "click"
)

type Props struct {
	Class string
}

type TriggerProps struct {
	ID          string
	For         string
	TriggerType TriggerType
}

type ContentProps struct {
	ID               string
	Class            string
	Attributes       templ.Attributes
	Placement        Placement
	Offset           int
	DisableClickAway bool
	DisableESC       bool
	ShowArrow        bool
	HoverDelay       int
	HoverOutDelay    int
	MatchWidth       bool
}

templ Popover(props ...Props) {
	@Script()
	{{ var p Props }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	<div class={ p.Class }>
		{ children... }
	</div>
	<div data-popover-portal-container class="fixed inset-0 z-[9999] pointer-events-none"></div>
}

templ Trigger(props ...TriggerProps) {
	{{ var p TriggerProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.TriggerType == "" {
		{{ p.TriggerType = TriggerTypeClick }}
	}
	<span
		if p.ID != "" {
			id={ p.ID }
		}
		data-popover-trigger
		data-popover-for={ p.For }
		data-popover-type={ string(p.TriggerType) }
	>
		{ children... }
	</span>
}

templ Content(props ...ContentProps) {
	{{ var p ContentProps }}
	if len(props) > 0 {
		{{ p = props[0] }}
	}
	if p.Placement == "" {
		{{ p.Placement = PlacementBottom }}
	}
	if p.Offset == 0 {
		if p.ShowArrow {
			{{ p.Offset = 8 }}
		} else {
			{{ p.Offset = 4 }}
		}
	}
	<div
		id={ p.ID }
		data-popover-id={ p.ID }
		data-popover-placement={ string(p.Placement) }
		data-popover-offset={ strconv.Itoa(p.Offset) }
		data-popover-disable-clickaway={ strconv.FormatBool(p.DisableClickAway) }
		data-popover-disable-esc={ strconv.FormatBool(p.DisableESC) }
		data-popover-show-arrow={ strconv.FormatBool(p.ShowArrow) }
		data-popover-hover-delay={ strconv.Itoa(p.HoverDelay) }
		data-popover-hover-out-delay={ strconv.Itoa(p.HoverOutDelay) }
		if p.MatchWidth {
			data-popover-match-width="true"
		}
		class={ utils.TwMerge(
			"bg-background rounded-lg border-[1.5px] border-[#e5e7eb] dark:border-[#27272a] text-sm shadow-lg pointer-events-auto fixed z-[9999] hidden top-0 left-0 p-2 min-w-[8rem] max-w-[20rem] relative",
			p.Class,
		) }
		{ p.Attributes... }
	>
		<div class="w-full overflow-hidden">
			{ children... }
		</div>
		if p.ShowArrow {
			<div data-popover-arrow class="absolute"></div>
		}
	</div>
	<style>
		@keyframes popover-in {
			0% { opacity: 0; transform: scale(0.95); }
			100% { opacity: 1; transform: scale(1); }
		}
		@keyframes popover-out {
			0% { opacity: 1; transform: scale(1); }
			100% { opacity: 0; transform: scale(0.95); }
		}
		[data-popover-id].popover-animate-in {
			animation: popover-in 0.15s cubic-bezier(0.16, 1, 0.3, 1);
		}
		[data-popover-id].popover-animate-out {
			animation: popover-out 0.1s cubic-bezier(0.16, 1, 0.3, 1) forwards;
		}
	</style>
}

var handle = templ.NewOnceHandle()

templ Script() {
	@handle.Once() {
		<script nonce={ templ.GetNonce(ctx) }>
		(function() {
		  if (window.popoverSystemInitialized) return;
          function getPlacement(trigger, content, placement, offset) {
            const rect = trigger.getBoundingClientRect();
            const cRect = content.getBoundingClientRect();
            let top = 0, left = 0;
            switch (placement) {
              case 'top':
                top = rect.top - cRect.height - offset;
                left = rect.left + (rect.width - cRect.width) / 2;
                break;
              case 'top-start':
                top = rect.top - cRect.height - offset;
                left = rect.left;
                break;
              case 'top-end':
                top = rect.top - cRect.height - offset;
                left = rect.left + rect.width - cRect.width;
                break;
              case 'right':
                top = rect.top + (rect.height - cRect.height) / 2;
                left = rect.right + offset;
                break;
              case 'right-start':
                top = rect.top;
                left = rect.right + offset;
                break;
              case 'right-end':
                top = rect.bottom - cRect.height;
                left = rect.right + offset;
                break;
              case 'bottom':
                top = rect.bottom + offset;
                left = rect.left + (rect.width - cRect.width) / 2;
                break;
              case 'bottom-start':
                top = rect.bottom + offset;
                left = rect.left;
                break;
              case 'bottom-end':
                top = rect.bottom + offset;
                left = rect.left + rect.width - cRect.width;
                break;
              case 'left':
                top = rect.top + (rect.height - cRect.height) / 2;
                left = rect.left - cRect.width - offset;
                break;
              case 'left-start':
                top = rect.top;
                left = rect.left - cRect.width - offset;
                break;
              case 'left-end':
                top = rect.bottom - cRect.height;
                left = rect.left - cRect.width - offset;
                break;
              default:
                top = rect.bottom + offset;
                left = rect.left + (rect.width - cRect.width) / 2;
            }
            return { top: Math.round(top), left: Math.round(left) };
          }

          function isInViewport(element) {
            const rect = element.getBoundingClientRect();
            return (
              rect.top >= 0 &&
              rect.left >= 0 &&
              rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
              rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
          }

          function findBestPlacement(trigger, content, preferredPlacement, offset) {
            // Determine the direction of the preferred placement
            const direction = preferredPlacement.split('-')[0]; // 'left', 'right', 'top', 'bottom'
            const alignment = preferredPlacement.split('-')[1] || ''; // 'start', 'end' or empty

            // Build alternatives in the same direction
            const sameDirectionPlacements = [
              preferredPlacement, // First try the preferred placement
              direction, // Then just the direction (e.g. 'left')
              direction + '-start', // Then start
              direction + '-end' // Then end
            ];

            // Build alternatives in the opposite direction
            const oppositeDirection = {
              'left': 'right',
              'right': 'left',
              'top': 'bottom',
              'bottom': 'top'
            }[direction];

            const oppositePlacements = [
              oppositeDirection,
              oppositeDirection + '-start',
              oppositeDirection + '-end'
            ];

            // Build alternatives in the other directions
            const otherDirections = ['top', 'right', 'bottom', 'left'].filter(d => d !== direction && d !== oppositeDirection);
            const otherPlacements = otherDirections.flatMap(d => [d, d + '-start', d + '-end']);

            // Combine all placements and remove duplicates
            const allPlacements = [
              ...sameDirectionPlacements,
              ...oppositePlacements,
              ...otherPlacements
            ];
            const uniquePlacements = [...new Set(allPlacements)];

            // Try each placement
            for (const placement of uniquePlacements) {
              const pos = getPlacement(trigger, content, placement, offset);
              content.style.top = pos.top + 'px';
              content.style.left = pos.left + 'px';

              if (isInViewport(content)) {
                return placement;
              }
            }

            // If no placement fits, at least keep the popover inside the viewport
            const pos = getPlacement(trigger, content, preferredPlacement, offset);
            const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            const viewportWidth = window.innerWidth || document.documentElement.clientWidth;

            let top = pos.top;
            let left = pos.left;

            // Check vertical boundaries
            if (top < 0) top = 0;
            if (top + content.offsetHeight > viewportHeight) {
              top = viewportHeight - content.offsetHeight;
            }

            // Check horizontal boundaries
            if (left < 0) left = 0;
            if (left + content.offsetWidth > viewportWidth) {
              left = viewportWidth - content.offsetWidth;
            }

            content.style.top = top + 'px';
            content.style.left = left + 'px';
            return preferredPlacement;
          }

          function openPopover(trigger, content, placement, offset, matchWidth) {
            // Calculate extra offset: add space for arrow if present, otherwise none for matchWidth popovers
            let extraOffset = 12;
            const hasArrow = !!content.querySelector('[data-popover-arrow]');
            if (matchWidth && !hasArrow) {
              extraOffset = 0;
            }
            offset = (offset || 0) + extraOffset;

            // Make popover visible but not shown, so it can be measured
            content.style.visibility = 'hidden';
            content.style.display = 'block';
            content.style.position = 'fixed';
            content.style.zIndex = '9999';
            content.classList.remove('hidden');
            content.classList.remove('popover-animate-out');

            // Make arrow measurable if present
            const arrow = content.querySelector('[data-popover-arrow]');
            if (arrow) {
              arrow.style.visibility = 'hidden';
              arrow.style.display = 'block';
            }

            // Set width to match trigger if requested
            if (matchWidth) {
              const triggerRect = trigger.getBoundingClientRect();
              content.style.width = `${triggerRect.width}px`;
              content.style.minWidth = `${triggerRect.width}px`;
              content.style.maxWidth = `${triggerRect.width}px`;
            } else {
              content.style.width = '';
              content.style.minWidth = '';
              content.style.maxWidth = '';
            }

            // Find the best placement that fits in the viewport
            const bestPlacement = findBestPlacement(trigger, content, placement, offset);
            let pos = getPlacement(trigger, content, bestPlacement, offset);

            // For matchWidth popovers, align left edge exactly with trigger
            if (matchWidth && (
              bestPlacement.startsWith('bottom') || bestPlacement.startsWith('top')
            )) {
              pos.left = trigger.getBoundingClientRect().left;
            }
            content.style.top = pos.top + 'px';
            content.style.left = pos.left + 'px';

            // Arrow positioning
            if (arrow) {
              const triggerRect = trigger.getBoundingClientRect();
              const contentRect = content.getBoundingClientRect();
              const popoverStyle = window.getComputedStyle(content);
              const popoverBorderColor = popoverStyle.borderColor;

              arrow.style.width = '0';
              arrow.style.height = '0';
              arrow.style.position = 'absolute';
              arrow.style.borderStyle = 'solid';
              arrow.style.borderColor = 'transparent';
              arrow.style.boxShadow = 'none';

              let size = 10; // px
              switch (bestPlacement) {
                case 'top':
                case 'top-start':
                case 'top-end':
                  arrow.style.borderLeft = `${size}px solid transparent`;
                  arrow.style.borderRight = `${size}px solid transparent`;
                  arrow.style.borderTop = `${size}px solid ${popoverBorderColor}`;
                  arrow.style.borderBottom = '0';
                  arrow.style.bottom = '-10px';
                  if (bestPlacement === 'top') {
                    arrow.style.left = (contentRect.width / 2 - size) + 'px';
                  } else if (bestPlacement === 'top-start') {
                    arrow.style.left = (triggerRect.left + triggerRect.width / 2 - contentRect.left - size) + 'px';
                  } else if (bestPlacement === 'top-end') {
                    arrow.style.left = (triggerRect.right - contentRect.left - triggerRect.width / 2 - size) + 'px';
                  }
                  break;
                case 'bottom':
                case 'bottom-start':
                case 'bottom-end':
                  arrow.style.borderLeft = `${size}px solid transparent`;
                  arrow.style.borderRight = `${size}px solid transparent`;
                  arrow.style.borderBottom = `${size}px solid ${popoverBorderColor}`;
                  arrow.style.borderTop = '0';
                  arrow.style.top = '-10px';
                  if (bestPlacement === 'bottom') {
                    arrow.style.left = (contentRect.width / 2 - size) + 'px';
                  } else if (bestPlacement === 'bottom-start') {
                    arrow.style.left = (triggerRect.left + triggerRect.width / 2 - contentRect.left - size) + 'px';
                  } else if (bestPlacement === 'bottom-end') {
                    arrow.style.left = (triggerRect.right - contentRect.left - triggerRect.width / 2 - size) + 'px';
                  }
                  break;
                case 'left':
                case 'left-start':
                case 'left-end':
                  arrow.style.borderTop = `${size}px solid transparent`;
                  arrow.style.borderBottom = `${size}px solid transparent`;
                  arrow.style.borderLeft = `${size}px solid ${popoverBorderColor}`;
                  arrow.style.borderRight = '0';
                  arrow.style.right = '-10px';
                  if (bestPlacement === 'left') {
                    arrow.style.top = (contentRect.height / 2 - size) + 'px';
                  } else if (bestPlacement === 'left-start') {
                    arrow.style.top = (triggerRect.top - contentRect.top + triggerRect.height / 2 - size) + 'px';
                  } else if (bestPlacement === 'left-end') {
                    arrow.style.top = (triggerRect.bottom - contentRect.top - triggerRect.height / 2 - size) + 'px';
                  }
                  break;
                case 'right':
                case 'right-start':
                case 'right-end':
                  arrow.style.borderTop = `${size}px solid transparent`;
                  arrow.style.borderBottom = `${size}px solid transparent`;
                  arrow.style.borderRight = `${size}px solid ${popoverBorderColor}`;
                  arrow.style.borderLeft = '0';
                  arrow.style.left = '-10px';
                  if (bestPlacement === 'right') {
                    arrow.style.top = (contentRect.height / 2 - size) + 'px';
                  } else if (bestPlacement === 'right-start') {
                    arrow.style.top = (triggerRect.top - contentRect.top + triggerRect.height / 2 - size) + 'px';
                  } else if (bestPlacement === 'right-end') {
                    arrow.style.top = (triggerRect.bottom - contentRect.top - triggerRect.height / 2 - size) + 'px';
                  }
                  break;
              }
              arrow.style.visibility = 'visible';
              arrow.style.display = '';
            }

            // Finally make visible and start animation
            content.style.visibility = 'visible';
            content.setAttribute('aria-hidden', 'false');

            // Start animation
            requestAnimationFrame(() => {
              content.classList.add('popover-animate-in');
            });
          }

          function closePopover(popover) {
            if (!popover) return;

            // If popover is already hidden, do nothing
            if (popover.classList.contains('hidden')) return;

            // First start exit animation
            popover.classList.remove('popover-animate-in');
            popover.classList.add('popover-animate-out');

            // Once animation ends, hide
            const animationEndHandler = function handler() {
              popover.removeEventListener('animationend', handler);
              popover.style.display = 'none';
              popover.style.visibility = 'hidden';
              popover.classList.add('hidden');
              popover.setAttribute('aria-hidden', 'true');

              // Hide arrow
              const arrow = popover.querySelector('[data-popover-arrow]');
              if (arrow) {
                arrow.style.visibility = 'hidden';
              }
            };

            popover.addEventListener('animationend', animationEndHandler, { once: true });

            // Fallback: if animation doesn't complete, force close after 300ms
            setTimeout(() => {
              if (!popover.classList.contains('hidden')) {
                popover.removeEventListener('animationend', animationEndHandler);
                popover.style.display = 'none';
                popover.style.visibility = 'hidden';
                popover.classList.add('hidden');
                popover.setAttribute('aria-hidden', 'true');

                const arrow = popover.querySelector('[data-popover-arrow]');
                if (arrow) {
                  arrow.style.visibility = 'hidden';
                }
              }
            }, 300);
          }

          function handleClickAway(e, content, trigger) {
            if (!content || !trigger) return;
            if (!content.contains(e.target) && !trigger.contains(e.target)) {
              closePopover(content);
            }
          }

          function handleESC(e, content) {
            if (!content) return;
            if (e.key === 'Escape') {
              closePopover(content);
            }
          }

          function initPopoverTrigger(trigger) {
            if (!trigger) return;

            const popoverId = trigger.getAttribute('data-popover-for');
            if (!popoverId) return;

            const content = document.getElementById(popoverId);
            if (!content) return;

            const type = trigger.getAttribute('data-popover-type') || 'click';
            const placement = content.getAttribute('data-popover-placement') || 'bottom';
            const offset = parseInt(content.getAttribute('data-popover-offset') || '4', 10);
            const disableClickAway = content.getAttribute('data-popover-disable-clickaway') === 'true';
            const disableESC = content.getAttribute('data-popover-disable-esc') === 'true';
            const hoverDelay = parseInt(content.getAttribute('data-popover-hover-delay') || '0', 10);
            const hoverOutDelay = parseInt(content.getAttribute('data-popover-hover-out-delay') || '0', 10);
            const matchWidth = content.getAttribute('data-popover-match-width') === 'true';

            // Clean up existing handlers if any
            if (trigger._popoverHandlers) {
              const handlers = trigger._popoverHandlers;
              if (handlers.clickAwayHandler) {
                document.removeEventListener('mousedown', handlers.clickAwayHandler);
              }
              if (handlers.escHandler) {
                document.removeEventListener('keydown', handlers.escHandler);
              }
              if (handlers.scrollHandler) {
                window.removeEventListener('scroll', handlers.scrollHandler, true);
              }
            }

            // Initialize new handlers
            trigger._popoverHandlers = {
              clickAwayHandler: null,
              escHandler: null,
              scrollHandler: null,
              resizeHandler: null
            };
            const handlers = trigger._popoverHandlers;

            let hoverTimeout, outTimeout;

            function updatePosition() {
              if (content && !content.classList.contains('hidden')) {
                openPopover(trigger, content, placement, offset, matchWidth);
              }
            }

            function show() {
              if (!content || !trigger) return;
              openPopover(trigger, content, placement, offset, matchWidth);
              if (!disableClickAway && !handlers.clickAwayHandler) {
                handlers.clickAwayHandler = (e) => handleClickAway(e, content, trigger);
                document.addEventListener('mousedown', handlers.clickAwayHandler);
              }
              if (!disableESC && !handlers.escHandler) {
                handlers.escHandler = (e) => handleESC(e, content);
                document.addEventListener('keydown', handlers.escHandler);
              }
              if (!handlers.scrollHandler) {
                handlers.scrollHandler = () => {
                  requestAnimationFrame(updatePosition);
                };
                window.addEventListener('scroll', handlers.scrollHandler, true);
              }

              // Add resize handler
              if (!handlers.resizeHandler) {
                handlers.resizeHandler = () => {
                  requestAnimationFrame(updatePosition);
                };
                window.addEventListener('resize', handlers.resizeHandler);
              }
            }

            function hide() {
              if (!content) return;
              closePopover(content);
              if (handlers.clickAwayHandler) {
                document.removeEventListener('mousedown', handlers.clickAwayHandler);
                handlers.clickAwayHandler = null;
              }
              if (handlers.escHandler) {
                document.removeEventListener('keydown', handlers.escHandler);
                handlers.escHandler = null;
              }
              if (handlers.scrollHandler) {
                window.removeEventListener('scroll', handlers.scrollHandler, true);
                handlers.scrollHandler = null;
              }
              if (handlers.resizeHandler) {
                window.removeEventListener('resize', handlers.resizeHandler);
                handlers.resizeHandler = null;
              }
            }

            // Remove any existing click handlers
            const newTrigger = trigger.cloneNode(true);
            trigger.parentNode.replaceChild(newTrigger, trigger);
            trigger = newTrigger;

            if (type === 'hover') {
              trigger.addEventListener('mouseenter', () => {
                clearTimeout(outTimeout);
                hoverTimeout = setTimeout(show, hoverDelay);
              });
              trigger.addEventListener('mouseleave', () => {
                clearTimeout(hoverTimeout);
                outTimeout = setTimeout(hide, hoverOutDelay);
              });
              content.addEventListener('mouseenter', () => {
                clearTimeout(outTimeout);
              });
              content.addEventListener('mouseleave', () => {
                outTimeout = setTimeout(hide, hoverOutDelay);
              });
            } else {
              trigger.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (content.classList.contains('hidden')) {
                  show();
                } else {
                  hide();
                }
              });
            }
          }

          function initAllPopovers(root = document) {
            const triggers = root.querySelectorAll('[data-popover-trigger]');
            triggers.forEach(trigger => {
              // Remove any existing handlers before reinitializing
              if (trigger._popoverHandlers) {
                const handlers = trigger._popoverHandlers;
                if (handlers.clickAwayHandler) {
                  document.removeEventListener('mousedown', handlers.clickAwayHandler);
                }
                if (handlers.escHandler) {
                  document.removeEventListener('keydown', handlers.escHandler);
                }
                if (handlers.scrollHandler) {
                  window.removeEventListener('scroll', handlers.scrollHandler, true);
                }
                if (handlers.resizeHandler) {
                  window.removeEventListener('resize', handlers.resizeHandler);
                }
              }
              initPopoverTrigger(trigger);
            });
          }

          // Global closePopover function for external use
          window.closePopover = function(popoverId, animate = true) {
            const popover = document.getElementById(popoverId);
            if (!popover) return;

            // Find the trigger element that opened this popover
            const trigger = document.querySelector(`[data-popover-trigger][data-popover-for="${popoverId}"]`);

            // Disable all interactive elements inside popover
            const interactiveElements = popover.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            interactiveElements.forEach(el => {
              el.setAttribute('tabindex', '-1');
              el.setAttribute('aria-hidden', 'true');
            });

            // Force blur any focused element inside popover
            if (document.activeElement && popover.contains(document.activeElement)) {
              document.activeElement.blur();
            }

            // Move focus to trigger or body
            if (trigger) {
              trigger.focus();
            } else {
              document.body.focus();
            }

            if (animate) {
              // Start exit animation
              popover.classList.remove('popover-animate-in');
              popover.classList.add('popover-animate-out');

              // Once animation ends, hide
              const animationEndHandler = function handler() {
                popover.removeEventListener('animationend', handler);
                popover.style.display = 'none';
                popover.style.visibility = 'hidden';
                popover.classList.add('hidden');
                popover.setAttribute('aria-hidden', 'true');

                // Hide arrow
                const arrow = popover.querySelector('[data-popover-arrow]');
                if (arrow) {
                  arrow.style.visibility = 'hidden';
                }

                // Re-enable interactive elements
                interactiveElements.forEach(el => {
                  el.removeAttribute('tabindex');
                  el.removeAttribute('aria-hidden');
                });
              };

              popover.addEventListener('animationend', animationEndHandler, { once: true });

              // Fallback: if animation doesn't complete, force close after 300ms
              setTimeout(() => {
                if (!popover.classList.contains('hidden')) {
                  popover.removeEventListener('animationend', animationEndHandler);
                  popover.style.display = 'none';
                  popover.style.visibility = 'hidden';
                  popover.classList.add('hidden');
                  popover.setAttribute('aria-hidden', 'true');

                  const arrow = popover.querySelector('[data-popover-arrow]');
                  if (arrow) {
                    arrow.style.visibility = 'hidden';
                  }

                  // Re-enable interactive elements
                  interactiveElements.forEach(el => {
                    el.removeAttribute('tabindex');
                    el.removeAttribute('aria-hidden');
                  });
                }
              }, 300);
            } else {
              // Immediate close without animation
              popover.style.display = 'none';
              popover.style.visibility = 'hidden';
              popover.classList.add('hidden');
              popover.setAttribute('aria-hidden', 'true');

              const arrow = popover.querySelector('[data-popover-arrow]');
              if (arrow) {
                arrow.style.visibility = 'hidden';
              }

              // Re-enable interactive elements
              interactiveElements.forEach(el => {
                el.removeAttribute('tabindex');
                el.removeAttribute('aria-hidden');
              });
            }
          };

          document.addEventListener('DOMContentLoaded', () => initAllPopovers(document));

          // HTMX event bindings
          function htmxInitHandler(event) {
            const target = event.detail && event.detail.elt;
            if (target instanceof Element) {
              initAllPopovers(target);
            }
          }
          document.body.addEventListener('htmx:afterSwap', htmxInitHandler);
          document.body.addEventListener('htmx:oobAfterSwap', htmxInitHandler);
          document.body.addEventListener('htmx:beforeSwap', htmxInitHandler);

          // Add popstate event listener for browser history navigation
          window.addEventListener('popstate', () => {
            requestAnimationFrame(() => {
              initAllPopovers(document);
            });
          });

          window.popoverSystemInitialized = true;
		})();
		</script>
	}
}
