(() => {
  var tn = Object.create;
  var Zt = Object.defineProperty;
  var nn = Object.getOwnPropertyDescriptor;
  var an = Object.getOwnPropertyNames;
  var rn = Object.getPrototypeOf,
    on = Object.prototype.hasOwnProperty;
  var $t = (N, S) => () => (
    S || N((S = { exports: {} }).exports, S), S.exports
  );
  var sn = (N, S, P, i) => {
    if ((S && typeof S == "object") || typeof S == "function")
      for (let n of an(S))
        !on.call(N, n) &&
          n !== P &&
          Zt(N, n, {
            get: () => S[n],
            enumerable: !(i = nn(S, n)) || i.enumerable,
          });
    return N;
  };
  var qt = (N, S, P) => (
    (P = N != null ? tn(rn(N)) : {}),
    sn(
      S || !N || !N.__esModule
        ? Zt(P, "default", { value: N, enumerable: !0 })
        : P,
      N
    )
  );
  var Vt = $t((Wt, Ut) => {
    window.hljs = (function () {
      "use strict";
      function N(e) {
        return (
          e instanceof Map
            ? (e.clear =
                e.delete =
                e.set =
                  () => {
                    throw Error("map is read-only");
                  })
            : e instanceof Set &&
              (e.add =
                e.clear =
                e.delete =
                  () => {
                    throw Error("set is read-only");
                  }),
          Object.freeze(e),
          Object.getOwnPropertyNames(e).forEach((t) => {
            let a = e[t],
              d = typeof a;
            (d !== "object" && d !== "function") || Object.isFrozen(a) || N(a);
          }),
          e
        );
      }
      class S {
        constructor(t) {
          t.data === void 0 && (t.data = {}),
            (this.data = t.data),
            (this.isMatchIgnored = !1);
        }
        ignoreMatch() {
          this.isMatchIgnored = !0;
        }
      }
      function P(e) {
        return e
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#x27;");
      }
      function i(e, ...t) {
        let a = Object.create(null);
        for (let d in e) a[d] = e[d];
        return (
          t.forEach((d) => {
            for (let y in d) a[y] = d[y];
          }),
          a
        );
      }
      let n = (e) => !!e.scope;
      class r {
        constructor(t, a) {
          (this.buffer = ""), (this.classPrefix = a.classPrefix), t.walk(this);
        }
        addText(t) {
          this.buffer += P(t);
        }
        openNode(t) {
          if (!n(t)) return;
          let a = ((d, { prefix: y }) => {
            if (d.startsWith("language:"))
              return d.replace("language:", "language-");
            if (d.includes(".")) {
              let u = d.split(".");
              return [
                `${y}${u.shift()}`,
                ...u.map((_, p) => `${_}${"_".repeat(p + 1)}`),
              ].join(" ");
            }
            return `${y}${d}`;
          })(t.scope, { prefix: this.classPrefix });
          this.span(a);
        }
        closeNode(t) {
          n(t) && (this.buffer += "</span>");
        }
        value() {
          return this.buffer;
        }
        span(t) {
          this.buffer += `<span class="${t}">`;
        }
      }
      let o = (e = {}) => {
        let t = { children: [] };
        return Object.assign(t, e), t;
      };
      class m {
        constructor() {
          (this.rootNode = o()), (this.stack = [this.rootNode]);
        }
        get top() {
          return this.stack[this.stack.length - 1];
        }
        get root() {
          return this.rootNode;
        }
        add(t) {
          this.top.children.push(t);
        }
        openNode(t) {
          let a = o({ scope: t });
          this.add(a), this.stack.push(a);
        }
        closeNode() {
          if (this.stack.length > 1) return this.stack.pop();
        }
        closeAllNodes() {
          for (; this.closeNode(); );
        }
        toJSON() {
          return JSON.stringify(this.rootNode, null, 4);
        }
        walk(t) {
          return this.constructor._walk(t, this.rootNode);
        }
        static _walk(t, a) {
          return (
            typeof a == "string"
              ? t.addText(a)
              : a.children &&
                (t.openNode(a),
                a.children.forEach((d) => this._walk(t, d)),
                t.closeNode(a)),
            t
          );
        }
        static _collapse(t) {
          typeof t != "string" &&
            t.children &&
            (t.children.every((a) => typeof a == "string")
              ? (t.children = [t.children.join("")])
              : t.children.forEach((a) => {
                  m._collapse(a);
                }));
        }
      }
      class C extends m {
        constructor(t) {
          super(), (this.options = t);
        }
        addText(t) {
          t !== "" && this.add(t);
        }
        startScope(t) {
          this.openNode(t);
        }
        endScope() {
          this.closeNode();
        }
        __addSublanguage(t, a) {
          let d = t.root;
          a && (d.scope = "language:" + a), this.add(d);
        }
        toHTML() {
          return new r(this, this.options).value();
        }
        finalize() {
          return this.closeAllNodes(), !0;
        }
      }
      function s(e) {
        return e ? (typeof e == "string" ? e : e.source) : null;
      }
      function f(e) {
        return x("(?=", e, ")");
      }
      function g(e) {
        return x("(?:", e, ")*");
      }
      function v(e) {
        return x("(?:", e, ")?");
      }
      function x(...e) {
        return e.map((t) => s(t)).join("");
      }
      function E(...e) {
        return (
          "(" +
          (((a) => {
            let d = a[a.length - 1];
            return typeof d == "object" && d.constructor === Object
              ? (a.splice(a.length - 1, 1), d)
              : {};
          })(e).capture
            ? ""
            : "?:") +
          e.map((a) => s(a)).join("|") +
          ")"
        );
      }
      function W(e) {
        return RegExp(e.toString() + "|").exec("").length - 1;
      }
      let R = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
      function c(e, { joinWith: t }) {
        let a = 0;
        return e
          .map((d) => {
            a += 1;
            let y = a,
              u = s(d),
              _ = "";
            for (; u.length > 0; ) {
              let p = R.exec(u);
              if (!p) {
                _ += u;
                break;
              }
              (_ += u.substring(0, p.index)),
                (u = u.substring(p.index + p[0].length)),
                p[0][0] === "\\" && p[1]
                  ? (_ += "\\" + (Number(p[1]) + y))
                  : ((_ += p[0]), p[0] === "(" && a++);
            }
            return _;
          })
          .map((d) => `(${d})`)
          .join(t);
      }
      let w = "[a-zA-Z]\\w*",
        k = "[a-zA-Z_]\\w*",
        B = "\\b\\d+(\\.\\d+)?",
        T =
          "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",
        V = "\\b(0b[01]+)",
        ye = { begin: "\\\\[\\s\\S]", relevance: 0 },
        Ne = {
          scope: "string",
          begin: "'",
          end: "'",
          illegal: "\\n",
          contains: [ye],
        },
        ge = {
          scope: "string",
          begin: '"',
          end: '"',
          illegal: "\\n",
          contains: [ye],
        },
        b = (e, t, a = {}) => {
          let d = i({ scope: "comment", begin: e, end: t, contains: [] }, a);
          d.contains.push({
            scope: "doctag",
            begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
            end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
            excludeBegin: !0,
            relevance: 0,
          });
          let y = E(
            "I",
            "a",
            "is",
            "so",
            "us",
            "to",
            "at",
            "if",
            "in",
            "it",
            "on",
            /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
            /[A-Za-z]+[-][a-z]+/,
            /[A-Za-z][a-z]{2,}/
          );
          return (
            d.contains.push({
              begin: x(/[ ]+/, "(", y, /[.]?[:]?([.][ ]|[ ])/, "){3}"),
            }),
            d
          );
        },
        A = b("//", "$"),
        Z = b("/\\*", "\\*/"),
        $ = b("#", "$");
      var U = Object.freeze({
        __proto__: null,
        APOS_STRING_MODE: Ne,
        BACKSLASH_ESCAPE: ye,
        BINARY_NUMBER_MODE: { scope: "number", begin: V, relevance: 0 },
        BINARY_NUMBER_RE: V,
        COMMENT: b,
        C_BLOCK_COMMENT_MODE: Z,
        C_LINE_COMMENT_MODE: A,
        C_NUMBER_MODE: { scope: "number", begin: T, relevance: 0 },
        C_NUMBER_RE: T,
        END_SAME_AS_BEGIN: (e) =>
          Object.assign(e, {
            "on:begin": (t, a) => {
              a.data._beginMatch = t[1];
            },
            "on:end": (t, a) => {
              a.data._beginMatch !== t[1] && a.ignoreMatch();
            },
          }),
        HASH_COMMENT_MODE: $,
        IDENT_RE: w,
        MATCH_NOTHING_RE: /\b\B/,
        METHOD_GUARD: { begin: "\\.\\s*" + k, relevance: 0 },
        NUMBER_MODE: { scope: "number", begin: B, relevance: 0 },
        NUMBER_RE: B,
        PHRASAL_WORDS_MODE: {
          begin:
            /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/,
        },
        QUOTE_STRING_MODE: ge,
        REGEXP_MODE: {
          scope: "regexp",
          begin: /\/(?=[^/\n]*\/)/,
          end: /\/[gimuy]*/,
          contains: [
            ye,
            { begin: /\[/, end: /\]/, relevance: 0, contains: [ye] },
          ],
        },
        RE_STARTERS_RE:
          "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",
        SHEBANG: (e = {}) => {
          let t = /^#![ ]*\//;
          return (
            e.binary && (e.begin = x(t, /.*\b/, e.binary, /\b.*/)),
            i(
              {
                scope: "meta",
                begin: t,
                end: /$/,
                relevance: 0,
                "on:begin": (a, d) => {
                  a.index !== 0 && d.ignoreMatch();
                },
              },
              e
            )
          );
        },
        TITLE_MODE: { scope: "title", begin: w, relevance: 0 },
        UNDERSCORE_IDENT_RE: k,
        UNDERSCORE_TITLE_MODE: { scope: "title", begin: k, relevance: 0 },
      });
      function F(e, t) {
        e.input[e.index - 1] === "." && t.ignoreMatch();
      }
      function Q(e, t) {
        e.className !== void 0 && ((e.scope = e.className), delete e.className);
      }
      function de(e, t) {
        t &&
          e.beginKeywords &&
          ((e.begin =
            "\\b(" +
            e.beginKeywords.split(" ").join("|") +
            ")(?!\\.)(?=\\b|\\s)"),
          (e.__beforeBegin = F),
          (e.keywords = e.keywords || e.beginKeywords),
          delete e.beginKeywords,
          e.relevance === void 0 && (e.relevance = 0));
      }
      function ke(e, t) {
        Array.isArray(e.illegal) && (e.illegal = E(...e.illegal));
      }
      function Ae(e, t) {
        if (e.match) {
          if (e.begin || e.end)
            throw Error("begin & end are not supported with match");
          (e.begin = e.match), delete e.match;
        }
      }
      function se(e, t) {
        e.relevance === void 0 && (e.relevance = 1);
      }
      let X = (e, t) => {
          if (!e.beforeMatch) return;
          if (e.starts) throw Error("beforeMatch cannot be used with starts");
          let a = Object.assign({}, e);
          Object.keys(e).forEach((d) => {
            delete e[d];
          }),
            (e.keywords = a.keywords),
            (e.begin = x(a.beforeMatch, f(a.begin))),
            (e.starts = {
              relevance: 0,
              contains: [Object.assign(a, { endsParent: !0 })],
            }),
            (e.relevance = 0),
            delete a.beforeMatch;
        },
        le = [
          "of",
          "and",
          "for",
          "in",
          "not",
          "or",
          "if",
          "then",
          "parent",
          "list",
          "value",
        ];
      function J(e, t, a = "keyword") {
        let d = Object.create(null);
        return (
          typeof e == "string"
            ? y(a, e.split(" "))
            : Array.isArray(e)
            ? y(a, e)
            : Object.keys(e).forEach((u) => {
                Object.assign(d, J(e[u], t, u));
              }),
          d
        );
        function y(u, _) {
          t && (_ = _.map((p) => p.toLowerCase())),
            _.forEach((p) => {
              let L = p.split("|");
              d[L[0]] = [u, re(L[0], L[1])];
            });
        }
      }
      function re(e, t) {
        return t ? Number(t) : ((a) => le.includes(a.toLowerCase()))(e) ? 0 : 1;
      }
      let oe = {},
        ie = (e) => {
          console.error(e);
        },
        we = (e, ...t) => {
          console.log("WARN: " + e, ...t);
        },
        ue = (e, t) => {
          oe[`${e}/${t}`] ||
            (console.log(`Deprecated as of ${e}. ${t}`),
            (oe[`${e}/${t}`] = !0));
        },
        me = Error();
      function be(e, t, { key: a }) {
        let d = 0,
          y = e[a],
          u = {},
          _ = {};
        for (let p = 1; p <= t.length; p++)
          (_[p + d] = y[p]), (u[p + d] = !0), (d += W(t[p - 1]));
        (e[a] = _), (e[a]._emit = u), (e[a]._multi = !0);
      }
      function _e(e) {
        ((t) => {
          t.scope &&
            typeof t.scope == "object" &&
            t.scope !== null &&
            ((t.beginScope = t.scope), delete t.scope);
        })(e),
          typeof e.beginScope == "string" &&
            (e.beginScope = { _wrap: e.beginScope }),
          typeof e.endScope == "string" && (e.endScope = { _wrap: e.endScope }),
          ((t) => {
            if (Array.isArray(t.begin)) {
              if (t.skip || t.excludeBegin || t.returnBegin)
                throw (
                  (ie(
                    "skip, excludeBegin, returnBegin not compatible with beginScope: {}"
                  ),
                  me)
                );
              if (typeof t.beginScope != "object" || t.beginScope === null)
                throw (ie("beginScope must be object"), me);
              be(t, t.begin, { key: "beginScope" }),
                (t.begin = c(t.begin, { joinWith: "" }));
            }
          })(e),
          ((t) => {
            if (Array.isArray(t.end)) {
              if (t.skip || t.excludeEnd || t.returnEnd)
                throw (
                  (ie(
                    "skip, excludeEnd, returnEnd not compatible with endScope: {}"
                  ),
                  me)
                );
              if (typeof t.endScope != "object" || t.endScope === null)
                throw (ie("endScope must be object"), me);
              be(t, t.end, { key: "endScope" }),
                (t.end = c(t.end, { joinWith: "" }));
            }
          })(e);
      }
      function qe(e) {
        function t(y, u) {
          return RegExp(
            s(y),
            "m" +
              (e.case_insensitive ? "i" : "") +
              (e.unicodeRegex ? "u" : "") +
              (u ? "g" : "")
          );
        }
        class a {
          constructor() {
            (this.matchIndexes = {}),
              (this.regexes = []),
              (this.matchAt = 1),
              (this.position = 0);
          }
          addRule(u, _) {
            (_.position = this.position++),
              (this.matchIndexes[this.matchAt] = _),
              this.regexes.push([_, u]),
              (this.matchAt += W(u) + 1);
          }
          compile() {
            this.regexes.length === 0 && (this.exec = () => null);
            let u = this.regexes.map((_) => _[1]);
            (this.matcherRe = t(c(u, { joinWith: "|" }), !0)),
              (this.lastIndex = 0);
          }
          exec(u) {
            this.matcherRe.lastIndex = this.lastIndex;
            let _ = this.matcherRe.exec(u);
            if (!_) return null;
            let p = _.findIndex((I, q) => q > 0 && I !== void 0),
              L = this.matchIndexes[p];
            return _.splice(0, p), Object.assign(_, L);
          }
        }
        class d {
          constructor() {
            (this.rules = []),
              (this.multiRegexes = []),
              (this.count = 0),
              (this.lastIndex = 0),
              (this.regexIndex = 0);
          }
          getMatcher(u) {
            if (this.multiRegexes[u]) return this.multiRegexes[u];
            let _ = new a();
            return (
              this.rules.slice(u).forEach(([p, L]) => _.addRule(p, L)),
              _.compile(),
              (this.multiRegexes[u] = _),
              _
            );
          }
          resumingScanAtSamePosition() {
            return this.regexIndex !== 0;
          }
          considerAll() {
            this.regexIndex = 0;
          }
          addRule(u, _) {
            this.rules.push([u, _]), _.type === "begin" && this.count++;
          }
          exec(u) {
            let _ = this.getMatcher(this.regexIndex);
            _.lastIndex = this.lastIndex;
            let p = _.exec(u);
            if (
              this.resumingScanAtSamePosition() &&
              !(p && p.index === this.lastIndex)
            ) {
              let L = this.getMatcher(0);
              (L.lastIndex = this.lastIndex + 1), (p = L.exec(u));
            }
            return (
              p &&
                ((this.regexIndex += p.position + 1),
                this.regexIndex === this.count && this.considerAll()),
              p
            );
          }
        }
        if (
          (e.compilerExtensions || (e.compilerExtensions = []),
          e.contains && e.contains.includes("self"))
        )
          throw Error(
            "ERR: contains `self` is not supported at the top-level of a language.  See documentation."
          );
        return (
          (e.classNameAliases = i(e.classNameAliases || {})),
          (function y(u, _) {
            let p = u;
            if (u.isCompiled) return p;
            [Q, Ae, _e, X].forEach((I) => I(u, _)),
              e.compilerExtensions.forEach((I) => I(u, _)),
              (u.__beforeBegin = null),
              [de, ke, se].forEach((I) => I(u, _)),
              (u.isCompiled = !0);
            let L = null;
            return (
              typeof u.keywords == "object" &&
                u.keywords.$pattern &&
                ((u.keywords = Object.assign({}, u.keywords)),
                (L = u.keywords.$pattern),
                delete u.keywords.$pattern),
              (L = L || /\w+/),
              u.keywords && (u.keywords = J(u.keywords, e.case_insensitive)),
              (p.keywordPatternRe = t(L, !0)),
              _ &&
                (u.begin || (u.begin = /\B|\b/),
                (p.beginRe = t(p.begin)),
                u.end || u.endsWithParent || (u.end = /\B|\b/),
                u.end && (p.endRe = t(p.end)),
                (p.terminatorEnd = s(p.end) || ""),
                u.endsWithParent &&
                  _.terminatorEnd &&
                  (p.terminatorEnd += (u.end ? "|" : "") + _.terminatorEnd)),
              u.illegal && (p.illegalRe = t(u.illegal)),
              u.contains || (u.contains = []),
              (u.contains = [].concat(
                ...u.contains.map((I) =>
                  ((q) => (
                    q.variants &&
                      !q.cachedVariants &&
                      (q.cachedVariants = q.variants.map((ae) =>
                        i(q, { variants: null }, ae)
                      )),
                    q.cachedVariants
                      ? q.cachedVariants
                      : Ue(q)
                      ? i(q, { starts: q.starts ? i(q.starts) : null })
                      : Object.isFrozen(q)
                      ? i(q)
                      : q
                  ))(I === "self" ? u : I)
                )
              )),
              u.contains.forEach((I) => {
                y(I, p);
              }),
              u.starts && y(u.starts, _),
              (p.matcher = ((I) => {
                let q = new d();
                return (
                  I.contains.forEach((ae) =>
                    q.addRule(ae.begin, { rule: ae, type: "begin" })
                  ),
                  I.terminatorEnd &&
                    q.addRule(I.terminatorEnd, { type: "end" }),
                  I.illegal && q.addRule(I.illegal, { type: "illegal" }),
                  q
                );
              })(p)),
              p
            );
          })(e)
        );
      }
      function Ue(e) {
        return !!e && (e.endsWithParent || Ue(e.starts));
      }
      class Qe extends Error {
        constructor(t, a) {
          super(t), (this.name = "HTMLInjectionError"), (this.html = a);
        }
      }
      let Ce = P,
        Be = i,
        l = Symbol("nomatch"),
        h = (e) => {
          let t = Object.create(null),
            a = Object.create(null),
            d = [],
            y = !0,
            u =
              "Could not find the language '{}', did you forget to load/include a language module?",
            _ = { disableAutodetect: !0, name: "Plain text", contains: [] },
            p = {
              ignoreUnescapedHTML: !1,
              throwUnescapedHTML: !1,
              noHighlightRe: /^(no-?highlight)$/i,
              languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
              classPrefix: "hljs-",
              cssSelector: "pre code",
              languages: null,
              __emitter: C,
            };
          function L(z) {
            return p.noHighlightRe.test(z);
          }
          function I(z, Y, pe) {
            let Ke = "",
              Pe = "";
            typeof Y == "object"
              ? ((Ke = z), (pe = Y.ignoreIllegals), (Pe = Y.language))
              : (ue(
                  "10.7.0",
                  "highlight(lang, code, ...args) has been deprecated."
                ),
                ue(
                  "10.7.0",
                  `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`
                ),
                (Pe = z),
                (Ke = Y)),
              pe === void 0 && (pe = !0);
            let Fe = { code: Ke, language: Pe };
            Xe("before:highlight", Fe);
            let Me = Fe.result ? Fe.result : q(Fe.language, Fe.code, pe);
            return (Me.code = Fe.code), Xe("after:highlight", Me), Me;
          }
          function q(z, Y, pe, Ke) {
            let Pe = Object.create(null);
            function Fe() {
              if (!fe.keywords) return void he.addText(Re);
              let K = 0;
              fe.keywordPatternRe.lastIndex = 0;
              let ce = fe.keywordPatternRe.exec(Re),
                $e = "";
              for (; ce; ) {
                $e += Re.substring(K, ce.index);
                let We = tt.case_insensitive ? ce[0].toLowerCase() : ce[0],
                  Je = ((ze = We), fe.keywords[ze]);
                if (Je) {
                  let [dt, Pt] = Je;
                  if (
                    (he.addText($e),
                    ($e = ""),
                    (Pe[We] = (Pe[We] || 0) + 1),
                    Pe[We] <= 7 && (lt += Pt),
                    dt.startsWith("_"))
                  )
                    $e += ce[0];
                  else {
                    let It = tt.classNameAliases[dt] || dt;
                    Te(ce[0], It);
                  }
                } else $e += ce[0];
                (K = fe.keywordPatternRe.lastIndex),
                  (ce = fe.keywordPatternRe.exec(Re));
              }
              var ze;
              ($e += Re.substring(K)), he.addText($e);
            }
            function Me() {
              fe.subLanguage != null
                ? (() => {
                    if (Re === "") return;
                    let K = null;
                    if (typeof fe.subLanguage == "string") {
                      if (!t[fe.subLanguage]) return void he.addText(Re);
                      (K = q(fe.subLanguage, Re, !0, Tt[fe.subLanguage])),
                        (Tt[fe.subLanguage] = K._top);
                    } else
                      K = ae(Re, fe.subLanguage.length ? fe.subLanguage : null);
                    fe.relevance > 0 && (lt += K.relevance),
                      he.__addSublanguage(K._emitter, K.language);
                  })()
                : Fe(),
                (Re = "");
            }
            function Te(K, ce) {
              K !== "" && (he.startScope(ce), he.addText(K), he.endScope());
            }
            function Oe(K, ce) {
              let $e = 1,
                ze = ce.length - 1;
              for (; $e <= ze; ) {
                if (!K._emit[$e]) {
                  $e++;
                  continue;
                }
                let We = tt.classNameAliases[K[$e]] || K[$e],
                  Je = ce[$e];
                We ? Te(Je, We) : ((Re = Je), Fe(), (Re = "")), $e++;
              }
            }
            function Ve(K, ce) {
              return (
                K.scope &&
                  typeof K.scope == "string" &&
                  he.openNode(tt.classNameAliases[K.scope] || K.scope),
                K.beginScope &&
                  (K.beginScope._wrap
                    ? (Te(
                        Re,
                        tt.classNameAliases[K.beginScope._wrap] ||
                          K.beginScope._wrap
                      ),
                      (Re = ""))
                    : K.beginScope._multi && (Oe(K.beginScope, ce), (Re = ""))),
                (fe = Object.create(K, { parent: { value: fe } })),
                fe
              );
            }
            function nt(K, ce, $e) {
              let ze = ((We, Je) => {
                let dt = We && We.exec(Je);
                return dt && dt.index === 0;
              })(K.endRe, $e);
              if (ze) {
                if (K["on:end"]) {
                  let We = new S(K);
                  K["on:end"](ce, We), We.isMatchIgnored && (ze = !1);
                }
                if (ze) {
                  for (; K.endsParent && K.parent; ) K = K.parent;
                  return K;
                }
              }
              if (K.endsWithParent) return nt(K.parent, ce, $e);
            }
            function bt(K) {
              return fe.matcher.regexIndex === 0
                ? ((Re += K[0]), 1)
                : ((zt = !0), 0);
            }
            function pt(K) {
              let ce = K[0],
                $e = Y.substring(K.index),
                ze = nt(fe, K, $e);
              if (!ze) return l;
              let We = fe;
              fe.endScope && fe.endScope._wrap
                ? (Me(), Te(ce, fe.endScope._wrap))
                : fe.endScope && fe.endScope._multi
                ? (Me(), Oe(fe.endScope, K))
                : We.skip
                ? (Re += ce)
                : (We.returnEnd || We.excludeEnd || (Re += ce),
                  Me(),
                  We.excludeEnd && (Re = ce));
              do
                fe.scope && he.closeNode(),
                  fe.skip || fe.subLanguage || (lt += fe.relevance),
                  (fe = fe.parent);
              while (fe !== ze.parent);
              return (
                ze.starts && Ve(ze.starts, K), We.returnEnd ? 0 : ce.length
              );
            }
            let at = {};
            function ft(K, ce) {
              let $e = ce && ce[0];
              if (((Re += K), $e == null)) return Me(), 0;
              if (
                at.type === "begin" &&
                ce.type === "end" &&
                at.index === ce.index &&
                $e === ""
              ) {
                if (((Re += Y.slice(ce.index, ce.index + 1)), !y)) {
                  let ze = Error(`0 width match regex (${z})`);
                  throw ((ze.languageName = z), (ze.badRule = at.rule), ze);
                }
                return 1;
              }
              if (((at = ce), ce.type === "begin"))
                return ((ze) => {
                  let We = ze[0],
                    Je = ze.rule,
                    dt = new S(Je),
                    Pt = [Je.__beforeBegin, Je["on:begin"]];
                  for (let It of Pt)
                    if (It && (It(ze, dt), dt.isMatchIgnored)) return bt(We);
                  return (
                    Je.skip
                      ? (Re += We)
                      : (Je.excludeBegin && (Re += We),
                        Me(),
                        Je.returnBegin || Je.excludeBegin || (Re = We)),
                    Ve(Je, ze),
                    Je.returnBegin ? 0 : We.length
                  );
                })(ce);
              if (ce.type === "illegal" && !pe) {
                let ze = Error(
                  'Illegal lexeme "' +
                    $e +
                    '" for mode "' +
                    (fe.scope || "<unnamed>") +
                    '"'
                );
                throw ((ze.mode = fe), ze);
              }
              if (ce.type === "end") {
                let ze = pt(ce);
                if (ze !== l) return ze;
              }
              if (ce.type === "illegal" && $e === "")
                return (
                  (Re += `
`),
                  1
                );
              if (Ft > 1e5 && Ft > 3 * ce.index)
                throw Error(
                  "potential infinite loop, way more iterations than matches"
                );
              return (Re += $e), $e.length;
            }
            let tt = Se(z);
            if (!tt)
              throw (
                (ie(u.replace("{}", z)), Error('Unknown language: "' + z + '"'))
              );
            let St = qe(tt),
              ht = "",
              fe = Ke || St,
              Tt = {},
              he = new p.__emitter(p);
            (() => {
              let K = [];
              for (let ce = fe; ce !== tt; ce = ce.parent)
                ce.scope && K.unshift(ce.scope);
              K.forEach((ce) => he.openNode(ce));
            })();
            let Re = "",
              lt = 0,
              ct = 0,
              Ft = 0,
              zt = !1;
            try {
              if (tt.__emitTokens) tt.__emitTokens(Y, he);
              else {
                for (fe.matcher.considerAll(); ; ) {
                  Ft++,
                    zt ? (zt = !1) : fe.matcher.considerAll(),
                    (fe.matcher.lastIndex = ct);
                  let K = fe.matcher.exec(Y);
                  if (!K) break;
                  let ce = ft(Y.substring(ct, K.index), K);
                  ct = K.index + ce;
                }
                ft(Y.substring(ct));
              }
              return (
                he.finalize(),
                (ht = he.toHTML()),
                {
                  language: z,
                  value: ht,
                  relevance: lt,
                  illegal: !1,
                  _emitter: he,
                  _top: fe,
                }
              );
            } catch (K) {
              if (K.message && K.message.includes("Illegal"))
                return {
                  language: z,
                  value: Ce(Y),
                  illegal: !0,
                  relevance: 0,
                  _illegalBy: {
                    message: K.message,
                    index: ct,
                    context: Y.slice(ct - 100, ct + 100),
                    mode: K.mode,
                    resultSoFar: ht,
                  },
                  _emitter: he,
                };
              if (y)
                return {
                  language: z,
                  value: Ce(Y),
                  illegal: !1,
                  relevance: 0,
                  errorRaised: K,
                  _emitter: he,
                  _top: fe,
                };
              throw K;
            }
          }
          function ae(z, Y) {
            Y = Y || p.languages || Object.keys(t);
            let pe = ((Oe) => {
                let Ve = {
                  value: Ce(Oe),
                  illegal: !1,
                  relevance: 0,
                  _top: _,
                  _emitter: new p.__emitter(p),
                };
                return Ve._emitter.addText(Oe), Ve;
              })(z),
              Ke = Y.filter(Se)
                .filter(et)
                .map((Oe) => q(Oe, z, !1));
            Ke.unshift(pe);
            let Pe = Ke.sort((Oe, Ve) => {
                if (Oe.relevance !== Ve.relevance)
                  return Ve.relevance - Oe.relevance;
                if (Oe.language && Ve.language) {
                  if (Se(Oe.language).supersetOf === Ve.language) return 1;
                  if (Se(Ve.language).supersetOf === Oe.language) return -1;
                }
                return 0;
              }),
              [Fe, Me] = Pe,
              Te = Fe;
            return (Te.secondBest = Me), Te;
          }
          function G(z) {
            let Y = null,
              pe = ((Fe) => {
                let Me = Fe.className + " ";
                Me += Fe.parentNode ? Fe.parentNode.className : "";
                let Te = p.languageDetectRe.exec(Me);
                if (Te) {
                  let Oe = Se(Te[1]);
                  return (
                    Oe ||
                      (we(u.replace("{}", Te[1])),
                      we(
                        "Falling back to no-highlight mode for this block.",
                        Fe
                      )),
                    Oe ? Te[1] : "no-highlight"
                  );
                }
                return Me.split(/\s+/).find((Oe) => L(Oe) || Se(Oe));
              })(z);
            if (L(pe)) return;
            if (
              (Xe("before:highlightElement", { el: z, language: pe }),
              z.dataset.highlighted)
            )
              return void console.log(
                "Element previously highlighted. To highlight again, first unset `dataset.highlighted`.",
                z
              );
            if (
              z.children.length > 0 &&
              (p.ignoreUnescapedHTML ||
                (console.warn(
                  "One of your code blocks includes unescaped HTML. This is a potentially serious security risk."
                ),
                console.warn(
                  "https://github.com/highlightjs/highlight.js/wiki/security"
                ),
                console.warn("The element with unescaped HTML:"),
                console.warn(z)),
              p.throwUnescapedHTML)
            )
              throw new Qe(
                "One of your code blocks includes unescaped HTML.",
                z.innerHTML
              );
            Y = z;
            let Ke = Y.textContent,
              Pe = pe ? I(Ke, { language: pe, ignoreIllegals: !0 }) : ae(Ke);
            (z.innerHTML = Pe.value),
              (z.dataset.highlighted = "yes"),
              ((Fe, Me, Te) => {
                let Oe = (Me && a[Me]) || Te;
                Fe.classList.add("hljs"), Fe.classList.add("language-" + Oe);
              })(z, pe, Pe.language),
              (z.result = {
                language: Pe.language,
                re: Pe.relevance,
                relevance: Pe.relevance,
              }),
              Pe.secondBest &&
                (z.secondBest = {
                  language: Pe.secondBest.language,
                  relevance: Pe.secondBest.relevance,
                }),
              Xe("after:highlightElement", { el: z, result: Pe, text: Ke });
          }
          let ve = !1;
          function xe() {
            if (document.readyState === "loading")
              return (
                ve ||
                  window.addEventListener(
                    "DOMContentLoaded",
                    () => {
                      xe();
                    },
                    !1
                  ),
                void (ve = !0)
              );
            document.querySelectorAll(p.cssSelector).forEach(G);
          }
          function Se(z) {
            return (z = (z || "").toLowerCase()), t[z] || t[a[z]];
          }
          function je(z, { languageName: Y }) {
            typeof z == "string" && (z = [z]),
              z.forEach((pe) => {
                a[pe.toLowerCase()] = Y;
              });
          }
          function et(z) {
            let Y = Se(z);
            return Y && !Y.disableAutodetect;
          }
          function Xe(z, Y) {
            let pe = z;
            d.forEach((Ke) => {
              Ke[pe] && Ke[pe](Y);
            });
          }
          Object.assign(e, {
            highlight: I,
            highlightAuto: ae,
            highlightAll: xe,
            highlightElement: G,
            highlightBlock: (z) => (
              ue("10.7.0", "highlightBlock will be removed entirely in v12.0"),
              ue("10.7.0", "Please use highlightElement now."),
              G(z)
            ),
            configure: (z) => {
              p = Be(p, z);
            },
            initHighlighting: () => {
              xe(),
                ue(
                  "10.6.0",
                  "initHighlighting() deprecated.  Use highlightAll() now."
                );
            },
            initHighlightingOnLoad: () => {
              xe(),
                ue(
                  "10.6.0",
                  "initHighlightingOnLoad() deprecated.  Use highlightAll() now."
                );
            },
            registerLanguage: (z, Y) => {
              let pe = null;
              try {
                pe = Y(e);
              } catch (Ke) {
                if (
                  (ie(
                    "Language definition for '{}' could not be registered.".replace(
                      "{}",
                      z
                    )
                  ),
                  !y)
                )
                  throw Ke;
                ie(Ke), (pe = _);
              }
              pe.name || (pe.name = z),
                (t[z] = pe),
                (pe.rawDefinition = Y.bind(null, e)),
                pe.aliases && je(pe.aliases, { languageName: z });
            },
            unregisterLanguage: (z) => {
              delete t[z];
              for (let Y of Object.keys(a)) a[Y] === z && delete a[Y];
            },
            listLanguages: () => Object.keys(t),
            getLanguage: Se,
            registerAliases: je,
            autoDetection: et,
            inherit: Be,
            addPlugin: (z) => {
              ((Y) => {
                Y["before:highlightBlock"] &&
                  !Y["before:highlightElement"] &&
                  (Y["before:highlightElement"] = (pe) => {
                    Y["before:highlightBlock"](
                      Object.assign({ block: pe.el }, pe)
                    );
                  }),
                  Y["after:highlightBlock"] &&
                    !Y["after:highlightElement"] &&
                    (Y["after:highlightElement"] = (pe) => {
                      Y["after:highlightBlock"](
                        Object.assign({ block: pe.el }, pe)
                      );
                    });
              })(z),
                d.push(z);
            },
            removePlugin: (z) => {
              let Y = d.indexOf(z);
              Y !== -1 && d.splice(Y, 1);
            },
          }),
            (e.debugMode = () => {
              y = !1;
            }),
            (e.safeMode = () => {
              y = !0;
            }),
            (e.versionString = "11.11.1"),
            (e.regex = {
              concat: x,
              lookahead: f,
              either: E,
              optional: v,
              anyNumberOfTimes: g,
            });
          for (let z in U) typeof U[z] == "object" && N(U[z]);
          return Object.assign(e, U), e;
        },
        O = h({});
      O.newInstance = () => h({});
      let M = (e) => ({
          IMPORTANT: { scope: "meta", begin: "!important" },
          BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
          HEXCOLOR: {
            scope: "number",
            begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/,
          },
          FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ },
          ATTRIBUTE_SELECTOR_MODE: {
            scope: "selector-attr",
            begin: /\[/,
            end: /\]/,
            illegal: "$",
            contains: [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE],
          },
          CSS_NUMBER_MODE: {
            scope: "number",
            begin:
              e.NUMBER_RE +
              "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
            relevance: 0,
          },
          CSS_VARIABLE: {
            className: "attr",
            begin: /--[A-Za-z_][A-Za-z0-9_-]*/,
          },
        }),
        D = [
          "a",
          "abbr",
          "address",
          "article",
          "aside",
          "audio",
          "b",
          "blockquote",
          "body",
          "button",
          "canvas",
          "caption",
          "cite",
          "code",
          "dd",
          "del",
          "details",
          "dfn",
          "div",
          "dl",
          "dt",
          "em",
          "fieldset",
          "figcaption",
          "figure",
          "footer",
          "form",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "header",
          "hgroup",
          "html",
          "i",
          "iframe",
          "img",
          "input",
          "ins",
          "kbd",
          "label",
          "legend",
          "li",
          "main",
          "mark",
          "menu",
          "nav",
          "object",
          "ol",
          "optgroup",
          "option",
          "p",
          "picture",
          "q",
          "quote",
          "samp",
          "section",
          "select",
          "source",
          "span",
          "strong",
          "summary",
          "sup",
          "table",
          "tbody",
          "td",
          "textarea",
          "tfoot",
          "th",
          "thead",
          "time",
          "tr",
          "ul",
          "var",
          "video",
          "defs",
          "g",
          "marker",
          "mask",
          "pattern",
          "svg",
          "switch",
          "symbol",
          "feBlend",
          "feColorMatrix",
          "feComponentTransfer",
          "feComposite",
          "feConvolveMatrix",
          "feDiffuseLighting",
          "feDisplacementMap",
          "feFlood",
          "feGaussianBlur",
          "feImage",
          "feMerge",
          "feMorphology",
          "feOffset",
          "feSpecularLighting",
          "feTile",
          "feTurbulence",
          "linearGradient",
          "radialGradient",
          "stop",
          "circle",
          "ellipse",
          "image",
          "line",
          "path",
          "polygon",
          "polyline",
          "rect",
          "text",
          "use",
          "textPath",
          "tspan",
          "foreignObject",
          "clipPath",
        ],
        H = [
          "any-hover",
          "any-pointer",
          "aspect-ratio",
          "color",
          "color-gamut",
          "color-index",
          "device-aspect-ratio",
          "device-height",
          "device-width",
          "display-mode",
          "forced-colors",
          "grid",
          "height",
          "hover",
          "inverted-colors",
          "monochrome",
          "orientation",
          "overflow-block",
          "overflow-inline",
          "pointer",
          "prefers-color-scheme",
          "prefers-contrast",
          "prefers-reduced-motion",
          "prefers-reduced-transparency",
          "resolution",
          "scan",
          "scripting",
          "update",
          "width",
          "min-width",
          "max-width",
          "min-height",
          "max-height",
        ]
          .sort()
          .reverse(),
        ee = [
          "active",
          "any-link",
          "blank",
          "checked",
          "current",
          "default",
          "defined",
          "dir",
          "disabled",
          "drop",
          "empty",
          "enabled",
          "first",
          "first-child",
          "first-of-type",
          "fullscreen",
          "future",
          "focus",
          "focus-visible",
          "focus-within",
          "has",
          "host",
          "host-context",
          "hover",
          "indeterminate",
          "in-range",
          "invalid",
          "is",
          "lang",
          "last-child",
          "last-of-type",
          "left",
          "link",
          "local-link",
          "not",
          "nth-child",
          "nth-col",
          "nth-last-child",
          "nth-last-col",
          "nth-last-of-type",
          "nth-of-type",
          "only-child",
          "only-of-type",
          "optional",
          "out-of-range",
          "past",
          "placeholder-shown",
          "read-only",
          "read-write",
          "required",
          "right",
          "root",
          "scope",
          "target",
          "target-within",
          "user-invalid",
          "valid",
          "visited",
          "where",
        ]
          .sort()
          .reverse(),
        te = [
          "after",
          "backdrop",
          "before",
          "cue",
          "cue-region",
          "first-letter",
          "first-line",
          "grammar-error",
          "marker",
          "part",
          "placeholder",
          "selection",
          "slotted",
          "spelling-error",
        ]
          .sort()
          .reverse(),
        j = [
          "accent-color",
          "align-content",
          "align-items",
          "align-self",
          "alignment-baseline",
          "all",
          "anchor-name",
          "animation",
          "animation-composition",
          "animation-delay",
          "animation-direction",
          "animation-duration",
          "animation-fill-mode",
          "animation-iteration-count",
          "animation-name",
          "animation-play-state",
          "animation-range",
          "animation-range-end",
          "animation-range-start",
          "animation-timeline",
          "animation-timing-function",
          "appearance",
          "aspect-ratio",
          "backdrop-filter",
          "backface-visibility",
          "background",
          "background-attachment",
          "background-blend-mode",
          "background-clip",
          "background-color",
          "background-image",
          "background-origin",
          "background-position",
          "background-position-x",
          "background-position-y",
          "background-repeat",
          "background-size",
          "baseline-shift",
          "block-size",
          "border",
          "border-block",
          "border-block-color",
          "border-block-end",
          "border-block-end-color",
          "border-block-end-style",
          "border-block-end-width",
          "border-block-start",
          "border-block-start-color",
          "border-block-start-style",
          "border-block-start-width",
          "border-block-style",
          "border-block-width",
          "border-bottom",
          "border-bottom-color",
          "border-bottom-left-radius",
          "border-bottom-right-radius",
          "border-bottom-style",
          "border-bottom-width",
          "border-collapse",
          "border-color",
          "border-end-end-radius",
          "border-end-start-radius",
          "border-image",
          "border-image-outset",
          "border-image-repeat",
          "border-image-slice",
          "border-image-source",
          "border-image-width",
          "border-inline",
          "border-inline-color",
          "border-inline-end",
          "border-inline-end-color",
          "border-inline-end-style",
          "border-inline-end-width",
          "border-inline-start",
          "border-inline-start-color",
          "border-inline-start-style",
          "border-inline-start-width",
          "border-inline-style",
          "border-inline-width",
          "border-left",
          "border-left-color",
          "border-left-style",
          "border-left-width",
          "border-radius",
          "border-right",
          "border-right-color",
          "border-right-style",
          "border-right-width",
          "border-spacing",
          "border-start-end-radius",
          "border-start-start-radius",
          "border-style",
          "border-top",
          "border-top-color",
          "border-top-left-radius",
          "border-top-right-radius",
          "border-top-style",
          "border-top-width",
          "border-width",
          "bottom",
          "box-align",
          "box-decoration-break",
          "box-direction",
          "box-flex",
          "box-flex-group",
          "box-lines",
          "box-ordinal-group",
          "box-orient",
          "box-pack",
          "box-shadow",
          "box-sizing",
          "break-after",
          "break-before",
          "break-inside",
          "caption-side",
          "caret-color",
          "clear",
          "clip",
          "clip-path",
          "clip-rule",
          "color",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "color-scheme",
          "column-count",
          "column-fill",
          "column-gap",
          "column-rule",
          "column-rule-color",
          "column-rule-style",
          "column-rule-width",
          "column-span",
          "column-width",
          "columns",
          "contain",
          "contain-intrinsic-block-size",
          "contain-intrinsic-height",
          "contain-intrinsic-inline-size",
          "contain-intrinsic-size",
          "contain-intrinsic-width",
          "container",
          "container-name",
          "container-type",
          "content",
          "content-visibility",
          "counter-increment",
          "counter-reset",
          "counter-set",
          "cue",
          "cue-after",
          "cue-before",
          "cursor",
          "cx",
          "cy",
          "direction",
          "display",
          "dominant-baseline",
          "empty-cells",
          "enable-background",
          "field-sizing",
          "fill",
          "fill-opacity",
          "fill-rule",
          "filter",
          "flex",
          "flex-basis",
          "flex-direction",
          "flex-flow",
          "flex-grow",
          "flex-shrink",
          "flex-wrap",
          "float",
          "flood-color",
          "flood-opacity",
          "flow",
          "font",
          "font-display",
          "font-family",
          "font-feature-settings",
          "font-kerning",
          "font-language-override",
          "font-optical-sizing",
          "font-palette",
          "font-size",
          "font-size-adjust",
          "font-smooth",
          "font-smoothing",
          "font-stretch",
          "font-style",
          "font-synthesis",
          "font-synthesis-position",
          "font-synthesis-small-caps",
          "font-synthesis-style",
          "font-synthesis-weight",
          "font-variant",
          "font-variant-alternates",
          "font-variant-caps",
          "font-variant-east-asian",
          "font-variant-emoji",
          "font-variant-ligatures",
          "font-variant-numeric",
          "font-variant-position",
          "font-variation-settings",
          "font-weight",
          "forced-color-adjust",
          "gap",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "grid",
          "grid-area",
          "grid-auto-columns",
          "grid-auto-flow",
          "grid-auto-rows",
          "grid-column",
          "grid-column-end",
          "grid-column-start",
          "grid-gap",
          "grid-row",
          "grid-row-end",
          "grid-row-start",
          "grid-template",
          "grid-template-areas",
          "grid-template-columns",
          "grid-template-rows",
          "hanging-punctuation",
          "height",
          "hyphenate-character",
          "hyphenate-limit-chars",
          "hyphens",
          "icon",
          "image-orientation",
          "image-rendering",
          "image-resolution",
          "ime-mode",
          "initial-letter",
          "initial-letter-align",
          "inline-size",
          "inset",
          "inset-area",
          "inset-block",
          "inset-block-end",
          "inset-block-start",
          "inset-inline",
          "inset-inline-end",
          "inset-inline-start",
          "isolation",
          "justify-content",
          "justify-items",
          "justify-self",
          "kerning",
          "left",
          "letter-spacing",
          "lighting-color",
          "line-break",
          "line-height",
          "line-height-step",
          "list-style",
          "list-style-image",
          "list-style-position",
          "list-style-type",
          "margin",
          "margin-block",
          "margin-block-end",
          "margin-block-start",
          "margin-bottom",
          "margin-inline",
          "margin-inline-end",
          "margin-inline-start",
          "margin-left",
          "margin-right",
          "margin-top",
          "margin-trim",
          "marker",
          "marker-end",
          "marker-mid",
          "marker-start",
          "marks",
          "mask",
          "mask-border",
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width",
          "mask-clip",
          "mask-composite",
          "mask-image",
          "mask-mode",
          "mask-origin",
          "mask-position",
          "mask-repeat",
          "mask-size",
          "mask-type",
          "masonry-auto-flow",
          "math-depth",
          "math-shift",
          "math-style",
          "max-block-size",
          "max-height",
          "max-inline-size",
          "max-width",
          "min-block-size",
          "min-height",
          "min-inline-size",
          "min-width",
          "mix-blend-mode",
          "nav-down",
          "nav-index",
          "nav-left",
          "nav-right",
          "nav-up",
          "none",
          "normal",
          "object-fit",
          "object-position",
          "offset",
          "offset-anchor",
          "offset-distance",
          "offset-path",
          "offset-position",
          "offset-rotate",
          "opacity",
          "order",
          "orphans",
          "outline",
          "outline-color",
          "outline-offset",
          "outline-style",
          "outline-width",
          "overflow",
          "overflow-anchor",
          "overflow-block",
          "overflow-clip-margin",
          "overflow-inline",
          "overflow-wrap",
          "overflow-x",
          "overflow-y",
          "overlay",
          "overscroll-behavior",
          "overscroll-behavior-block",
          "overscroll-behavior-inline",
          "overscroll-behavior-x",
          "overscroll-behavior-y",
          "padding",
          "padding-block",
          "padding-block-end",
          "padding-block-start",
          "padding-bottom",
          "padding-inline",
          "padding-inline-end",
          "padding-inline-start",
          "padding-left",
          "padding-right",
          "padding-top",
          "page",
          "page-break-after",
          "page-break-before",
          "page-break-inside",
          "paint-order",
          "pause",
          "pause-after",
          "pause-before",
          "perspective",
          "perspective-origin",
          "place-content",
          "place-items",
          "place-self",
          "pointer-events",
          "position",
          "position-anchor",
          "position-visibility",
          "print-color-adjust",
          "quotes",
          "r",
          "resize",
          "rest",
          "rest-after",
          "rest-before",
          "right",
          "rotate",
          "row-gap",
          "ruby-align",
          "ruby-position",
          "scale",
          "scroll-behavior",
          "scroll-margin",
          "scroll-margin-block",
          "scroll-margin-block-end",
          "scroll-margin-block-start",
          "scroll-margin-bottom",
          "scroll-margin-inline",
          "scroll-margin-inline-end",
          "scroll-margin-inline-start",
          "scroll-margin-left",
          "scroll-margin-right",
          "scroll-margin-top",
          "scroll-padding",
          "scroll-padding-block",
          "scroll-padding-block-end",
          "scroll-padding-block-start",
          "scroll-padding-bottom",
          "scroll-padding-inline",
          "scroll-padding-inline-end",
          "scroll-padding-inline-start",
          "scroll-padding-left",
          "scroll-padding-right",
          "scroll-padding-top",
          "scroll-snap-align",
          "scroll-snap-stop",
          "scroll-snap-type",
          "scroll-timeline",
          "scroll-timeline-axis",
          "scroll-timeline-name",
          "scrollbar-color",
          "scrollbar-gutter",
          "scrollbar-width",
          "shape-image-threshold",
          "shape-margin",
          "shape-outside",
          "shape-rendering",
          "speak",
          "speak-as",
          "src",
          "stop-color",
          "stop-opacity",
          "stroke",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "tab-size",
          "table-layout",
          "text-align",
          "text-align-all",
          "text-align-last",
          "text-anchor",
          "text-combine-upright",
          "text-decoration",
          "text-decoration-color",
          "text-decoration-line",
          "text-decoration-skip",
          "text-decoration-skip-ink",
          "text-decoration-style",
          "text-decoration-thickness",
          "text-emphasis",
          "text-emphasis-color",
          "text-emphasis-position",
          "text-emphasis-style",
          "text-indent",
          "text-justify",
          "text-orientation",
          "text-overflow",
          "text-rendering",
          "text-shadow",
          "text-size-adjust",
          "text-transform",
          "text-underline-offset",
          "text-underline-position",
          "text-wrap",
          "text-wrap-mode",
          "text-wrap-style",
          "timeline-scope",
          "top",
          "touch-action",
          "transform",
          "transform-box",
          "transform-origin",
          "transform-style",
          "transition",
          "transition-behavior",
          "transition-delay",
          "transition-duration",
          "transition-property",
          "transition-timing-function",
          "translate",
          "unicode-bidi",
          "user-modify",
          "user-select",
          "vector-effect",
          "vertical-align",
          "view-timeline",
          "view-timeline-axis",
          "view-timeline-inset",
          "view-timeline-name",
          "view-transition-name",
          "visibility",
          "voice-balance",
          "voice-duration",
          "voice-family",
          "voice-pitch",
          "voice-range",
          "voice-rate",
          "voice-stress",
          "voice-volume",
          "white-space",
          "white-space-collapse",
          "widows",
          "width",
          "will-change",
          "word-break",
          "word-spacing",
          "word-wrap",
          "writing-mode",
          "x",
          "y",
          "z-index",
          "zoom",
        ]
          .sort()
          .reverse(),
        ne = ee.concat(te).sort().reverse();
      var Ee = "[0-9](_*[0-9])*",
        Ie = `\\.(${Ee})`,
        Ge = "[0-9a-fA-F](_*[0-9a-fA-F])*",
        Ze = {
          className: "number",
          variants: [
            {
              begin: `(\\b(${Ee})((${Ie})|\\.)?|(${Ie}))[eE][+-]?(${Ee})[fFdD]?\\b`,
            },
            { begin: `\\b(${Ee})((${Ie})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
            { begin: `(${Ie})[fFdD]?\\b` },
            { begin: `\\b(${Ee})[fFdD]\\b` },
            {
              begin: `\\b0[xX]((${Ge})\\.?|(${Ge})?\\.(${Ge}))[pP][+-]?(${Ee})[fFdD]?\\b`,
            },
            { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
            { begin: `\\b0[xX](${Ge})[lL]?\\b` },
            { begin: "\\b0(_*[0-7])*[lL]?\\b" },
            { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" },
          ],
          relevance: 0,
        };
      function Le(e, t, a) {
        return a === -1 ? "" : e.replace(t, (d) => Le(e, t, a - 1));
      }
      let He = "[A-Za-z$_][0-9A-Za-z$_]*",
        De = [
          "as",
          "in",
          "of",
          "if",
          "for",
          "while",
          "finally",
          "var",
          "new",
          "function",
          "do",
          "return",
          "void",
          "else",
          "break",
          "catch",
          "instanceof",
          "with",
          "throw",
          "case",
          "default",
          "try",
          "switch",
          "continue",
          "typeof",
          "delete",
          "let",
          "yield",
          "const",
          "class",
          "debugger",
          "async",
          "await",
          "static",
          "import",
          "from",
          "export",
          "extends",
          "using",
        ],
        Ye = ["true", "false", "null", "undefined", "NaN", "Infinity"],
        it = [
          "Object",
          "Function",
          "Boolean",
          "Symbol",
          "Math",
          "Date",
          "Number",
          "BigInt",
          "String",
          "RegExp",
          "Array",
          "Float32Array",
          "Float64Array",
          "Int8Array",
          "Uint8Array",
          "Uint8ClampedArray",
          "Int16Array",
          "Int32Array",
          "Uint16Array",
          "Uint32Array",
          "BigInt64Array",
          "BigUint64Array",
          "Set",
          "Map",
          "WeakSet",
          "WeakMap",
          "ArrayBuffer",
          "SharedArrayBuffer",
          "Atomics",
          "DataView",
          "JSON",
          "Promise",
          "Generator",
          "GeneratorFunction",
          "AsyncFunction",
          "Reflect",
          "Proxy",
          "Intl",
          "WebAssembly",
        ],
        rt = [
          "Error",
          "EvalError",
          "InternalError",
          "RangeError",
          "ReferenceError",
          "SyntaxError",
          "TypeError",
          "URIError",
        ],
        ut = [
          "setInterval",
          "setTimeout",
          "clearInterval",
          "clearTimeout",
          "require",
          "exports",
          "eval",
          "isFinite",
          "isNaN",
          "parseFloat",
          "parseInt",
          "decodeURI",
          "decodeURIComponent",
          "encodeURI",
          "encodeURIComponent",
          "escape",
          "unescape",
        ],
        vt = [
          "arguments",
          "this",
          "super",
          "console",
          "window",
          "document",
          "localStorage",
          "sessionStorage",
          "module",
          "global",
        ],
        ot = [].concat(ut, it, rt);
      function yt(e) {
        let t = e.regex,
          a = He,
          d = {
            begin: /<[A-Za-z0-9\\._:-]+/,
            end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
            isTrulyOpeningTag: (Ve, nt) => {
              let bt = Ve[0].length + Ve.index,
                pt = Ve.input[bt];
              if (pt === "<" || pt === ",") return void nt.ignoreMatch();
              let at;
              pt === ">" &&
                (((tt, { after: St }) => {
                  let ht = "</" + tt[0].slice(1);
                  return tt.input.indexOf(ht, St) !== -1;
                })(Ve, { after: bt }) ||
                  nt.ignoreMatch());
              let ft = Ve.input.substring(bt);
              ((at = ft.match(/^\s*=/)) ||
                ((at = ft.match(/^\s+extends\s+/)) && at.index === 0)) &&
                nt.ignoreMatch();
            },
          },
          y = {
            $pattern: He,
            keyword: De,
            literal: Ye,
            built_in: ot,
            "variable.language": vt,
          },
          u = "[0-9](_?[0-9])*",
          _ = `\\.(${u})`,
          p = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*",
          L = {
            className: "number",
            variants: [
              { begin: `(\\b(${p})((${_})|\\.)?|(${_}))[eE][+-]?(${u})\\b` },
              { begin: `\\b(${p})\\b((${_})\\b|\\.)?|(${_})\\b` },
              { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
              { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
              { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
              { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
              { begin: "\\b0[0-7]+n?\\b" },
            ],
            relevance: 0,
          },
          I = {
            className: "subst",
            begin: "\\$\\{",
            end: "\\}",
            keywords: y,
            contains: [],
          },
          q = {
            begin: ".?html`",
            end: "",
            starts: {
              end: "`",
              returnEnd: !1,
              contains: [e.BACKSLASH_ESCAPE, I],
              subLanguage: "xml",
            },
          },
          ae = {
            begin: ".?css`",
            end: "",
            starts: {
              end: "`",
              returnEnd: !1,
              contains: [e.BACKSLASH_ESCAPE, I],
              subLanguage: "css",
            },
          },
          G = {
            begin: ".?gql`",
            end: "",
            starts: {
              end: "`",
              returnEnd: !1,
              contains: [e.BACKSLASH_ESCAPE, I],
              subLanguage: "graphql",
            },
          },
          ve = {
            className: "string",
            begin: "`",
            end: "`",
            contains: [e.BACKSLASH_ESCAPE, I],
          },
          xe = {
            className: "comment",
            variants: [
              e.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
                relevance: 0,
                contains: [
                  {
                    begin: "(?=@[A-Za-z]+)",
                    relevance: 0,
                    contains: [
                      { className: "doctag", begin: "@[A-Za-z]+" },
                      {
                        className: "type",
                        begin: "\\{",
                        end: "\\}",
                        excludeEnd: !0,
                        excludeBegin: !0,
                        relevance: 0,
                      },
                      {
                        className: "variable",
                        begin: a + "(?=\\s*(-)|$)",
                        endsParent: !0,
                        relevance: 0,
                      },
                      { begin: /(?=[^\n])\s/, relevance: 0 },
                    ],
                  },
                ],
              }),
              e.C_BLOCK_COMMENT_MODE,
              e.C_LINE_COMMENT_MODE,
            ],
          },
          Se = [
            e.APOS_STRING_MODE,
            e.QUOTE_STRING_MODE,
            q,
            ae,
            G,
            ve,
            { match: /\$\d+/ },
            L,
          ];
        I.contains = Se.concat({
          begin: /\{/,
          end: /\}/,
          keywords: y,
          contains: ["self"].concat(Se),
        });
        let je = [].concat(xe, I.contains),
          et = je.concat([
            {
              begin: /(\s*)\(/,
              end: /\)/,
              keywords: y,
              contains: ["self"].concat(je),
            },
          ]),
          Xe = {
            className: "params",
            begin: /(\s*)\(/,
            end: /\)/,
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: y,
            contains: et,
          },
          z = {
            variants: [
              {
                match: [
                  /class/,
                  /\s+/,
                  a,
                  /\s+/,
                  /extends/,
                  /\s+/,
                  t.concat(a, "(", t.concat(/\./, a), ")*"),
                ],
                scope: {
                  1: "keyword",
                  3: "title.class",
                  5: "keyword",
                  7: "title.class.inherited",
                },
              },
              {
                match: [/class/, /\s+/, a],
                scope: { 1: "keyword", 3: "title.class" },
              },
            ],
          },
          Y = {
            relevance: 0,
            match: t.either(
              /\bJSON/,
              /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
              /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
              /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
            ),
            className: "title.class",
            keywords: { _: [...it, ...rt] },
          },
          pe = {
            variants: [
              { match: [/function/, /\s+/, a, /(?=\s*\()/] },
              { match: [/function/, /\s*(?=\()/] },
            ],
            className: { 1: "keyword", 3: "title.function" },
            label: "func.def",
            contains: [Xe],
            illegal: /%/,
          },
          Ke = {
            match: t.concat(
              /\b/,
              ((Pe = [...ut, "super", "import"].map((Ve) => Ve + "\\s*\\(")),
              t.concat("(?!", Pe.join("|"), ")")),
              a,
              t.lookahead(/\s*\(/)
            ),
            className: "title.function",
            relevance: 0,
          };
        var Pe;
        let Fe = {
            begin: t.concat(
              /\./,
              t.lookahead(t.concat(a, /(?![0-9A-Za-z$_(])/))
            ),
            end: a,
            excludeBegin: !0,
            keywords: "prototype",
            className: "property",
            relevance: 0,
          },
          Me = {
            match: [/get|set/, /\s+/, a, /(?=\()/],
            className: { 1: "keyword", 3: "title.function" },
            contains: [{ begin: /\(\)/ }, Xe],
          },
          Te =
            "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" +
            e.UNDERSCORE_IDENT_RE +
            ")\\s*=>",
          Oe = {
            match: [
              /const|var|let/,
              /\s+/,
              a,
              /\s*/,
              /=\s*/,
              /(async\s*)?/,
              t.lookahead(Te),
            ],
            keywords: "async",
            className: { 1: "keyword", 3: "title.function" },
            contains: [Xe],
          };
        return {
          name: "JavaScript",
          aliases: ["js", "jsx", "mjs", "cjs"],
          keywords: y,
          exports: { PARAMS_CONTAINS: et, CLASS_REFERENCE: Y },
          illegal: /#(?![$_A-z])/,
          contains: [
            e.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }),
            {
              label: "use_strict",
              className: "meta",
              relevance: 10,
              begin: /^\s*['"]use (strict|asm)['"]/,
            },
            e.APOS_STRING_MODE,
            e.QUOTE_STRING_MODE,
            q,
            ae,
            G,
            ve,
            xe,
            { match: /\$\d+/ },
            L,
            Y,
            { scope: "attr", match: a + t.lookahead(":"), relevance: 0 },
            Oe,
            {
              begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
              keywords: "return throw case",
              relevance: 0,
              contains: [
                xe,
                e.REGEXP_MODE,
                {
                  className: "function",
                  begin: Te,
                  returnBegin: !0,
                  end: "\\s*=>",
                  contains: [
                    {
                      className: "params",
                      variants: [
                        { begin: e.UNDERSCORE_IDENT_RE, relevance: 0 },
                        { className: null, begin: /\(\s*\)/, skip: !0 },
                        {
                          begin: /(\s*)\(/,
                          end: /\)/,
                          excludeBegin: !0,
                          excludeEnd: !0,
                          keywords: y,
                          contains: et,
                        },
                      ],
                    },
                  ],
                },
                { begin: /,/, relevance: 0 },
                { match: /\s+/, relevance: 0 },
                {
                  variants: [
                    { begin: "<>", end: "</>" },
                    { match: /<[A-Za-z0-9\\._:-]+\s*\/>/ },
                    {
                      begin: d.begin,
                      "on:begin": d.isTrulyOpeningTag,
                      end: d.end,
                    },
                  ],
                  subLanguage: "xml",
                  contains: [
                    {
                      begin: d.begin,
                      end: d.end,
                      skip: !0,
                      contains: ["self"],
                    },
                  ],
                },
              ],
            },
            pe,
            { beginKeywords: "while if switch catch for" },
            {
              begin:
                "\\b(?!function)" +
                e.UNDERSCORE_IDENT_RE +
                "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
              returnBegin: !0,
              label: "func.def",
              contains: [
                Xe,
                e.inherit(e.TITLE_MODE, {
                  begin: a,
                  className: "title.function",
                }),
              ],
            },
            { match: /\.\.\./, relevance: 0 },
            Fe,
            { match: "\\$" + a, relevance: 0 },
            {
              match: [/\bconstructor(?=\s*\()/],
              className: { 1: "title.function" },
              contains: [Xe],
            },
            Ke,
            {
              relevance: 0,
              match: /\b[A-Z][A-Z_0-9]+\b/,
              className: "variable.constant",
            },
            z,
            Me,
            { match: /\$[(.]/ },
          ],
        };
      }
      let mt = (e) => x(/\b/, e, /\w$/.test(e) ? /\b/ : /\B/),
        kt = ["Protocol", "Type"].map(mt),
        wt = ["init", "self"].map(mt),
        At = ["Any", "Self"],
        _t = [
          "actor",
          "any",
          "associatedtype",
          "async",
          "await",
          /as\?/,
          /as!/,
          "as",
          "borrowing",
          "break",
          "case",
          "catch",
          "class",
          "consume",
          "consuming",
          "continue",
          "convenience",
          "copy",
          "default",
          "defer",
          "deinit",
          "didSet",
          "distributed",
          "do",
          "dynamic",
          "each",
          "else",
          "enum",
          "extension",
          "fallthrough",
          /fileprivate\(set\)/,
          "fileprivate",
          "final",
          "for",
          "func",
          "get",
          "guard",
          "if",
          "import",
          "indirect",
          "infix",
          /init\?/,
          /init!/,
          "inout",
          /internal\(set\)/,
          "internal",
          "in",
          "is",
          "isolated",
          "nonisolated",
          "lazy",
          "let",
          "macro",
          "mutating",
          "nonmutating",
          /open\(set\)/,
          "open",
          "operator",
          "optional",
          "override",
          "package",
          "postfix",
          "precedencegroup",
          "prefix",
          /private\(set\)/,
          "private",
          "protocol",
          /public\(set\)/,
          "public",
          "repeat",
          "required",
          "rethrows",
          "return",
          "set",
          "some",
          "static",
          "struct",
          "subscript",
          "super",
          "switch",
          "throws",
          "throw",
          /try\?/,
          /try!/,
          "try",
          "typealias",
          /unowned\(safe\)/,
          /unowned\(unsafe\)/,
          "unowned",
          "var",
          "weak",
          "where",
          "while",
          "willSet",
        ],
        Et = ["false", "nil", "true"],
        Ct = [
          "assignment",
          "associativity",
          "higherThan",
          "left",
          "lowerThan",
          "none",
          "right",
        ],
        Ot = [
          "#colorLiteral",
          "#column",
          "#dsohandle",
          "#else",
          "#elseif",
          "#endif",
          "#error",
          "#file",
          "#fileID",
          "#fileLiteral",
          "#filePath",
          "#function",
          "#if",
          "#imageLiteral",
          "#keyPath",
          "#line",
          "#selector",
          "#sourceLocation",
          "#warning",
        ],
        xt = [
          "abs",
          "all",
          "any",
          "assert",
          "assertionFailure",
          "debugPrint",
          "dump",
          "fatalError",
          "getVaList",
          "isKnownUniquelyReferenced",
          "max",
          "min",
          "numericCast",
          "pointwiseMax",
          "pointwiseMin",
          "precondition",
          "preconditionFailure",
          "print",
          "readLine",
          "repeatElement",
          "sequence",
          "stride",
          "swap",
          "swift_unboxFromSwiftValueWithType",
          "transcode",
          "type",
          "unsafeBitCast",
          "unsafeDowncast",
          "withExtendedLifetime",
          "withUnsafeMutablePointer",
          "withUnsafePointer",
          "withVaList",
          "withoutActuallyEscaping",
          "zip",
        ],
        Nt = E(
          /[/=\-+!*%<>&|^~?]/,
          /[\u00A1-\u00A7]/,
          /[\u00A9\u00AB]/,
          /[\u00AC\u00AE]/,
          /[\u00B0\u00B1]/,
          /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
          /[\u2016-\u2017]/,
          /[\u2020-\u2027]/,
          /[\u2030-\u203E]/,
          /[\u2041-\u2053]/,
          /[\u2055-\u205E]/,
          /[\u2190-\u23FF]/,
          /[\u2500-\u2775]/,
          /[\u2794-\u2BFF]/,
          /[\u2E00-\u2E7F]/,
          /[\u3001-\u3003]/,
          /[\u3008-\u3020]/,
          /[\u3030]/
        ),
        gt = E(
          Nt,
          /[\u0300-\u036F]/,
          /[\u1DC0-\u1DFF]/,
          /[\u20D0-\u20FF]/,
          /[\uFE00-\uFE0F]/,
          /[\uFE20-\uFE2F]/
        ),
        Bt = x(Nt, gt, "*"),
        jt = E(
          /[a-zA-Z_]/,
          /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
          /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
          /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
          /[\u1E00-\u1FFF]/,
          /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
          /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
          /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
          /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
          /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
          /[\uFE47-\uFEFE\uFF00-\uFFFD]/
        ),
        Lt = E(
          jt,
          /\d/,
          /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
        ),
        st = x(jt, Lt, "*"),
        Mt = x(/[A-Z]/, Lt, "*"),
        Jt = [
          "attached",
          "autoclosure",
          x(/convention\(/, E("swift", "block", "c"), /\)/),
          "discardableResult",
          "dynamicCallable",
          "dynamicMemberLookup",
          "escaping",
          "freestanding",
          "frozen",
          "GKInspectable",
          "IBAction",
          "IBDesignable",
          "IBInspectable",
          "IBOutlet",
          "IBSegueAction",
          "inlinable",
          "main",
          "nonobjc",
          "NSApplicationMain",
          "NSCopying",
          "NSManaged",
          x(/objc\(/, st, /\)/),
          "objc",
          "objcMembers",
          "propertyWrapper",
          "requires_stored_property_inits",
          "resultBuilder",
          "Sendable",
          "testable",
          "UIApplicationMain",
          "unchecked",
          "unknown",
          "usableFromInline",
          "warn_unqualified_access",
        ],
        en = [
          "iOS",
          "iOSApplicationExtension",
          "macOS",
          "macOSApplicationExtension",
          "macCatalyst",
          "macCatalystApplicationExtension",
          "watchOS",
          "watchOSApplicationExtension",
          "tvOS",
          "tvOSApplicationExtension",
          "swift",
        ];
      var Kt = Object.freeze({
        __proto__: null,
        grmr_bash: (e) => {
          let t = e.regex,
            a = {},
            d = {
              begin: /\$\{/,
              end: /\}/,
              contains: ["self", { begin: /:-/, contains: [a] }],
            };
          Object.assign(a, {
            className: "variable",
            variants: [
              { begin: t.concat(/\$[\w\d#@][\w\d_]*/, "(?![\\w\\d])(?![$])") },
              d,
            ],
          });
          let y = {
              className: "subst",
              begin: /\$\(/,
              end: /\)/,
              contains: [e.BACKSLASH_ESCAPE],
            },
            u = e.inherit(e.COMMENT(), {
              match: [/(^|\s)/, /#.*$/],
              scope: { 2: "comment" },
            }),
            _ = {
              begin: /<<-?\s*(?=\w+)/,
              starts: {
                contains: [
                  e.END_SAME_AS_BEGIN({
                    begin: /(\w+)/,
                    end: /(\w+)/,
                    className: "string",
                  }),
                ],
              },
            },
            p = {
              className: "string",
              begin: /"/,
              end: /"/,
              contains: [e.BACKSLASH_ESCAPE, a, y],
            };
          y.contains.push(p);
          let L = {
              begin: /\$?\(\(/,
              end: /\)\)/,
              contains: [
                { begin: /\d+#[0-9a-f]+/, className: "number" },
                e.NUMBER_MODE,
                a,
              ],
            },
            I = e.SHEBANG({
              binary: "(fish|bash|zsh|sh|csh|ksh|tcsh|dash|scsh)",
              relevance: 10,
            }),
            q = {
              className: "function",
              begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
              returnBegin: !0,
              contains: [e.inherit(e.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
              relevance: 0,
            };
          return {
            name: "Bash",
            aliases: ["sh", "zsh"],
            keywords: {
              $pattern: /\b[a-z][a-z0-9._-]+\b/,
              keyword: [
                "if",
                "then",
                "else",
                "elif",
                "fi",
                "time",
                "for",
                "while",
                "until",
                "in",
                "do",
                "done",
                "case",
                "esac",
                "coproc",
                "function",
                "select",
              ],
              literal: ["true", "false"],
              built_in: [
                "break",
                "cd",
                "continue",
                "eval",
                "exec",
                "exit",
                "export",
                "getopts",
                "hash",
                "pwd",
                "readonly",
                "return",
                "shift",
                "test",
                "times",
                "trap",
                "umask",
                "unset",
                "alias",
                "bind",
                "builtin",
                "caller",
                "command",
                "declare",
                "echo",
                "enable",
                "help",
                "let",
                "local",
                "logout",
                "mapfile",
                "printf",
                "read",
                "readarray",
                "source",
                "sudo",
                "type",
                "typeset",
                "ulimit",
                "unalias",
                "set",
                "shopt",
                "autoload",
                "bg",
                "bindkey",
                "bye",
                "cap",
                "chdir",
                "clone",
                "comparguments",
                "compcall",
                "compctl",
                "compdescribe",
                "compfiles",
                "compgroups",
                "compquote",
                "comptags",
                "comptry",
                "compvalues",
                "dirs",
                "disable",
                "disown",
                "echotc",
                "echoti",
                "emulate",
                "fc",
                "fg",
                "float",
                "functions",
                "getcap",
                "getln",
                "history",
                "integer",
                "jobs",
                "kill",
                "limit",
                "log",
                "noglob",
                "popd",
                "print",
                "pushd",
                "pushln",
                "rehash",
                "sched",
                "setcap",
                "setopt",
                "stat",
                "suspend",
                "ttyctl",
                "unfunction",
                "unhash",
                "unlimit",
                "unsetopt",
                "vared",
                "wait",
                "whence",
                "where",
                "which",
                "zcompile",
                "zformat",
                "zftp",
                "zle",
                "zmodload",
                "zparseopts",
                "zprof",
                "zpty",
                "zregexparse",
                "zsocket",
                "zstyle",
                "ztcp",
                "chcon",
                "chgrp",
                "chown",
                "chmod",
                "cp",
                "dd",
                "df",
                "dir",
                "dircolors",
                "ln",
                "ls",
                "mkdir",
                "mkfifo",
                "mknod",
                "mktemp",
                "mv",
                "realpath",
                "rm",
                "rmdir",
                "shred",
                "sync",
                "touch",
                "truncate",
                "vdir",
                "b2sum",
                "base32",
                "base64",
                "cat",
                "cksum",
                "comm",
                "csplit",
                "cut",
                "expand",
                "fmt",
                "fold",
                "head",
                "join",
                "md5sum",
                "nl",
                "numfmt",
                "od",
                "paste",
                "ptx",
                "pr",
                "sha1sum",
                "sha224sum",
                "sha256sum",
                "sha384sum",
                "sha512sum",
                "shuf",
                "sort",
                "split",
                "sum",
                "tac",
                "tail",
                "tr",
                "tsort",
                "unexpand",
                "uniq",
                "wc",
                "arch",
                "basename",
                "chroot",
                "date",
                "dirname",
                "du",
                "echo",
                "env",
                "expr",
                "factor",
                "groups",
                "hostid",
                "id",
                "link",
                "logname",
                "nice",
                "nohup",
                "nproc",
                "pathchk",
                "pinky",
                "printenv",
                "printf",
                "pwd",
                "readlink",
                "runcon",
                "seq",
                "sleep",
                "stat",
                "stdbuf",
                "stty",
                "tee",
                "test",
                "timeout",
                "tty",
                "uname",
                "unlink",
                "uptime",
                "users",
                "who",
                "whoami",
                "yes",
              ],
            },
            contains: [
              I,
              e.SHEBANG(),
              q,
              L,
              u,
              _,
              { match: /(\/[a-z._-]+)+/ },
              p,
              { match: /\\"/ },
              { className: "string", begin: /'/, end: /'/ },
              { match: /\\'/ },
              a,
            ],
          };
        },
        grmr_c: (e) => {
          let t = e.regex,
            a = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }),
            d = "decltype\\(auto\\)",
            y = "[a-zA-Z_]\\w*::",
            u =
              "(" +
              d +
              "|" +
              t.optional(y) +
              "[a-zA-Z_]\\w*" +
              t.optional("<[^<>]+>") +
              ")",
            _ = {
              className: "type",
              variants: [
                { begin: "\\b[a-z\\d_]*_t\\b" },
                { match: /\batomic_[a-z]{3,6}\b/ },
              ],
            },
            p = {
              className: "string",
              variants: [
                {
                  begin: '(u8?|U|L)?"',
                  end: '"',
                  illegal: "\\n",
                  contains: [e.BACKSLASH_ESCAPE],
                },
                {
                  begin:
                    "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
                  end: "'",
                  illegal: ".",
                },
                e.END_SAME_AS_BEGIN({
                  begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
                  end: /\)([^()\\ ]{0,16})"/,
                }),
              ],
            },
            L = {
              className: "number",
              variants: [
                { match: /\b(0b[01']+)/ },
                {
                  match:
                    /(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/,
                },
                {
                  match:
                    /(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/,
                },
                {
                  match:
                    /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/,
                },
              ],
              relevance: 0,
            },
            I = {
              className: "meta",
              begin: /#\s*[a-z]+\b/,
              end: /$/,
              keywords: {
                keyword:
                  "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include",
              },
              contains: [
                { begin: /\\\n/, relevance: 0 },
                e.inherit(p, { className: "string" }),
                { className: "string", begin: /<.*?>/ },
                a,
                e.C_BLOCK_COMMENT_MODE,
              ],
            },
            q = {
              className: "title",
              begin: t.optional(y) + e.IDENT_RE,
              relevance: 0,
            },
            ae = t.optional(y) + e.IDENT_RE + "\\s*\\(",
            G = {
              keyword: [
                "asm",
                "auto",
                "break",
                "case",
                "continue",
                "default",
                "do",
                "else",
                "enum",
                "extern",
                "for",
                "fortran",
                "goto",
                "if",
                "inline",
                "register",
                "restrict",
                "return",
                "sizeof",
                "typeof",
                "typeof_unqual",
                "struct",
                "switch",
                "typedef",
                "union",
                "volatile",
                "while",
                "_Alignas",
                "_Alignof",
                "_Atomic",
                "_Generic",
                "_Noreturn",
                "_Static_assert",
                "_Thread_local",
                "alignas",
                "alignof",
                "noreturn",
                "static_assert",
                "thread_local",
                "_Pragma",
              ],
              type: [
                "float",
                "double",
                "signed",
                "unsigned",
                "int",
                "short",
                "long",
                "char",
                "void",
                "_Bool",
                "_BitInt",
                "_Complex",
                "_Imaginary",
                "_Decimal32",
                "_Decimal64",
                "_Decimal96",
                "_Decimal128",
                "_Decimal64x",
                "_Decimal128x",
                "_Float16",
                "_Float32",
                "_Float64",
                "_Float128",
                "_Float32x",
                "_Float64x",
                "_Float128x",
                "const",
                "static",
                "constexpr",
                "complex",
                "bool",
                "imaginary",
              ],
              literal: "true false NULL",
              built_in:
                "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr",
            },
            ve = [I, _, a, e.C_BLOCK_COMMENT_MODE, L, p],
            xe = {
              variants: [
                { begin: /=/, end: /;/ },
                { begin: /\(/, end: /\)/ },
                { beginKeywords: "new throw return else", end: /;/ },
              ],
              keywords: G,
              contains: ve.concat([
                {
                  begin: /\(/,
                  end: /\)/,
                  keywords: G,
                  contains: ve.concat(["self"]),
                  relevance: 0,
                },
              ]),
              relevance: 0,
            },
            Se = {
              begin: "(" + u + "[\\*&\\s]+)+" + ae,
              returnBegin: !0,
              end: /[{;=]/,
              excludeEnd: !0,
              keywords: G,
              illegal: /[^\w\s\*&:<>.]/,
              contains: [
                { begin: d, keywords: G, relevance: 0 },
                {
                  begin: ae,
                  returnBegin: !0,
                  contains: [e.inherit(q, { className: "title.function" })],
                  relevance: 0,
                },
                { relevance: 0, match: /,/ },
                {
                  className: "params",
                  begin: /\(/,
                  end: /\)/,
                  keywords: G,
                  relevance: 0,
                  contains: [
                    a,
                    e.C_BLOCK_COMMENT_MODE,
                    p,
                    L,
                    _,
                    {
                      begin: /\(/,
                      end: /\)/,
                      keywords: G,
                      relevance: 0,
                      contains: ["self", a, e.C_BLOCK_COMMENT_MODE, p, L, _],
                    },
                  ],
                },
                _,
                a,
                e.C_BLOCK_COMMENT_MODE,
                I,
              ],
            };
          return {
            name: "C",
            aliases: ["h"],
            keywords: G,
            disableAutodetect: !0,
            illegal: "</",
            contains: [].concat(xe, Se, ve, [
              I,
              { begin: e.IDENT_RE + "::", keywords: G },
              {
                className: "class",
                beginKeywords: "enum class struct union",
                end: /[{;:<>=]/,
                contains: [
                  { beginKeywords: "final class struct" },
                  e.TITLE_MODE,
                ],
              },
            ]),
            exports: { preprocessor: I, strings: p, keywords: G },
          };
        },
        grmr_cpp: (e) => {
          let t = e.regex,
            a = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }),
            d = "decltype\\(auto\\)",
            y = "[a-zA-Z_]\\w*::",
            u =
              "(?!struct)(" +
              d +
              "|" +
              t.optional(y) +
              "[a-zA-Z_]\\w*" +
              t.optional("<[^<>]+>") +
              ")",
            _ = { className: "type", begin: "\\b[a-z\\d_]*_t\\b" },
            p = {
              className: "string",
              variants: [
                {
                  begin: '(u8?|U|L)?"',
                  end: '"',
                  illegal: "\\n",
                  contains: [e.BACKSLASH_ESCAPE],
                },
                {
                  begin:
                    "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
                  end: "'",
                  illegal: ".",
                },
                e.END_SAME_AS_BEGIN({
                  begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
                  end: /\)([^()\\ ]{0,16})"/,
                }),
              ],
            },
            L = {
              className: "number",
              variants: [
                {
                  begin:
                    "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)",
                },
                {
                  begin:
                    "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)",
                },
              ],
              relevance: 0,
            },
            I = {
              className: "meta",
              begin: /#\s*[a-z]+\b/,
              end: /$/,
              keywords: {
                keyword:
                  "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include",
              },
              contains: [
                { begin: /\\\n/, relevance: 0 },
                e.inherit(p, { className: "string" }),
                { className: "string", begin: /<.*?>/ },
                a,
                e.C_BLOCK_COMMENT_MODE,
              ],
            },
            q = {
              className: "title",
              begin: t.optional(y) + e.IDENT_RE,
              relevance: 0,
            },
            ae = t.optional(y) + e.IDENT_RE + "\\s*\\(",
            G = {
              type: [
                "bool",
                "char",
                "char16_t",
                "char32_t",
                "char8_t",
                "double",
                "float",
                "int",
                "long",
                "short",
                "void",
                "wchar_t",
                "unsigned",
                "signed",
                "const",
                "static",
              ],
              keyword: [
                "alignas",
                "alignof",
                "and",
                "and_eq",
                "asm",
                "atomic_cancel",
                "atomic_commit",
                "atomic_noexcept",
                "auto",
                "bitand",
                "bitor",
                "break",
                "case",
                "catch",
                "class",
                "co_await",
                "co_return",
                "co_yield",
                "compl",
                "concept",
                "const_cast|10",
                "consteval",
                "constexpr",
                "constinit",
                "continue",
                "decltype",
                "default",
                "delete",
                "do",
                "dynamic_cast|10",
                "else",
                "enum",
                "explicit",
                "export",
                "extern",
                "false",
                "final",
                "for",
                "friend",
                "goto",
                "if",
                "import",
                "inline",
                "module",
                "mutable",
                "namespace",
                "new",
                "noexcept",
                "not",
                "not_eq",
                "nullptr",
                "operator",
                "or",
                "or_eq",
                "override",
                "private",
                "protected",
                "public",
                "reflexpr",
                "register",
                "reinterpret_cast|10",
                "requires",
                "return",
                "sizeof",
                "static_assert",
                "static_cast|10",
                "struct",
                "switch",
                "synchronized",
                "template",
                "this",
                "thread_local",
                "throw",
                "transaction_safe",
                "transaction_safe_dynamic",
                "true",
                "try",
                "typedef",
                "typeid",
                "typename",
                "union",
                "using",
                "virtual",
                "volatile",
                "while",
                "xor",
                "xor_eq",
              ],
              literal: ["NULL", "false", "nullopt", "nullptr", "true"],
              built_in: ["_Pragma"],
              _type_hints: [
                "any",
                "auto_ptr",
                "barrier",
                "binary_semaphore",
                "bitset",
                "complex",
                "condition_variable",
                "condition_variable_any",
                "counting_semaphore",
                "deque",
                "false_type",
                "flat_map",
                "flat_set",
                "future",
                "imaginary",
                "initializer_list",
                "istringstream",
                "jthread",
                "latch",
                "lock_guard",
                "multimap",
                "multiset",
                "mutex",
                "optional",
                "ostringstream",
                "packaged_task",
                "pair",
                "promise",
                "priority_queue",
                "queue",
                "recursive_mutex",
                "recursive_timed_mutex",
                "scoped_lock",
                "set",
                "shared_future",
                "shared_lock",
                "shared_mutex",
                "shared_timed_mutex",
                "shared_ptr",
                "stack",
                "string_view",
                "stringstream",
                "timed_mutex",
                "thread",
                "true_type",
                "tuple",
                "unique_lock",
                "unique_ptr",
                "unordered_map",
                "unordered_multimap",
                "unordered_multiset",
                "unordered_set",
                "variant",
                "vector",
                "weak_ptr",
                "wstring",
                "wstring_view",
              ],
            },
            ve = {
              className: "function.dispatch",
              relevance: 0,
              keywords: {
                _hint: [
                  "abort",
                  "abs",
                  "acos",
                  "apply",
                  "as_const",
                  "asin",
                  "atan",
                  "atan2",
                  "calloc",
                  "ceil",
                  "cerr",
                  "cin",
                  "clog",
                  "cos",
                  "cosh",
                  "cout",
                  "declval",
                  "endl",
                  "exchange",
                  "exit",
                  "exp",
                  "fabs",
                  "floor",
                  "fmod",
                  "forward",
                  "fprintf",
                  "fputs",
                  "free",
                  "frexp",
                  "fscanf",
                  "future",
                  "invoke",
                  "isalnum",
                  "isalpha",
                  "iscntrl",
                  "isdigit",
                  "isgraph",
                  "islower",
                  "isprint",
                  "ispunct",
                  "isspace",
                  "isupper",
                  "isxdigit",
                  "labs",
                  "launder",
                  "ldexp",
                  "log",
                  "log10",
                  "make_pair",
                  "make_shared",
                  "make_shared_for_overwrite",
                  "make_tuple",
                  "make_unique",
                  "malloc",
                  "memchr",
                  "memcmp",
                  "memcpy",
                  "memset",
                  "modf",
                  "move",
                  "pow",
                  "printf",
                  "putchar",
                  "puts",
                  "realloc",
                  "scanf",
                  "sin",
                  "sinh",
                  "snprintf",
                  "sprintf",
                  "sqrt",
                  "sscanf",
                  "std",
                  "stderr",
                  "stdin",
                  "stdout",
                  "strcat",
                  "strchr",
                  "strcmp",
                  "strcpy",
                  "strcspn",
                  "strlen",
                  "strncat",
                  "strncmp",
                  "strncpy",
                  "strpbrk",
                  "strrchr",
                  "strspn",
                  "strstr",
                  "swap",
                  "tan",
                  "tanh",
                  "terminate",
                  "to_underlying",
                  "tolower",
                  "toupper",
                  "vfprintf",
                  "visit",
                  "vprintf",
                  "vsprintf",
                ],
              },
              begin: t.concat(
                /\b/,
                /(?!decltype)/,
                /(?!if)/,
                /(?!for)/,
                /(?!switch)/,
                /(?!while)/,
                e.IDENT_RE,
                t.lookahead(/(<[^<>]+>|)\s*\(/)
              ),
            },
            xe = [ve, I, _, a, e.C_BLOCK_COMMENT_MODE, L, p],
            Se = {
              variants: [
                { begin: /=/, end: /;/ },
                { begin: /\(/, end: /\)/ },
                { beginKeywords: "new throw return else", end: /;/ },
              ],
              keywords: G,
              contains: xe.concat([
                {
                  begin: /\(/,
                  end: /\)/,
                  keywords: G,
                  contains: xe.concat(["self"]),
                  relevance: 0,
                },
              ]),
              relevance: 0,
            },
            je = {
              className: "function",
              begin: "(" + u + "[\\*&\\s]+)+" + ae,
              returnBegin: !0,
              end: /[{;=]/,
              excludeEnd: !0,
              keywords: G,
              illegal: /[^\w\s\*&:<>.]/,
              contains: [
                { begin: d, keywords: G, relevance: 0 },
                { begin: ae, returnBegin: !0, contains: [q], relevance: 0 },
                { begin: /::/, relevance: 0 },
                { begin: /:/, endsWithParent: !0, contains: [p, L] },
                { relevance: 0, match: /,/ },
                {
                  className: "params",
                  begin: /\(/,
                  end: /\)/,
                  keywords: G,
                  relevance: 0,
                  contains: [
                    a,
                    e.C_BLOCK_COMMENT_MODE,
                    p,
                    L,
                    _,
                    {
                      begin: /\(/,
                      end: /\)/,
                      keywords: G,
                      relevance: 0,
                      contains: ["self", a, e.C_BLOCK_COMMENT_MODE, p, L, _],
                    },
                  ],
                },
                _,
                a,
                e.C_BLOCK_COMMENT_MODE,
                I,
              ],
            };
          return {
            name: "C++",
            aliases: ["cc", "c++", "h++", "hpp", "hh", "hxx", "cxx"],
            keywords: G,
            illegal: "</",
            classNameAliases: { "function.dispatch": "built_in" },
            contains: [].concat(Se, je, ve, xe, [
              I,
              {
                begin:
                  "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
                end: ">",
                keywords: G,
                contains: ["self", _],
              },
              { begin: e.IDENT_RE + "::", keywords: G },
              {
                match: [
                  /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
                  /\s+/,
                  /\w+/,
                ],
                className: { 1: "keyword", 3: "title.class" },
              },
            ]),
          };
        },
        grmr_csharp: (e) => {
          let t = {
              keyword: [
                "abstract",
                "as",
                "base",
                "break",
                "case",
                "catch",
                "class",
                "const",
                "continue",
                "do",
                "else",
                "event",
                "explicit",
                "extern",
                "finally",
                "fixed",
                "for",
                "foreach",
                "goto",
                "if",
                "implicit",
                "in",
                "interface",
                "internal",
                "is",
                "lock",
                "namespace",
                "new",
                "operator",
                "out",
                "override",
                "params",
                "private",
                "protected",
                "public",
                "readonly",
                "record",
                "ref",
                "return",
                "scoped",
                "sealed",
                "sizeof",
                "stackalloc",
                "static",
                "struct",
                "switch",
                "this",
                "throw",
                "try",
                "typeof",
                "unchecked",
                "unsafe",
                "using",
                "virtual",
                "void",
                "volatile",
                "while",
              ].concat([
                "add",
                "alias",
                "and",
                "ascending",
                "args",
                "async",
                "await",
                "by",
                "descending",
                "dynamic",
                "equals",
                "file",
                "from",
                "get",
                "global",
                "group",
                "init",
                "into",
                "join",
                "let",
                "nameof",
                "not",
                "notnull",
                "on",
                "or",
                "orderby",
                "partial",
                "record",
                "remove",
                "required",
                "scoped",
                "select",
                "set",
                "unmanaged",
                "value|0",
                "var",
                "when",
                "where",
                "with",
                "yield",
              ]),
              built_in: [
                "bool",
                "byte",
                "char",
                "decimal",
                "delegate",
                "double",
                "dynamic",
                "enum",
                "float",
                "int",
                "long",
                "nint",
                "nuint",
                "object",
                "sbyte",
                "short",
                "string",
                "ulong",
                "uint",
                "ushort",
              ],
              literal: ["default", "false", "null", "true"],
            },
            a = e.inherit(e.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }),
            d = {
              className: "number",
              variants: [
                { begin: "\\b(0b[01']+)" },
                {
                  begin:
                    "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)",
                },
                {
                  begin:
                    "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)",
                },
              ],
              relevance: 0,
            },
            y = {
              className: "string",
              begin: '@"',
              end: '"',
              contains: [{ begin: '""' }],
            },
            u = e.inherit(y, { illegal: /\n/ }),
            _ = { className: "subst", begin: /\{/, end: /\}/, keywords: t },
            p = e.inherit(_, { illegal: /\n/ }),
            L = {
              className: "string",
              begin: /\$"/,
              end: '"',
              illegal: /\n/,
              contains: [
                { begin: /\{\{/ },
                { begin: /\}\}/ },
                e.BACKSLASH_ESCAPE,
                p,
              ],
            },
            I = {
              className: "string",
              begin: /\$@"/,
              end: '"',
              contains: [
                { begin: /\{\{/ },
                { begin: /\}\}/ },
                { begin: '""' },
                _,
              ],
            },
            q = e.inherit(I, {
              illegal: /\n/,
              contains: [
                { begin: /\{\{/ },
                { begin: /\}\}/ },
                { begin: '""' },
                p,
              ],
            });
          (_.contains = [
            I,
            L,
            y,
            e.APOS_STRING_MODE,
            e.QUOTE_STRING_MODE,
            d,
            e.C_BLOCK_COMMENT_MODE,
          ]),
            (p.contains = [
              q,
              L,
              u,
              e.APOS_STRING_MODE,
              e.QUOTE_STRING_MODE,
              d,
              e.inherit(e.C_BLOCK_COMMENT_MODE, { illegal: /\n/ }),
            ]);
          let ae = {
              variants: [
                {
                  className: "string",
                  begin: /"""("*)(?!")(.|\n)*?"""\1/,
                  relevance: 1,
                },
                I,
                L,
                y,
                e.APOS_STRING_MODE,
                e.QUOTE_STRING_MODE,
              ],
            },
            G = {
              begin: "<",
              end: ">",
              contains: [{ beginKeywords: "in out" }, a],
            },
            ve =
              e.IDENT_RE +
              "(<" +
              e.IDENT_RE +
              "(\\s*,\\s*" +
              e.IDENT_RE +
              ")*>)?(\\[\\])?",
            xe = { begin: "@" + e.IDENT_RE, relevance: 0 };
          return {
            name: "C#",
            aliases: ["cs", "c#"],
            keywords: t,
            illegal: /::/,
            contains: [
              e.COMMENT("///", "$", {
                returnBegin: !0,
                contains: [
                  {
                    className: "doctag",
                    variants: [
                      { begin: "///", relevance: 0 },
                      { begin: "<!--|-->" },
                      { begin: "</?", end: ">" },
                    ],
                  },
                ],
              }),
              e.C_LINE_COMMENT_MODE,
              e.C_BLOCK_COMMENT_MODE,
              {
                className: "meta",
                begin: "#",
                end: "$",
                keywords: {
                  keyword:
                    "if else elif endif define undef warning error line region endregion pragma checksum",
                },
              },
              ae,
              d,
              {
                beginKeywords: "class interface",
                relevance: 0,
                end: /[{;=]/,
                illegal: /[^\s:,]/,
                contains: [
                  { beginKeywords: "where class" },
                  a,
                  G,
                  e.C_LINE_COMMENT_MODE,
                  e.C_BLOCK_COMMENT_MODE,
                ],
              },
              {
                beginKeywords: "namespace",
                relevance: 0,
                end: /[{;=]/,
                illegal: /[^\s:]/,
                contains: [a, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE],
              },
              {
                beginKeywords: "record",
                relevance: 0,
                end: /[{;=]/,
                illegal: /[^\s:]/,
                contains: [a, G, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE],
              },
              {
                className: "meta",
                begin: "^\\s*\\[(?=[\\w])",
                excludeBegin: !0,
                end: "\\]",
                excludeEnd: !0,
                contains: [{ className: "string", begin: /"/, end: /"/ }],
              },
              { beginKeywords: "new return throw await else", relevance: 0 },
              {
                className: "function",
                begin:
                  "(" + ve + "\\s+)+" + e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
                returnBegin: !0,
                end: /\s*[{;=]/,
                excludeEnd: !0,
                keywords: t,
                contains: [
                  {
                    beginKeywords:
                      "public private protected static internal protected abstract async extern override unsafe virtual new sealed partial",
                    relevance: 0,
                  },
                  {
                    begin: e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
                    returnBegin: !0,
                    contains: [e.TITLE_MODE, G],
                    relevance: 0,
                  },
                  { match: /\(\)/ },
                  {
                    className: "params",
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: t,
                    relevance: 0,
                    contains: [ae, d, e.C_BLOCK_COMMENT_MODE],
                  },
                  e.C_LINE_COMMENT_MODE,
                  e.C_BLOCK_COMMENT_MODE,
                ],
              },
              xe,
            ],
          };
        },
        grmr_css: (e) => {
          let t = e.regex,
            a = M(e),
            d = [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE];
          return {
            name: "CSS",
            case_insensitive: !0,
            illegal: /[=|'\$]/,
            keywords: { keyframePosition: "from to" },
            classNameAliases: { keyframePosition: "selector-tag" },
            contains: [
              a.BLOCK_COMMENT,
              { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ },
              a.CSS_NUMBER_MODE,
              {
                className: "selector-id",
                begin: /#[A-Za-z0-9_-]+/,
                relevance: 0,
              },
              {
                className: "selector-class",
                begin: "\\.[a-zA-Z-][a-zA-Z0-9_-]*",
                relevance: 0,
              },
              a.ATTRIBUTE_SELECTOR_MODE,
              {
                className: "selector-pseudo",
                variants: [
                  { begin: ":(" + ee.join("|") + ")" },
                  { begin: ":(:)?(" + te.join("|") + ")" },
                ],
              },
              a.CSS_VARIABLE,
              { className: "attribute", begin: "\\b(" + j.join("|") + ")\\b" },
              {
                begin: /:/,
                end: /[;}{]/,
                contains: [
                  a.BLOCK_COMMENT,
                  a.HEXCOLOR,
                  a.IMPORTANT,
                  a.CSS_NUMBER_MODE,
                  ...d,
                  {
                    begin: /(url|data-uri)\(/,
                    end: /\)/,
                    relevance: 0,
                    keywords: { built_in: "url data-uri" },
                    contains: [
                      ...d,
                      {
                        className: "string",
                        begin: /[^)]/,
                        endsWithParent: !0,
                        excludeEnd: !0,
                      },
                    ],
                  },
                  a.FUNCTION_DISPATCH,
                ],
              },
              {
                begin: t.lookahead(/@/),
                end: "[{;]",
                relevance: 0,
                illegal: /:/,
                contains: [
                  { className: "keyword", begin: /@-?\w[\w]*(-\w+)*/ },
                  {
                    begin: /\s/,
                    endsWithParent: !0,
                    excludeEnd: !0,
                    relevance: 0,
                    keywords: {
                      $pattern: /[a-z-]+/,
                      keyword: "and or not only",
                      attribute: H.join(" "),
                    },
                    contains: [
                      { begin: /[a-z-]+(?=:)/, className: "attribute" },
                      ...d,
                      a.CSS_NUMBER_MODE,
                    ],
                  },
                ],
              },
              {
                className: "selector-tag",
                begin: "\\b(" + D.join("|") + ")\\b",
              },
            ],
          };
        },
        grmr_diff: (e) => {
          let t = e.regex;
          return {
            name: "Diff",
            aliases: ["patch"],
            contains: [
              {
                className: "meta",
                relevance: 10,
                match: t.either(
                  /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
                  /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
                  /^--- +\d+,\d+ +----$/
                ),
              },
              {
                className: "comment",
                variants: [
                  {
                    begin: t.either(
                      /Index: /,
                      /^index/,
                      /={3,}/,
                      /^-{3}/,
                      /^\*{3} /,
                      /^\+{3}/,
                      /^diff --git/
                    ),
                    end: /$/,
                  },
                  { match: /^\*{15}$/ },
                ],
              },
              { className: "addition", begin: /^\+/, end: /$/ },
              { className: "deletion", begin: /^-/, end: /$/ },
              { className: "addition", begin: /^!/, end: /$/ },
            ],
          };
        },
        grmr_go: (e) => {
          let t = {
            keyword: [
              "break",
              "case",
              "chan",
              "const",
              "continue",
              "default",
              "defer",
              "else",
              "fallthrough",
              "for",
              "func",
              "go",
              "goto",
              "if",
              "import",
              "interface",
              "map",
              "package",
              "range",
              "return",
              "select",
              "struct",
              "switch",
              "type",
              "var",
            ],
            type: [
              "bool",
              "byte",
              "complex64",
              "complex128",
              "error",
              "float32",
              "float64",
              "int8",
              "int16",
              "int32",
              "int64",
              "string",
              "uint8",
              "uint16",
              "uint32",
              "uint64",
              "int",
              "uint",
              "uintptr",
              "rune",
            ],
            literal: ["true", "false", "iota", "nil"],
            built_in: [
              "append",
              "cap",
              "close",
              "complex",
              "copy",
              "imag",
              "len",
              "make",
              "new",
              "panic",
              "print",
              "println",
              "real",
              "recover",
              "delete",
            ],
          };
          return {
            name: "Go",
            aliases: ["golang"],
            keywords: t,
            illegal: "</",
            contains: [
              e.C_LINE_COMMENT_MODE,
              e.C_BLOCK_COMMENT_MODE,
              {
                className: "string",
                variants: [
                  e.QUOTE_STRING_MODE,
                  e.APOS_STRING_MODE,
                  { begin: "`", end: "`" },
                ],
              },
              {
                className: "number",
                variants: [
                  {
                    match:
                      /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/,
                    relevance: 0,
                  },
                  {
                    match:
                      /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
                    relevance: 0,
                  },
                  { match: /-?\b0[oO](_?[0-7])*i?/, relevance: 0 },
                  {
                    match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/,
                    relevance: 0,
                  },
                  {
                    match:
                      /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/,
                    relevance: 0,
                  },
                ],
              },
              { begin: /:=/ },
              {
                className: "function",
                beginKeywords: "func",
                end: "\\s*(\\{|$)",
                excludeEnd: !0,
                contains: [
                  e.TITLE_MODE,
                  {
                    className: "params",
                    begin: /\(/,
                    end: /\)/,
                    endsParent: !0,
                    keywords: t,
                    illegal: /["']/,
                  },
                ],
              },
            ],
          };
        },
        grmr_graphql: (e) => {
          let t = e.regex;
          return {
            name: "GraphQL",
            aliases: ["gql"],
            case_insensitive: !0,
            disableAutodetect: !1,
            keywords: {
              keyword: [
                "query",
                "mutation",
                "subscription",
                "type",
                "input",
                "schema",
                "directive",
                "interface",
                "union",
                "scalar",
                "fragment",
                "enum",
                "on",
              ],
              literal: ["true", "false", "null"],
            },
            contains: [
              e.HASH_COMMENT_MODE,
              e.QUOTE_STRING_MODE,
              e.NUMBER_MODE,
              { scope: "punctuation", match: /[.]{3}/, relevance: 0 },
              {
                scope: "punctuation",
                begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
                relevance: 0,
              },
              {
                scope: "variable",
                begin: /\$/,
                end: /\W/,
                excludeEnd: !0,
                relevance: 0,
              },
              { scope: "meta", match: /@\w+/, excludeEnd: !0 },
              {
                scope: "symbol",
                begin: t.concat(/[_A-Za-z][_0-9A-Za-z]*/, t.lookahead(/\s*:/)),
                relevance: 0,
              },
            ],
            illegal: [/[;<']/, /BEGIN/],
          };
        },
        grmr_ini: (e) => {
          let t = e.regex,
            a = {
              className: "number",
              relevance: 0,
              variants: [
                { begin: /([+-]+)?[\d]+_[\d_]+/ },
                { begin: e.NUMBER_RE },
              ],
            },
            d = e.COMMENT();
          d.variants = [
            { begin: /;/, end: /$/ },
            { begin: /#/, end: /$/ },
          ];
          let y = {
              className: "variable",
              variants: [
                { begin: /\$[\w\d"][\w\d_]*/ },
                { begin: /\$\{(.*?)\}/ },
              ],
            },
            u = { className: "literal", begin: /\bon|off|true|false|yes|no\b/ },
            _ = {
              className: "string",
              contains: [e.BACKSLASH_ESCAPE],
              variants: [
                { begin: "'''", end: "'''", relevance: 10 },
                { begin: '"""', end: '"""', relevance: 10 },
                { begin: '"', end: '"' },
                { begin: "'", end: "'" },
              ],
            },
            p = {
              begin: /\[/,
              end: /\]/,
              contains: [d, u, y, _, a, "self"],
              relevance: 0,
            },
            L = t.either(/[A-Za-z0-9_-]+/, /"(\\"|[^"])*"/, /'[^']*'/);
          return {
            name: "TOML, also INI",
            aliases: ["toml"],
            case_insensitive: !0,
            illegal: /\S/,
            contains: [
              d,
              { className: "section", begin: /\[+/, end: /\]+/ },
              {
                begin: t.concat(
                  L,
                  "(\\s*\\.\\s*",
                  L,
                  ")*",
                  t.lookahead(/\s*=\s*[^#\s]/)
                ),
                className: "attr",
                starts: { end: /$/, contains: [d, p, u, y, _, a] },
              },
            ],
          };
        },
        grmr_java: (e) => {
          let t = e.regex,
            a = "[\xC0-\u02B8a-zA-Z_$][\xC0-\u02B8a-zA-Z_$0-9]*",
            d =
              a +
              Le("(?:<" + a + "~~~(?:\\s*,\\s*" + a + "~~~)*>)?", /~~~/g, 2),
            y = {
              keyword: [
                "synchronized",
                "abstract",
                "private",
                "var",
                "static",
                "if",
                "const ",
                "for",
                "while",
                "strictfp",
                "finally",
                "protected",
                "import",
                "native",
                "final",
                "void",
                "enum",
                "else",
                "break",
                "transient",
                "catch",
                "instanceof",
                "volatile",
                "case",
                "assert",
                "package",
                "default",
                "public",
                "try",
                "switch",
                "continue",
                "throws",
                "protected",
                "public",
                "private",
                "module",
                "requires",
                "exports",
                "do",
                "sealed",
                "yield",
                "permits",
                "goto",
                "when",
              ],
              literal: ["false", "true", "null"],
              type: [
                "char",
                "boolean",
                "long",
                "float",
                "int",
                "byte",
                "short",
                "double",
              ],
              built_in: ["super", "this"],
            },
            u = {
              className: "meta",
              begin: "@" + a,
              contains: [{ begin: /\(/, end: /\)/, contains: ["self"] }],
            },
            _ = {
              className: "params",
              begin: /\(/,
              end: /\)/,
              keywords: y,
              relevance: 0,
              contains: [e.C_BLOCK_COMMENT_MODE],
              endsParent: !0,
            };
          return {
            name: "Java",
            aliases: ["jsp"],
            keywords: y,
            illegal: /<\/|#/,
            contains: [
              e.COMMENT("/\\*\\*", "\\*/", {
                relevance: 0,
                contains: [
                  { begin: /\w+@/, relevance: 0 },
                  { className: "doctag", begin: "@[A-Za-z]+" },
                ],
              }),
              {
                begin: /import java\.[a-z]+\./,
                keywords: "import",
                relevance: 2,
              },
              e.C_LINE_COMMENT_MODE,
              e.C_BLOCK_COMMENT_MODE,
              {
                begin: /"""/,
                end: /"""/,
                className: "string",
                contains: [e.BACKSLASH_ESCAPE],
              },
              e.APOS_STRING_MODE,
              e.QUOTE_STRING_MODE,
              {
                match: [
                  /\b(?:class|interface|enum|extends|implements|new)/,
                  /\s+/,
                  a,
                ],
                className: { 1: "keyword", 3: "title.class" },
              },
              { match: /non-sealed/, scope: "keyword" },
              {
                begin: [t.concat(/(?!else)/, a), /\s+/, a, /\s+/, /=(?!=)/],
                className: { 1: "type", 3: "variable", 5: "operator" },
              },
              {
                begin: [/record/, /\s+/, a],
                className: { 1: "keyword", 3: "title.class" },
                contains: [_, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE],
              },
              { beginKeywords: "new throw return else", relevance: 0 },
              {
                begin: [
                  "(?:" + d + "\\s+)",
                  e.UNDERSCORE_IDENT_RE,
                  /\s*(?=\()/,
                ],
                className: { 2: "title.function" },
                keywords: y,
                contains: [
                  {
                    className: "params",
                    begin: /\(/,
                    end: /\)/,
                    keywords: y,
                    relevance: 0,
                    contains: [
                      u,
                      e.APOS_STRING_MODE,
                      e.QUOTE_STRING_MODE,
                      Ze,
                      e.C_BLOCK_COMMENT_MODE,
                    ],
                  },
                  e.C_LINE_COMMENT_MODE,
                  e.C_BLOCK_COMMENT_MODE,
                ],
              },
              Ze,
              u,
            ],
          };
        },
        grmr_javascript: yt,
        grmr_json: (e) => {
          let t = ["true", "false", "null"],
            a = { scope: "literal", beginKeywords: t.join(" ") };
          return {
            name: "JSON",
            aliases: ["jsonc"],
            keywords: { literal: t },
            contains: [
              {
                className: "attr",
                begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
                relevance: 1.01,
              },
              { match: /[{}[\],:]/, className: "punctuation", relevance: 0 },
              e.QUOTE_STRING_MODE,
              a,
              e.C_NUMBER_MODE,
              e.C_LINE_COMMENT_MODE,
              e.C_BLOCK_COMMENT_MODE,
            ],
            illegal: "\\S",
          };
        },
        grmr_kotlin: (e) => {
          let t = {
              keyword:
                "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
              built_in:
                "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
              literal: "true false null",
            },
            a = { className: "symbol", begin: e.UNDERSCORE_IDENT_RE + "@" },
            d = {
              className: "subst",
              begin: /\$\{/,
              end: /\}/,
              contains: [e.C_NUMBER_MODE],
            },
            y = { className: "variable", begin: "\\$" + e.UNDERSCORE_IDENT_RE },
            u = {
              className: "string",
              variants: [
                { begin: '"""', end: '"""(?=[^"])', contains: [y, d] },
                {
                  begin: "'",
                  end: "'",
                  illegal: /\n/,
                  contains: [e.BACKSLASH_ESCAPE],
                },
                {
                  begin: '"',
                  end: '"',
                  illegal: /\n/,
                  contains: [e.BACKSLASH_ESCAPE, y, d],
                },
              ],
            };
          d.contains.push(u);
          let _ = {
              className: "meta",
              begin:
                "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" +
                e.UNDERSCORE_IDENT_RE +
                ")?",
            },
            p = {
              className: "meta",
              begin: "@" + e.UNDERSCORE_IDENT_RE,
              contains: [
                {
                  begin: /\(/,
                  end: /\)/,
                  contains: [e.inherit(u, { className: "string" }), "self"],
                },
              ],
            },
            L = Ze,
            I = e.COMMENT("/\\*", "\\*/", {
              contains: [e.C_BLOCK_COMMENT_MODE],
            }),
            q = {
              variants: [
                { className: "type", begin: e.UNDERSCORE_IDENT_RE },
                { begin: /\(/, end: /\)/, contains: [] },
              ],
            },
            ae = q;
          return (
            (ae.variants[1].contains = [q]),
            (q.variants[1].contains = [ae]),
            {
              name: "Kotlin",
              aliases: ["kt", "kts"],
              keywords: t,
              contains: [
                e.COMMENT("/\\*\\*", "\\*/", {
                  relevance: 0,
                  contains: [{ className: "doctag", begin: "@[A-Za-z]+" }],
                }),
                e.C_LINE_COMMENT_MODE,
                I,
                {
                  className: "keyword",
                  begin: /\b(break|continue|return|this)\b/,
                  starts: {
                    contains: [{ className: "symbol", begin: /@\w+/ }],
                  },
                },
                a,
                _,
                p,
                {
                  className: "function",
                  beginKeywords: "fun",
                  end: "[(]|$",
                  returnBegin: !0,
                  excludeEnd: !0,
                  keywords: t,
                  relevance: 5,
                  contains: [
                    {
                      begin: e.UNDERSCORE_IDENT_RE + "\\s*\\(",
                      returnBegin: !0,
                      relevance: 0,
                      contains: [e.UNDERSCORE_TITLE_MODE],
                    },
                    {
                      className: "type",
                      begin: /</,
                      end: />/,
                      keywords: "reified",
                      relevance: 0,
                    },
                    {
                      className: "params",
                      begin: /\(/,
                      end: /\)/,
                      endsParent: !0,
                      keywords: t,
                      relevance: 0,
                      contains: [
                        {
                          begin: /:/,
                          end: /[=,\/]/,
                          endsWithParent: !0,
                          contains: [q, e.C_LINE_COMMENT_MODE, I],
                          relevance: 0,
                        },
                        e.C_LINE_COMMENT_MODE,
                        I,
                        _,
                        p,
                        u,
                        e.C_NUMBER_MODE,
                      ],
                    },
                    I,
                  ],
                },
                {
                  begin: [
                    /class|interface|trait/,
                    /\s+/,
                    e.UNDERSCORE_IDENT_RE,
                  ],
                  beginScope: { 3: "title.class" },
                  keywords: "class interface trait",
                  end: /[:\{(]|$/,
                  excludeEnd: !0,
                  illegal: "extends implements",
                  contains: [
                    {
                      beginKeywords:
                        "public protected internal private constructor",
                    },
                    e.UNDERSCORE_TITLE_MODE,
                    {
                      className: "type",
                      begin: /</,
                      end: />/,
                      excludeBegin: !0,
                      excludeEnd: !0,
                      relevance: 0,
                    },
                    {
                      className: "type",
                      begin: /[,:]\s*/,
                      end: /[<\(,){\s]|$/,
                      excludeBegin: !0,
                      returnEnd: !0,
                    },
                    _,
                    p,
                  ],
                },
                u,
                {
                  className: "meta",
                  begin: "^#!/usr/bin/env",
                  end: "$",
                  illegal: `
`,
                },
                L,
              ],
            }
          );
        },
        grmr_less: (e) => {
          let t = M(e),
            a = ne,
            d = "[\\w-]+",
            y = "(" + d + "|@\\{" + d + "\\})",
            u = [],
            _ = [],
            p = (Xe) => ({
              className: "string",
              begin: "~?" + Xe + ".*?" + Xe,
            }),
            L = (Xe, z, Y) => ({ className: Xe, begin: z, relevance: Y }),
            I = {
              $pattern: /[a-z-]+/,
              keyword: "and or not only",
              attribute: H.join(" "),
            },
            q = {
              begin: "\\(",
              end: "\\)",
              contains: _,
              keywords: I,
              relevance: 0,
            };
          _.push(
            e.C_LINE_COMMENT_MODE,
            e.C_BLOCK_COMMENT_MODE,
            p("'"),
            p('"'),
            t.CSS_NUMBER_MODE,
            {
              begin: "(url|data-uri)\\(",
              starts: { className: "string", end: "[\\)\\n]", excludeEnd: !0 },
            },
            t.HEXCOLOR,
            q,
            L("variable", "@@?" + d, 10),
            L("variable", "@\\{" + d + "\\}"),
            L("built_in", "~?`[^`]*?`"),
            {
              className: "attribute",
              begin: d + "\\s*:",
              end: ":",
              returnBegin: !0,
              excludeEnd: !0,
            },
            t.IMPORTANT,
            { beginKeywords: "and not" },
            t.FUNCTION_DISPATCH
          );
          let ae = _.concat({ begin: /\{/, end: /\}/, contains: u }),
            G = {
              beginKeywords: "when",
              endsWithParent: !0,
              contains: [{ beginKeywords: "and not" }].concat(_),
            },
            ve = {
              begin: y + "\\s*:",
              returnBegin: !0,
              end: /[;}]/,
              relevance: 0,
              contains: [
                { begin: /-(webkit|moz|ms|o)-/ },
                t.CSS_VARIABLE,
                {
                  className: "attribute",
                  begin: "\\b(" + j.join("|") + ")\\b",
                  end: /(?=:)/,
                  starts: {
                    endsWithParent: !0,
                    illegal: "[<=$]",
                    relevance: 0,
                    contains: _,
                  },
                },
              ],
            },
            xe = {
              className: "keyword",
              begin:
                "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
              starts: {
                end: "[;{}]",
                keywords: I,
                returnEnd: !0,
                contains: _,
                relevance: 0,
              },
            },
            Se = {
              className: "variable",
              variants: [
                { begin: "@" + d + "\\s*:", relevance: 15 },
                { begin: "@" + d },
              ],
              starts: { end: "[;}]", returnEnd: !0, contains: ae },
            },
            je = {
              variants: [
                { begin: "[\\.#:&\\[>]", end: "[;{}]" },
                { begin: y, end: /\{/ },
              ],
              returnBegin: !0,
              returnEnd: !0,
              illegal: `[<='$"]`,
              relevance: 0,
              contains: [
                e.C_LINE_COMMENT_MODE,
                e.C_BLOCK_COMMENT_MODE,
                G,
                L("keyword", "all\\b"),
                L("variable", "@\\{" + d + "\\}"),
                {
                  begin: "\\b(" + D.join("|") + ")\\b",
                  className: "selector-tag",
                },
                t.CSS_NUMBER_MODE,
                L("selector-tag", y, 0),
                L("selector-id", "#" + y),
                L("selector-class", "\\." + y, 0),
                L("selector-tag", "&", 0),
                t.ATTRIBUTE_SELECTOR_MODE,
                {
                  className: "selector-pseudo",
                  begin: ":(" + ee.join("|") + ")",
                },
                {
                  className: "selector-pseudo",
                  begin: ":(:)?(" + te.join("|") + ")",
                },
                { begin: /\(/, end: /\)/, relevance: 0, contains: ae },
                { begin: "!important" },
                t.FUNCTION_DISPATCH,
              ],
            },
            et = {
              begin: d + `:(:)?(${a.join("|")})`,
              returnBegin: !0,
              contains: [je],
            };
          return (
            u.push(
              e.C_LINE_COMMENT_MODE,
              e.C_BLOCK_COMMENT_MODE,
              xe,
              Se,
              et,
              ve,
              je,
              G,
              t.FUNCTION_DISPATCH
            ),
            {
              name: "Less",
              case_insensitive: !0,
              illegal: `[=>'/<($"]`,
              contains: u,
            }
          );
        },
        grmr_lua: (e) => {
          let t = "\\[=*\\[",
            a = "\\]=*\\]",
            d = { begin: t, end: a, contains: ["self"] },
            y = [
              e.COMMENT("--(?!" + t + ")", "$"),
              e.COMMENT("--" + t, a, { contains: [d], relevance: 10 }),
            ];
          return {
            name: "Lua",
            aliases: ["pluto"],
            keywords: {
              $pattern: e.UNDERSCORE_IDENT_RE,
              literal: "true false nil",
              keyword:
                "and break do else elseif end for goto if in local not or repeat return then until while",
              built_in:
                "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove",
            },
            contains: y.concat([
              {
                className: "function",
                beginKeywords: "function",
                end: "\\)",
                contains: [
                  e.inherit(e.TITLE_MODE, {
                    begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*",
                  }),
                  {
                    className: "params",
                    begin: "\\(",
                    endsWithParent: !0,
                    contains: y,
                  },
                ].concat(y),
              },
              e.C_NUMBER_MODE,
              e.APOS_STRING_MODE,
              e.QUOTE_STRING_MODE,
              {
                className: "string",
                begin: t,
                end: a,
                contains: [d],
                relevance: 5,
              },
            ]),
          };
        },
        grmr_makefile: (e) => {
          let t = {
              className: "variable",
              variants: [
                {
                  begin: "\\$\\(" + e.UNDERSCORE_IDENT_RE + "\\)",
                  contains: [e.BACKSLASH_ESCAPE],
                },
                { begin: /\$[@%<?\^\+\*]/ },
              ],
            },
            a = {
              className: "string",
              begin: /"/,
              end: /"/,
              contains: [e.BACKSLASH_ESCAPE, t],
            },
            d = {
              className: "variable",
              begin: /\$\([\w-]+\s/,
              end: /\)/,
              keywords: {
                built_in:
                  "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value",
              },
              contains: [t, a],
            },
            y = { begin: "^" + e.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" },
            u = {
              className: "section",
              begin: /^[^\s]+:/,
              end: /$/,
              contains: [t],
            };
          return {
            name: "Makefile",
            aliases: ["mk", "mak", "make"],
            keywords: {
              $pattern: /[\w-]+/,
              keyword:
                "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath",
            },
            contains: [
              e.HASH_COMMENT_MODE,
              t,
              a,
              d,
              y,
              {
                className: "meta",
                begin: /^\.PHONY:/,
                end: /$/,
                keywords: { $pattern: /[\.\w]+/, keyword: ".PHONY" },
              },
              u,
            ],
          };
        },
        grmr_markdown: (e) => {
          let t = {
              begin: /<\/?[A-Za-z_]/,
              end: ">",
              subLanguage: "xml",
              relevance: 0,
            },
            a = {
              variants: [
                { begin: /\[.+?\]\[.*?\]/, relevance: 0 },
                {
                  begin:
                    /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
                  relevance: 2,
                },
                {
                  begin: e.regex.concat(
                    /\[.+?\]\(/,
                    /[A-Za-z][A-Za-z0-9+.-]*/,
                    /:\/\/.*?\)/
                  ),
                  relevance: 2,
                },
                { begin: /\[.+?\]\([./?&#].*?\)/, relevance: 1 },
                { begin: /\[.*?\]\(.*?\)/, relevance: 0 },
              ],
              returnBegin: !0,
              contains: [
                { match: /\[(?=\])/ },
                {
                  className: "string",
                  relevance: 0,
                  begin: "\\[",
                  end: "\\]",
                  excludeBegin: !0,
                  returnEnd: !0,
                },
                {
                  className: "link",
                  relevance: 0,
                  begin: "\\]\\(",
                  end: "\\)",
                  excludeBegin: !0,
                  excludeEnd: !0,
                },
                {
                  className: "symbol",
                  relevance: 0,
                  begin: "\\]\\[",
                  end: "\\]",
                  excludeBegin: !0,
                  excludeEnd: !0,
                },
              ],
            },
            d = {
              className: "strong",
              contains: [],
              variants: [
                { begin: /_{2}(?!\s)/, end: /_{2}/ },
                { begin: /\*{2}(?!\s)/, end: /\*{2}/ },
              ],
            },
            y = {
              className: "emphasis",
              contains: [],
              variants: [
                { begin: /\*(?![*\s])/, end: /\*/ },
                { begin: /_(?![_\s])/, end: /_/, relevance: 0 },
              ],
            },
            u = e.inherit(d, { contains: [] }),
            _ = e.inherit(y, { contains: [] });
          d.contains.push(_), y.contains.push(u);
          let p = [t, a];
          return (
            [d, y, u, _].forEach((L) => {
              L.contains = L.contains.concat(p);
            }),
            (p = p.concat(d, y)),
            {
              name: "Markdown",
              aliases: ["md", "mkdown", "mkd"],
              contains: [
                {
                  className: "section",
                  variants: [
                    { begin: "^#{1,6}", end: "$", contains: p },
                    {
                      begin: "(?=^.+?\\n[=-]{2,}$)",
                      contains: [
                        { begin: "^[=-]*$" },
                        { begin: "^", end: "\\n", contains: p },
                      ],
                    },
                  ],
                },
                t,
                {
                  className: "bullet",
                  begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
                  end: "\\s+",
                  excludeEnd: !0,
                },
                d,
                y,
                { className: "quote", begin: "^>\\s+", contains: p, end: "$" },
                {
                  className: "code",
                  variants: [
                    { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
                    { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
                    { begin: "```", end: "```+[ ]*$" },
                    { begin: "~~~", end: "~~~+[ ]*$" },
                    { begin: "`.+?`" },
                    {
                      begin: "(?=^( {4}|\\t))",
                      contains: [{ begin: "^( {4}|\\t)", end: "(\\n)$" }],
                      relevance: 0,
                    },
                  ],
                },
                { begin: "^[-\\*]{3,}", end: "$" },
                a,
                {
                  begin: /^\[[^\n]+\]:/,
                  returnBegin: !0,
                  contains: [
                    {
                      className: "symbol",
                      begin: /\[/,
                      end: /\]/,
                      excludeBegin: !0,
                      excludeEnd: !0,
                    },
                    {
                      className: "link",
                      begin: /:\s*/,
                      end: /$/,
                      excludeBegin: !0,
                    },
                  ],
                },
                {
                  scope: "literal",
                  match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/,
                },
              ],
            }
          );
        },
        grmr_objectivec: (e) => {
          let t = /[a-zA-Z@][a-zA-Z0-9_]*/,
            a = {
              $pattern: t,
              keyword: ["@interface", "@class", "@protocol", "@implementation"],
            };
          return {
            name: "Objective-C",
            aliases: ["mm", "objc", "obj-c", "obj-c++", "objective-c++"],
            keywords: {
              "variable.language": ["this", "super"],
              $pattern: t,
              keyword: [
                "while",
                "export",
                "sizeof",
                "typedef",
                "const",
                "struct",
                "for",
                "union",
                "volatile",
                "static",
                "mutable",
                "if",
                "do",
                "return",
                "goto",
                "enum",
                "else",
                "break",
                "extern",
                "asm",
                "case",
                "default",
                "register",
                "explicit",
                "typename",
                "switch",
                "continue",
                "inline",
                "readonly",
                "assign",
                "readwrite",
                "self",
                "@synchronized",
                "id",
                "typeof",
                "nonatomic",
                "IBOutlet",
                "IBAction",
                "strong",
                "weak",
                "copy",
                "in",
                "out",
                "inout",
                "bycopy",
                "byref",
                "oneway",
                "__strong",
                "__weak",
                "__block",
                "__autoreleasing",
                "@private",
                "@protected",
                "@public",
                "@try",
                "@property",
                "@end",
                "@throw",
                "@catch",
                "@finally",
                "@autoreleasepool",
                "@synthesize",
                "@dynamic",
                "@selector",
                "@optional",
                "@required",
                "@encode",
                "@package",
                "@import",
                "@defs",
                "@compatibility_alias",
                "__bridge",
                "__bridge_transfer",
                "__bridge_retained",
                "__bridge_retain",
                "__covariant",
                "__contravariant",
                "__kindof",
                "_Nonnull",
                "_Nullable",
                "_Null_unspecified",
                "__FUNCTION__",
                "__PRETTY_FUNCTION__",
                "__attribute__",
                "getter",
                "setter",
                "retain",
                "unsafe_unretained",
                "nonnull",
                "nullable",
                "null_unspecified",
                "null_resettable",
                "class",
                "instancetype",
                "NS_DESIGNATED_INITIALIZER",
                "NS_UNAVAILABLE",
                "NS_REQUIRES_SUPER",
                "NS_RETURNS_INNER_POINTER",
                "NS_INLINE",
                "NS_AVAILABLE",
                "NS_DEPRECATED",
                "NS_ENUM",
                "NS_OPTIONS",
                "NS_SWIFT_UNAVAILABLE",
                "NS_ASSUME_NONNULL_BEGIN",
                "NS_ASSUME_NONNULL_END",
                "NS_REFINED_FOR_SWIFT",
                "NS_SWIFT_NAME",
                "NS_SWIFT_NOTHROW",
                "NS_DURING",
                "NS_HANDLER",
                "NS_ENDHANDLER",
                "NS_VALUERETURN",
                "NS_VOIDRETURN",
              ],
              literal: [
                "false",
                "true",
                "FALSE",
                "TRUE",
                "nil",
                "YES",
                "NO",
                "NULL",
              ],
              built_in: [
                "dispatch_once_t",
                "dispatch_queue_t",
                "dispatch_sync",
                "dispatch_async",
                "dispatch_once",
              ],
              type: [
                "int",
                "float",
                "char",
                "unsigned",
                "signed",
                "short",
                "long",
                "double",
                "wchar_t",
                "unichar",
                "void",
                "bool",
                "BOOL",
                "id|0",
                "_Bool",
              ],
            },
            illegal: "</",
            contains: [
              {
                className: "built_in",
                begin:
                  "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+",
              },
              e.C_LINE_COMMENT_MODE,
              e.C_BLOCK_COMMENT_MODE,
              e.C_NUMBER_MODE,
              e.QUOTE_STRING_MODE,
              e.APOS_STRING_MODE,
              {
                className: "string",
                variants: [
                  {
                    begin: '@"',
                    end: '"',
                    illegal: "\\n",
                    contains: [e.BACKSLASH_ESCAPE],
                  },
                ],
              },
              {
                className: "meta",
                begin: /#\s*[a-z]+\b/,
                end: /$/,
                keywords: {
                  keyword:
                    "if else elif endif define undef warning error line pragma ifdef ifndef include",
                },
                contains: [
                  { begin: /\\\n/, relevance: 0 },
                  e.inherit(e.QUOTE_STRING_MODE, { className: "string" }),
                  {
                    className: "string",
                    begin: /<.*?>/,
                    end: /$/,
                    illegal: "\\n",
                  },
                  e.C_LINE_COMMENT_MODE,
                  e.C_BLOCK_COMMENT_MODE,
                ],
              },
              {
                className: "class",
                begin: "(" + a.keyword.join("|") + ")\\b",
                end: /(\{|$)/,
                excludeEnd: !0,
                keywords: a,
                contains: [e.UNDERSCORE_TITLE_MODE],
              },
              { begin: "\\." + e.UNDERSCORE_IDENT_RE, relevance: 0 },
            ],
          };
        },
        grmr_perl: (e) => {
          let t = e.regex,
            a = /[dualxmsipngr]{0,12}/,
            d = {
              $pattern: /[\w.]+/,
              keyword:
                "abs accept alarm and atan2 bind binmode bless break caller chdir chmod chomp chop chown chr chroot class close closedir connect continue cos crypt dbmclose dbmopen defined delete die do dump each else elsif endgrent endhostent endnetent endprotoent endpwent endservent eof eval exec exists exit exp fcntl field fileno flock for foreach fork format formline getc getgrent getgrgid getgrnam gethostbyaddr gethostbyname gethostent getlogin getnetbyaddr getnetbyname getnetent getpeername getpgrp getpriority getprotobyname getprotobynumber getprotoent getpwent getpwnam getpwuid getservbyname getservbyport getservent getsockname getsockopt given glob gmtime goto grep gt hex if index int ioctl join keys kill last lc lcfirst length link listen local localtime log lstat lt ma map method mkdir msgctl msgget msgrcv msgsnd my ne next no not oct open opendir or ord our pack package pipe pop pos print printf prototype push q|0 qq quotemeta qw qx rand read readdir readline readlink readpipe recv redo ref rename require reset return reverse rewinddir rindex rmdir say scalar seek seekdir select semctl semget semop send setgrent sethostent setnetent setpgrp setpriority setprotoent setpwent setservent setsockopt shift shmctl shmget shmread shmwrite shutdown sin sleep socket socketpair sort splice split sprintf sqrt srand stat state study sub substr symlink syscall sysopen sysread sysseek system syswrite tell telldir tie tied time times tr truncate uc ucfirst umask undef unless unlink unpack unshift untie until use utime values vec wait waitpid wantarray warn when while write x|0 xor y|0",
            },
            y = {
              className: "subst",
              begin: "[$@]\\{",
              end: "\\}",
              keywords: d,
            },
            u = { begin: /->\{/, end: /\}/ },
            _ = { scope: "attr", match: /\s+:\s*\w+(\s*\(.*?\))?/ },
            p = {
              scope: "variable",
              variants: [
                { begin: /\$\d/ },
                {
                  begin: t.concat(
                    /[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
                    "(?![A-Za-z])(?![@$%])"
                  ),
                },
                { begin: /[$%@](?!")[^\s\w{=]|\$=/, relevance: 0 },
              ],
              contains: [_],
            },
            L = {
              className: "number",
              variants: [
                { match: /0?\.[0-9][0-9_]+\b/ },
                { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
                { match: /\b0[0-7][0-7_]*\b/ },
                { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
                { match: /\b0b[0-1][0-1_]*\b/ },
              ],
              relevance: 0,
            },
            I = [e.BACKSLASH_ESCAPE, y, p],
            q = [/!/, /\//, /\|/, /\?/, /'/, /"/, /#/],
            ae = (xe, Se, je = "\\1") => {
              let et = je === "\\1" ? je : t.concat(je, Se);
              return t.concat(
                t.concat("(?:", xe, ")"),
                Se,
                /(?:\\.|[^\\\/])*?/,
                et,
                /(?:\\.|[^\\\/])*?/,
                je,
                a
              );
            },
            G = (xe, Se, je) =>
              t.concat(
                t.concat("(?:", xe, ")"),
                Se,
                /(?:\\.|[^\\\/])*?/,
                je,
                a
              ),
            ve = [
              p,
              e.HASH_COMMENT_MODE,
              e.COMMENT(/^=\w/, /=cut/, { endsWithParent: !0 }),
              u,
              {
                className: "string",
                contains: I,
                variants: [
                  { begin: "q[qwxr]?\\s*\\(", end: "\\)", relevance: 5 },
                  { begin: "q[qwxr]?\\s*\\[", end: "\\]", relevance: 5 },
                  { begin: "q[qwxr]?\\s*\\{", end: "\\}", relevance: 5 },
                  { begin: "q[qwxr]?\\s*\\|", end: "\\|", relevance: 5 },
                  { begin: "q[qwxr]?\\s*<", end: ">", relevance: 5 },
                  { begin: "qw\\s+q", end: "q", relevance: 5 },
                  { begin: "'", end: "'", contains: [e.BACKSLASH_ESCAPE] },
                  { begin: '"', end: '"' },
                  { begin: "`", end: "`", contains: [e.BACKSLASH_ESCAPE] },
                  { begin: /\{\w+\}/, relevance: 0 },
                  { begin: "-?\\w+\\s*=>", relevance: 0 },
                ],
              },
              L,
              {
                begin:
                  "(\\/\\/|" +
                  e.RE_STARTERS_RE +
                  "|\\b(split|return|print|reverse|grep)\\b)\\s*",
                keywords: "split return print reverse grep",
                relevance: 0,
                contains: [
                  e.HASH_COMMENT_MODE,
                  {
                    className: "regexp",
                    variants: [
                      { begin: ae("s|tr|y", t.either(...q, { capture: !0 })) },
                      { begin: ae("s|tr|y", "\\(", "\\)") },
                      { begin: ae("s|tr|y", "\\[", "\\]") },
                      { begin: ae("s|tr|y", "\\{", "\\}") },
                    ],
                    relevance: 2,
                  },
                  {
                    className: "regexp",
                    variants: [
                      { begin: /(m|qr)\/\//, relevance: 0 },
                      { begin: G("(?:m|qr)?", /\//, /\//) },
                      {
                        begin: G("m|qr", t.either(...q, { capture: !0 }), /\1/),
                      },
                      { begin: G("m|qr", /\(/, /\)/) },
                      { begin: G("m|qr", /\[/, /\]/) },
                      { begin: G("m|qr", /\{/, /\}/) },
                    ],
                  },
                ],
              },
              {
                className: "function",
                beginKeywords: "sub method",
                end: "(\\s*\\(.*?\\))?[;{]",
                excludeEnd: !0,
                relevance: 5,
                contains: [e.TITLE_MODE, _],
              },
              {
                className: "class",
                beginKeywords: "class",
                end: "[;{]",
                excludeEnd: !0,
                relevance: 5,
                contains: [e.TITLE_MODE, _, L],
              },
              { begin: "-\\w\\b", relevance: 0 },
              {
                begin: "^__DATA__$",
                end: "^__END__$",
                subLanguage: "mojolicious",
                contains: [{ begin: "^@@.*", end: "$", className: "comment" }],
              },
            ];
          return (
            (y.contains = ve),
            (u.contains = ve),
            { name: "Perl", aliases: ["pl", "pm"], keywords: d, contains: ve }
          );
        },
        grmr_php: (e) => {
          let t = e.regex,
            a = /(?![A-Za-z0-9])(?![$])/,
            d = t.concat(/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/, a),
            y = t.concat(
              /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
              a
            ),
            u = t.concat(/[A-Z]+/, a),
            _ = { scope: "variable", match: "\\$+" + d },
            p = {
              scope: "subst",
              variants: [{ begin: /\$\w+/ }, { begin: /\{\$/, end: /\}/ }],
            },
            L = e.inherit(e.APOS_STRING_MODE, { illegal: null }),
            I = `[ 	
]`,
            q = {
              scope: "string",
              variants: [
                e.inherit(e.QUOTE_STRING_MODE, {
                  illegal: null,
                  contains: e.QUOTE_STRING_MODE.contains.concat(p),
                }),
                L,
                {
                  begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
                  end: /[ \t]*(\w+)\b/,
                  contains: e.QUOTE_STRING_MODE.contains.concat(p),
                  "on:begin": (Me, Te) => {
                    Te.data._beginMatch = Me[1] || Me[2];
                  },
                  "on:end": (Me, Te) => {
                    Te.data._beginMatch !== Me[1] && Te.ignoreMatch();
                  },
                },
                e.END_SAME_AS_BEGIN({
                  begin: /<<<[ \t]*'(\w+)'\n/,
                  end: /[ \t]*(\w+)\b/,
                }),
              ],
            },
            ae = {
              scope: "number",
              variants: [
                { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
                { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
                { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
                {
                  begin:
                    "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?",
                },
              ],
              relevance: 0,
            },
            G = ["false", "null", "true"],
            ve = [
              "__CLASS__",
              "__DIR__",
              "__FILE__",
              "__FUNCTION__",
              "__COMPILER_HALT_OFFSET__",
              "__LINE__",
              "__METHOD__",
              "__NAMESPACE__",
              "__TRAIT__",
              "die",
              "echo",
              "exit",
              "include",
              "include_once",
              "print",
              "require",
              "require_once",
              "array",
              "abstract",
              "and",
              "as",
              "binary",
              "bool",
              "boolean",
              "break",
              "callable",
              "case",
              "catch",
              "class",
              "clone",
              "const",
              "continue",
              "declare",
              "default",
              "do",
              "double",
              "else",
              "elseif",
              "empty",
              "enddeclare",
              "endfor",
              "endforeach",
              "endif",
              "endswitch",
              "endwhile",
              "enum",
              "eval",
              "extends",
              "final",
              "finally",
              "float",
              "for",
              "foreach",
              "from",
              "global",
              "goto",
              "if",
              "implements",
              "instanceof",
              "insteadof",
              "int",
              "integer",
              "interface",
              "isset",
              "iterable",
              "list",
              "match|0",
              "mixed",
              "new",
              "never",
              "object",
              "or",
              "private",
              "protected",
              "public",
              "readonly",
              "real",
              "return",
              "string",
              "switch",
              "throw",
              "trait",
              "try",
              "unset",
              "use",
              "var",
              "void",
              "while",
              "xor",
              "yield",
            ],
            xe = [
              "Error|0",
              "AppendIterator",
              "ArgumentCountError",
              "ArithmeticError",
              "ArrayIterator",
              "ArrayObject",
              "AssertionError",
              "BadFunctionCallException",
              "BadMethodCallException",
              "CachingIterator",
              "CallbackFilterIterator",
              "CompileError",
              "Countable",
              "DirectoryIterator",
              "DivisionByZeroError",
              "DomainException",
              "EmptyIterator",
              "ErrorException",
              "Exception",
              "FilesystemIterator",
              "FilterIterator",
              "GlobIterator",
              "InfiniteIterator",
              "InvalidArgumentException",
              "IteratorIterator",
              "LengthException",
              "LimitIterator",
              "LogicException",
              "MultipleIterator",
              "NoRewindIterator",
              "OutOfBoundsException",
              "OutOfRangeException",
              "OuterIterator",
              "OverflowException",
              "ParentIterator",
              "ParseError",
              "RangeException",
              "RecursiveArrayIterator",
              "RecursiveCachingIterator",
              "RecursiveCallbackFilterIterator",
              "RecursiveDirectoryIterator",
              "RecursiveFilterIterator",
              "RecursiveIterator",
              "RecursiveIteratorIterator",
              "RecursiveRegexIterator",
              "RecursiveTreeIterator",
              "RegexIterator",
              "RuntimeException",
              "SeekableIterator",
              "SplDoublyLinkedList",
              "SplFileInfo",
              "SplFileObject",
              "SplFixedArray",
              "SplHeap",
              "SplMaxHeap",
              "SplMinHeap",
              "SplObjectStorage",
              "SplObserver",
              "SplPriorityQueue",
              "SplQueue",
              "SplStack",
              "SplSubject",
              "SplTempFileObject",
              "TypeError",
              "UnderflowException",
              "UnexpectedValueException",
              "UnhandledMatchError",
              "ArrayAccess",
              "BackedEnum",
              "Closure",
              "Fiber",
              "Generator",
              "Iterator",
              "IteratorAggregate",
              "Serializable",
              "Stringable",
              "Throwable",
              "Traversable",
              "UnitEnum",
              "WeakReference",
              "WeakMap",
              "Directory",
              "__PHP_Incomplete_Class",
              "parent",
              "php_user_filter",
              "self",
              "static",
              "stdClass",
            ],
            Se = {
              keyword: ve,
              literal: ((Me) => {
                let Te = [];
                return (
                  Me.forEach((Oe) => {
                    Te.push(Oe),
                      Oe.toLowerCase() === Oe
                        ? Te.push(Oe.toUpperCase())
                        : Te.push(Oe.toLowerCase());
                  }),
                  Te
                );
              })(G),
              built_in: xe,
            },
            je = (Me) => Me.map((Te) => Te.replace(/\|\d+$/, "")),
            et = {
              variants: [
                {
                  match: [
                    /new/,
                    t.concat(I, "+"),
                    t.concat("(?!", je(xe).join("\\b|"), "\\b)"),
                    y,
                  ],
                  scope: { 1: "keyword", 4: "title.class" },
                },
              ],
            },
            Xe = t.concat(d, "\\b(?!\\()"),
            z = {
              variants: [
                {
                  match: [t.concat(/::/, t.lookahead(/(?!class\b)/)), Xe],
                  scope: { 2: "variable.constant" },
                },
                { match: [/::/, /class/], scope: { 2: "variable.language" } },
                {
                  match: [y, t.concat(/::/, t.lookahead(/(?!class\b)/)), Xe],
                  scope: { 1: "title.class", 3: "variable.constant" },
                },
                {
                  match: [y, t.concat("::", t.lookahead(/(?!class\b)/))],
                  scope: { 1: "title.class" },
                },
                {
                  match: [y, /::/, /class/],
                  scope: { 1: "title.class", 3: "variable.language" },
                },
              ],
            },
            Y = {
              scope: "attr",
              match: t.concat(d, t.lookahead(":"), t.lookahead(/(?!::)/)),
            },
            pe = {
              relevance: 0,
              begin: /\(/,
              end: /\)/,
              keywords: Se,
              contains: [Y, _, z, e.C_BLOCK_COMMENT_MODE, q, ae, et],
            },
            Ke = {
              relevance: 0,
              match: [
                /\b/,
                t.concat(
                  "(?!fn\\b|function\\b|",
                  je(ve).join("\\b|"),
                  "|",
                  je(xe).join("\\b|"),
                  "\\b)"
                ),
                d,
                t.concat(I, "*"),
                t.lookahead(/(?=\()/),
              ],
              scope: { 3: "title.function.invoke" },
              contains: [pe],
            };
          pe.contains.push(Ke);
          let Pe = [Y, z, e.C_BLOCK_COMMENT_MODE, q, ae, et],
            Fe = {
              begin: t.concat(/#\[\s*\\?/, t.either(y, u)),
              beginScope: "meta",
              end: /]/,
              endScope: "meta",
              keywords: { literal: G, keyword: ["new", "array"] },
              contains: [
                {
                  begin: /\[/,
                  end: /]/,
                  keywords: { literal: G, keyword: ["new", "array"] },
                  contains: ["self", ...Pe],
                },
                ...Pe,
                { scope: "meta", variants: [{ match: y }, { match: u }] },
              ],
            };
          return {
            case_insensitive: !1,
            keywords: Se,
            contains: [
              Fe,
              e.HASH_COMMENT_MODE,
              e.COMMENT("//", "$"),
              e.COMMENT("/\\*", "\\*/", {
                contains: [{ scope: "doctag", match: "@[A-Za-z]+" }],
              }),
              {
                match: /__halt_compiler\(\);/,
                keywords: "__halt_compiler",
                starts: {
                  scope: "comment",
                  end: e.MATCH_NOTHING_RE,
                  contains: [{ match: /\?>/, scope: "meta", endsParent: !0 }],
                },
              },
              {
                scope: "meta",
                variants: [
                  { begin: /<\?php/, relevance: 10 },
                  { begin: /<\?=/ },
                  { begin: /<\?/, relevance: 0.1 },
                  { begin: /\?>/ },
                ],
              },
              { scope: "variable.language", match: /\$this\b/ },
              _,
              Ke,
              z,
              {
                match: [/const/, /\s/, d],
                scope: { 1: "keyword", 3: "variable.constant" },
              },
              et,
              {
                scope: "function",
                relevance: 0,
                beginKeywords: "fn function",
                end: /[;{]/,
                excludeEnd: !0,
                illegal: "[$%\\[]",
                contains: [
                  { beginKeywords: "use" },
                  e.UNDERSCORE_TITLE_MODE,
                  { begin: "=>", endsParent: !0 },
                  {
                    scope: "params",
                    begin: "\\(",
                    end: "\\)",
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: Se,
                    contains: ["self", Fe, _, z, e.C_BLOCK_COMMENT_MODE, q, ae],
                  },
                ],
              },
              {
                scope: "class",
                variants: [
                  { beginKeywords: "enum", illegal: /[($"]/ },
                  { beginKeywords: "class interface trait", illegal: /[:($"]/ },
                ],
                relevance: 0,
                end: /\{/,
                excludeEnd: !0,
                contains: [
                  { beginKeywords: "extends implements" },
                  e.UNDERSCORE_TITLE_MODE,
                ],
              },
              {
                beginKeywords: "namespace",
                relevance: 0,
                end: ";",
                illegal: /[.']/,
                contains: [
                  e.inherit(e.UNDERSCORE_TITLE_MODE, { scope: "title.class" }),
                ],
              },
              {
                beginKeywords: "use",
                relevance: 0,
                end: ";",
                contains: [
                  { match: /\b(as|const|function)\b/, scope: "keyword" },
                  e.UNDERSCORE_TITLE_MODE,
                ],
              },
              q,
              ae,
            ],
          };
        },
        grmr_php_template: (e) => ({
          name: "PHP template",
          subLanguage: "xml",
          contains: [
            {
              begin: /<\?(php|=)?/,
              end: /\?>/,
              subLanguage: "php",
              contains: [
                { begin: "/\\*", end: "\\*/", skip: !0 },
                { begin: 'b"', end: '"', skip: !0 },
                { begin: "b'", end: "'", skip: !0 },
                e.inherit(e.APOS_STRING_MODE, {
                  illegal: null,
                  className: null,
                  contains: null,
                  skip: !0,
                }),
                e.inherit(e.QUOTE_STRING_MODE, {
                  illegal: null,
                  className: null,
                  contains: null,
                  skip: !0,
                }),
              ],
            },
          ],
        }),
        grmr_plaintext: (e) => ({
          name: "Plain text",
          aliases: ["text", "txt"],
          disableAutodetect: !0,
        }),
        grmr_python: (e) => {
          let t = e.regex,
            a = /[\p{XID_Start}_]\p{XID_Continue}*/u,
            d = [
              "and",
              "as",
              "assert",
              "async",
              "await",
              "break",
              "case",
              "class",
              "continue",
              "def",
              "del",
              "elif",
              "else",
              "except",
              "finally",
              "for",
              "from",
              "global",
              "if",
              "import",
              "in",
              "is",
              "lambda",
              "match",
              "nonlocal|10",
              "not",
              "or",
              "pass",
              "raise",
              "return",
              "try",
              "while",
              "with",
              "yield",
            ],
            y = {
              $pattern: /[A-Za-z]\w+|__\w+__/,
              keyword: d,
              built_in: [
                "__import__",
                "abs",
                "all",
                "any",
                "ascii",
                "bin",
                "bool",
                "breakpoint",
                "bytearray",
                "bytes",
                "callable",
                "chr",
                "classmethod",
                "compile",
                "complex",
                "delattr",
                "dict",
                "dir",
                "divmod",
                "enumerate",
                "eval",
                "exec",
                "filter",
                "float",
                "format",
                "frozenset",
                "getattr",
                "globals",
                "hasattr",
                "hash",
                "help",
                "hex",
                "id",
                "input",
                "int",
                "isinstance",
                "issubclass",
                "iter",
                "len",
                "list",
                "locals",
                "map",
                "max",
                "memoryview",
                "min",
                "next",
                "object",
                "oct",
                "open",
                "ord",
                "pow",
                "print",
                "property",
                "range",
                "repr",
                "reversed",
                "round",
                "set",
                "setattr",
                "slice",
                "sorted",
                "staticmethod",
                "str",
                "sum",
                "super",
                "tuple",
                "type",
                "vars",
                "zip",
              ],
              literal: [
                "__debug__",
                "Ellipsis",
                "False",
                "None",
                "NotImplemented",
                "True",
              ],
              type: [
                "Any",
                "Callable",
                "Coroutine",
                "Dict",
                "List",
                "Literal",
                "Generic",
                "Optional",
                "Sequence",
                "Set",
                "Tuple",
                "Type",
                "Union",
              ],
            },
            u = { className: "meta", begin: /^(>>>|\.\.\.) / },
            _ = {
              className: "subst",
              begin: /\{/,
              end: /\}/,
              keywords: y,
              illegal: /#/,
            },
            p = { begin: /\{\{/, relevance: 0 },
            L = {
              className: "string",
              contains: [e.BACKSLASH_ESCAPE],
              variants: [
                {
                  begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
                  end: /'''/,
                  contains: [e.BACKSLASH_ESCAPE, u],
                  relevance: 10,
                },
                {
                  begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
                  end: /"""/,
                  contains: [e.BACKSLASH_ESCAPE, u],
                  relevance: 10,
                },
                {
                  begin: /([fF][rR]|[rR][fF]|[fF])'''/,
                  end: /'''/,
                  contains: [e.BACKSLASH_ESCAPE, u, p, _],
                },
                {
                  begin: /([fF][rR]|[rR][fF]|[fF])"""/,
                  end: /"""/,
                  contains: [e.BACKSLASH_ESCAPE, u, p, _],
                },
                { begin: /([uU]|[rR])'/, end: /'/, relevance: 10 },
                { begin: /([uU]|[rR])"/, end: /"/, relevance: 10 },
                { begin: /([bB]|[bB][rR]|[rR][bB])'/, end: /'/ },
                { begin: /([bB]|[bB][rR]|[rR][bB])"/, end: /"/ },
                {
                  begin: /([fF][rR]|[rR][fF]|[fF])'/,
                  end: /'/,
                  contains: [e.BACKSLASH_ESCAPE, p, _],
                },
                {
                  begin: /([fF][rR]|[rR][fF]|[fF])"/,
                  end: /"/,
                  contains: [e.BACKSLASH_ESCAPE, p, _],
                },
                e.APOS_STRING_MODE,
                e.QUOTE_STRING_MODE,
              ],
            },
            I = "[0-9](_?[0-9])*",
            q = `(\\b(${I}))?\\.(${I})|\\b(${I})\\.`,
            ae = "\\b|" + d.join("|"),
            G = {
              className: "number",
              relevance: 0,
              variants: [
                { begin: `(\\b(${I})|(${q}))[eE][+-]?(${I})[jJ]?(?=${ae})` },
                { begin: `(${q})[jJ]?` },
                { begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${ae})` },
                { begin: `\\b0[bB](_?[01])+[lL]?(?=${ae})` },
                { begin: `\\b0[oO](_?[0-7])+[lL]?(?=${ae})` },
                { begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${ae})` },
                { begin: `\\b(${I})[jJ](?=${ae})` },
              ],
            },
            ve = {
              className: "comment",
              begin: t.lookahead(/# type:/),
              end: /$/,
              keywords: y,
              contains: [
                { begin: /# type:/ },
                { begin: /#/, end: /\b\B/, endsWithParent: !0 },
              ],
            },
            xe = {
              className: "params",
              variants: [
                { className: "", begin: /\(\s*\)/, skip: !0 },
                {
                  begin: /\(/,
                  end: /\)/,
                  excludeBegin: !0,
                  excludeEnd: !0,
                  keywords: y,
                  contains: ["self", u, G, L, e.HASH_COMMENT_MODE],
                },
              ],
            };
          return (
            (_.contains = [L, G, u]),
            {
              name: "Python",
              aliases: ["py", "gyp", "ipython"],
              unicodeRegex: !0,
              keywords: y,
              illegal: /(<\/|\?)|=>/,
              contains: [
                u,
                G,
                { scope: "variable.language", match: /\bself\b/ },
                { beginKeywords: "if", relevance: 0 },
                { match: /\bor\b/, scope: "keyword" },
                L,
                ve,
                e.HASH_COMMENT_MODE,
                {
                  match: [/\bdef/, /\s+/, a],
                  scope: { 1: "keyword", 3: "title.function" },
                  contains: [xe],
                },
                {
                  variants: [
                    {
                      match: [/\bclass/, /\s+/, a, /\s*/, /\(\s*/, a, /\s*\)/],
                    },
                    { match: [/\bclass/, /\s+/, a] },
                  ],
                  scope: {
                    1: "keyword",
                    3: "title.class",
                    6: "title.class.inherited",
                  },
                },
                {
                  className: "meta",
                  begin: /^[\t ]*@/,
                  end: /(?=#)|$/,
                  contains: [G, xe, L],
                },
              ],
            }
          );
        },
        grmr_python_repl: (e) => ({
          aliases: ["pycon"],
          contains: [
            {
              className: "meta.prompt",
              starts: {
                end: / |$/,
                starts: { end: "$", subLanguage: "python" },
              },
              variants: [
                { begin: /^>>>(?=[ ]|$)/ },
                { begin: /^\.\.\.(?=[ ]|$)/ },
              ],
            },
          ],
        }),
        grmr_r: (e) => {
          let t = e.regex,
            a = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/,
            d = t.either(
              /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
              /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
              /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
            ),
            y =
              /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/,
            u = t.either(/[()]/, /[{}]/, /\[\[/, /[[\]]/, /\\/, /,/);
          return {
            name: "R",
            keywords: {
              $pattern: a,
              keyword: "function if in break next repeat else for while",
              literal:
                "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
              built_in:
                "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm",
            },
            contains: [
              e.COMMENT(/#'/, /$/, {
                contains: [
                  {
                    scope: "doctag",
                    match: /@examples/,
                    starts: {
                      end: t.lookahead(
                        t.either(/\n^#'\s*(?=@[a-zA-Z]+)/, /\n^(?!#')/)
                      ),
                      endsParent: !0,
                    },
                  },
                  {
                    scope: "doctag",
                    begin: "@param",
                    end: /$/,
                    contains: [
                      {
                        scope: "variable",
                        variants: [
                          { match: a },
                          { match: /`(?:\\.|[^`\\])+`/ },
                        ],
                        endsParent: !0,
                      },
                    ],
                  },
                  { scope: "doctag", match: /@[a-zA-Z]+/ },
                  { scope: "keyword", match: /\\[a-zA-Z]+/ },
                ],
              }),
              e.HASH_COMMENT_MODE,
              {
                scope: "string",
                contains: [e.BACKSLASH_ESCAPE],
                variants: [
                  e.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\(/, end: /\)(-*)"/ }),
                  e.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\{/, end: /\}(-*)"/ }),
                  e.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\[/, end: /\](-*)"/ }),
                  e.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\(/, end: /\)(-*)'/ }),
                  e.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\{/, end: /\}(-*)'/ }),
                  e.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\[/, end: /\](-*)'/ }),
                  { begin: '"', end: '"', relevance: 0 },
                  { begin: "'", end: "'", relevance: 0 },
                ],
              },
              {
                relevance: 0,
                variants: [
                  { scope: { 1: "operator", 2: "number" }, match: [y, d] },
                  {
                    scope: { 1: "operator", 2: "number" },
                    match: [/%[^%]*%/, d],
                  },
                  { scope: { 1: "punctuation", 2: "number" }, match: [u, d] },
                  { scope: { 2: "number" }, match: [/[^a-zA-Z0-9._]|^/, d] },
                ],
              },
              { scope: { 3: "operator" }, match: [a, /\s+/, /<-/, /\s+/] },
              {
                scope: "operator",
                relevance: 0,
                variants: [{ match: y }, { match: /%[^%]*%/ }],
              },
              { scope: "punctuation", relevance: 0, match: u },
              { begin: "`", end: "`", contains: [{ begin: /\\./ }] },
            ],
          };
        },
        grmr_ruby: (e) => {
          let t = e.regex,
            a =
              "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)",
            d = t.either(/\b([A-Z]+[a-z0-9]+)+/, /\b([A-Z]+[a-z0-9]+)+[A-Z]+/),
            y = t.concat(d, /(::\w+)*/),
            u = {
              "variable.constant": ["__FILE__", "__LINE__", "__ENCODING__"],
              "variable.language": ["self", "super"],
              keyword: [
                "alias",
                "and",
                "begin",
                "BEGIN",
                "break",
                "case",
                "class",
                "defined",
                "do",
                "else",
                "elsif",
                "end",
                "END",
                "ensure",
                "for",
                "if",
                "in",
                "module",
                "next",
                "not",
                "or",
                "redo",
                "require",
                "rescue",
                "retry",
                "return",
                "then",
                "undef",
                "unless",
                "until",
                "when",
                "while",
                "yield",
                "include",
                "extend",
                "prepend",
                "public",
                "private",
                "protected",
                "raise",
                "throw",
              ],
              built_in: [
                "proc",
                "lambda",
                "attr_accessor",
                "attr_reader",
                "attr_writer",
                "define_method",
                "private_constant",
                "module_function",
              ],
              literal: ["true", "false", "nil"],
            },
            _ = { className: "doctag", begin: "@[A-Za-z]+" },
            p = { begin: "#<", end: ">" },
            L = [
              e.COMMENT("#", "$", { contains: [_] }),
              e.COMMENT("^=begin", "^=end", { contains: [_], relevance: 10 }),
              e.COMMENT("^__END__", e.MATCH_NOTHING_RE),
            ],
            I = { className: "subst", begin: /#\{/, end: /\}/, keywords: u },
            q = {
              className: "string",
              contains: [e.BACKSLASH_ESCAPE, I],
              variants: [
                { begin: /'/, end: /'/ },
                { begin: /"/, end: /"/ },
                { begin: /`/, end: /`/ },
                { begin: /%[qQwWx]?\(/, end: /\)/ },
                { begin: /%[qQwWx]?\[/, end: /\]/ },
                { begin: /%[qQwWx]?\{/, end: /\}/ },
                { begin: /%[qQwWx]?</, end: />/ },
                { begin: /%[qQwWx]?\//, end: /\// },
                { begin: /%[qQwWx]?%/, end: /%/ },
                { begin: /%[qQwWx]?-/, end: /-/ },
                { begin: /%[qQwWx]?\|/, end: /\|/ },
                { begin: /\B\?(\\\d{1,3})/ },
                { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
                { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
                {
                  begin:
                    /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/,
                },
                { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
                { begin: /\B\?\\?\S/ },
                {
                  begin: t.concat(
                    /<<[-~]?'?/,
                    t.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
                  ),
                  contains: [
                    e.END_SAME_AS_BEGIN({
                      begin: /(\w+)/,
                      end: /(\w+)/,
                      contains: [e.BACKSLASH_ESCAPE, I],
                    }),
                  ],
                },
              ],
            },
            ae = "[0-9](_?[0-9])*",
            G = {
              className: "number",
              relevance: 0,
              variants: [
                {
                  begin: `\\b([1-9](_?[0-9])*|0)(\\.(${ae}))?([eE][+-]?(${ae})|r)?i?\\b`,
                },
                { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
                { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
                { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
                { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
                { begin: "\\b0(_?[0-7])+r?i?\\b" },
              ],
            },
            ve = {
              variants: [
                { match: /\(\)/ },
                {
                  className: "params",
                  begin: /\(/,
                  end: /(?=\))/,
                  excludeBegin: !0,
                  endsParent: !0,
                  keywords: u,
                },
              ],
            },
            xe = [
              q,
              {
                variants: [
                  { match: [/class\s+/, y, /\s+<\s+/, y] },
                  { match: [/\b(class|module)\s+/, y] },
                ],
                scope: { 2: "title.class", 4: "title.class.inherited" },
                keywords: u,
              },
              {
                match: [/(include|extend)\s+/, y],
                scope: { 2: "title.class" },
                keywords: u,
              },
              {
                relevance: 0,
                match: [y, /\.new[. (]/],
                scope: { 1: "title.class" },
              },
              {
                relevance: 0,
                match: /\b[A-Z][A-Z_0-9]+\b/,
                className: "variable.constant",
              },
              { relevance: 0, match: d, scope: "title.class" },
              {
                match: [/def/, /\s+/, a],
                scope: { 1: "keyword", 3: "title.function" },
                contains: [ve],
              },
              { begin: e.IDENT_RE + "::" },
              {
                className: "symbol",
                begin: e.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
                relevance: 0,
              },
              {
                className: "symbol",
                begin: ":(?!\\s)",
                contains: [q, { begin: a }],
                relevance: 0,
              },
              G,
              {
                className: "variable",
                begin:
                  "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])",
              },
              {
                className: "params",
                begin: /\|(?!=)/,
                end: /\|/,
                excludeBegin: !0,
                excludeEnd: !0,
                relevance: 0,
                keywords: u,
              },
              {
                begin: "(" + e.RE_STARTERS_RE + "|unless)\\s*",
                keywords: "unless",
                contains: [
                  {
                    className: "regexp",
                    contains: [e.BACKSLASH_ESCAPE, I],
                    illegal: /\n/,
                    variants: [
                      { begin: "/", end: "/[a-z]*" },
                      { begin: /%r\{/, end: /\}[a-z]*/ },
                      { begin: "%r\\(", end: "\\)[a-z]*" },
                      { begin: "%r!", end: "![a-z]*" },
                      { begin: "%r\\[", end: "\\][a-z]*" },
                    ],
                  },
                ].concat(p, L),
                relevance: 0,
              },
            ].concat(p, L);
          (I.contains = xe), (ve.contains = xe);
          let Se = [
            { begin: /^\s*=>/, starts: { end: "$", contains: xe } },
            {
              className: "meta.prompt",
              begin:
                "^([>?]>|[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]|(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>)(?=[ ])",
              starts: { end: "$", keywords: u, contains: xe },
            },
          ];
          return (
            L.unshift(p),
            {
              name: "Ruby",
              aliases: ["rb", "gemspec", "podspec", "thor", "irb"],
              keywords: u,
              illegal: /\/\*/,
              contains: [e.SHEBANG({ binary: "ruby" })]
                .concat(Se)
                .concat(L)
                .concat(xe),
            }
          );
        },
        grmr_rust: (e) => {
          let t = e.regex,
            a = /(r#)?/,
            d = t.concat(a, e.UNDERSCORE_IDENT_RE),
            y = t.concat(a, e.IDENT_RE),
            u = {
              className: "title.function.invoke",
              relevance: 0,
              begin: t.concat(
                /\b/,
                /(?!let|for|while|if|else|match\b)/,
                y,
                t.lookahead(/\s*\(/)
              ),
            },
            _ = "([ui](8|16|32|64|128|size)|f(32|64))?",
            p = [
              "drop ",
              "Copy",
              "Send",
              "Sized",
              "Sync",
              "Drop",
              "Fn",
              "FnMut",
              "FnOnce",
              "ToOwned",
              "Clone",
              "Debug",
              "PartialEq",
              "PartialOrd",
              "Eq",
              "Ord",
              "AsRef",
              "AsMut",
              "Into",
              "From",
              "Default",
              "Iterator",
              "Extend",
              "IntoIterator",
              "DoubleEndedIterator",
              "ExactSizeIterator",
              "SliceConcatExt",
              "ToString",
              "assert!",
              "assert_eq!",
              "bitflags!",
              "bytes!",
              "cfg!",
              "col!",
              "concat!",
              "concat_idents!",
              "debug_assert!",
              "debug_assert_eq!",
              "env!",
              "eprintln!",
              "panic!",
              "file!",
              "format!",
              "format_args!",
              "include_bytes!",
              "include_str!",
              "line!",
              "local_data_key!",
              "module_path!",
              "option_env!",
              "print!",
              "println!",
              "select!",
              "stringify!",
              "try!",
              "unimplemented!",
              "unreachable!",
              "vec!",
              "write!",
              "writeln!",
              "macro_rules!",
              "assert_ne!",
              "debug_assert_ne!",
            ],
            L = [
              "i8",
              "i16",
              "i32",
              "i64",
              "i128",
              "isize",
              "u8",
              "u16",
              "u32",
              "u64",
              "u128",
              "usize",
              "f32",
              "f64",
              "str",
              "char",
              "bool",
              "Box",
              "Option",
              "Result",
              "String",
              "Vec",
            ];
          return {
            name: "Rust",
            aliases: ["rs"],
            keywords: {
              $pattern: e.IDENT_RE + "!?",
              type: L,
              keyword: [
                "abstract",
                "as",
                "async",
                "await",
                "become",
                "box",
                "break",
                "const",
                "continue",
                "crate",
                "do",
                "dyn",
                "else",
                "enum",
                "extern",
                "false",
                "final",
                "fn",
                "for",
                "if",
                "impl",
                "in",
                "let",
                "loop",
                "macro",
                "match",
                "mod",
                "move",
                "mut",
                "override",
                "priv",
                "pub",
                "ref",
                "return",
                "self",
                "Self",
                "static",
                "struct",
                "super",
                "trait",
                "true",
                "try",
                "type",
                "typeof",
                "union",
                "unsafe",
                "unsized",
                "use",
                "virtual",
                "where",
                "while",
                "yield",
              ],
              literal: ["true", "false", "Some", "None", "Ok", "Err"],
              built_in: p,
            },
            illegal: "</",
            contains: [
              e.C_LINE_COMMENT_MODE,
              e.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
              e.inherit(e.QUOTE_STRING_MODE, { begin: /b?"/, illegal: null }),
              { className: "symbol", begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/ },
              {
                scope: "string",
                variants: [
                  { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
                  {
                    begin: /b?'/,
                    end: /'/,
                    contains: [
                      {
                        scope: "char.escape",
                        match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/,
                      },
                    ],
                  },
                ],
              },
              {
                className: "number",
                variants: [
                  { begin: "\\b0b([01_]+)" + _ },
                  { begin: "\\b0o([0-7_]+)" + _ },
                  { begin: "\\b0x([A-Fa-f0-9_]+)" + _ },
                  {
                    begin:
                      "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + _,
                  },
                ],
                relevance: 0,
              },
              {
                begin: [/fn/, /\s+/, d],
                className: { 1: "keyword", 3: "title.function" },
              },
              {
                className: "meta",
                begin: "#!?\\[",
                end: "\\]",
                contains: [
                  {
                    className: "string",
                    begin: /"/,
                    end: /"/,
                    contains: [e.BACKSLASH_ESCAPE],
                  },
                ],
              },
              {
                begin: [/let/, /\s+/, /(?:mut\s+)?/, d],
                className: { 1: "keyword", 3: "keyword", 4: "variable" },
              },
              {
                begin: [/for/, /\s+/, d, /\s+/, /in/],
                className: { 1: "keyword", 3: "variable", 5: "keyword" },
              },
              {
                begin: [/type/, /\s+/, d],
                className: { 1: "keyword", 3: "title.class" },
              },
              {
                begin: [/(?:trait|enum|struct|union|impl|for)/, /\s+/, d],
                className: { 1: "keyword", 3: "title.class" },
              },
              {
                begin: e.IDENT_RE + "::",
                keywords: { keyword: "Self", built_in: p, type: L },
              },
              { className: "punctuation", begin: "->" },
              u,
            ],
          };
        },
        grmr_scss: (e) => {
          let t = M(e),
            a = te,
            d = ee,
            y = "@[a-z-]+",
            u = {
              className: "variable",
              begin: "(\\$[a-zA-Z-][a-zA-Z0-9_-]*)\\b",
              relevance: 0,
            };
          return {
            name: "SCSS",
            case_insensitive: !0,
            illegal: "[=/|']",
            contains: [
              e.C_LINE_COMMENT_MODE,
              e.C_BLOCK_COMMENT_MODE,
              t.CSS_NUMBER_MODE,
              {
                className: "selector-id",
                begin: "#[A-Za-z0-9_-]+",
                relevance: 0,
              },
              {
                className: "selector-class",
                begin: "\\.[A-Za-z0-9_-]+",
                relevance: 0,
              },
              t.ATTRIBUTE_SELECTOR_MODE,
              {
                className: "selector-tag",
                begin: "\\b(" + D.join("|") + ")\\b",
                relevance: 0,
              },
              { className: "selector-pseudo", begin: ":(" + d.join("|") + ")" },
              {
                className: "selector-pseudo",
                begin: ":(:)?(" + a.join("|") + ")",
              },
              u,
              { begin: /\(/, end: /\)/, contains: [t.CSS_NUMBER_MODE] },
              t.CSS_VARIABLE,
              { className: "attribute", begin: "\\b(" + j.join("|") + ")\\b" },
              {
                begin:
                  "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b",
              },
              {
                begin: /:/,
                end: /[;}{]/,
                relevance: 0,
                contains: [
                  t.BLOCK_COMMENT,
                  u,
                  t.HEXCOLOR,
                  t.CSS_NUMBER_MODE,
                  e.QUOTE_STRING_MODE,
                  e.APOS_STRING_MODE,
                  t.IMPORTANT,
                  t.FUNCTION_DISPATCH,
                ],
              },
              {
                begin: "@(page|font-face)",
                keywords: { $pattern: y, keyword: "@page @font-face" },
              },
              {
                begin: "@",
                end: "[{;]",
                returnBegin: !0,
                keywords: {
                  $pattern: /[a-z-]+/,
                  keyword: "and or not only",
                  attribute: H.join(" "),
                },
                contains: [
                  { begin: y, className: "keyword" },
                  { begin: /[a-z-]+(?=:)/, className: "attribute" },
                  u,
                  e.QUOTE_STRING_MODE,
                  e.APOS_STRING_MODE,
                  t.HEXCOLOR,
                  t.CSS_NUMBER_MODE,
                ],
              },
              t.FUNCTION_DISPATCH,
            ],
          };
        },
        grmr_shell: (e) => ({
          name: "Shell Session",
          aliases: ["console", "shellsession"],
          contains: [
            {
              className: "meta.prompt",
              begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
              starts: { end: /[^\\](?=\s*$)/, subLanguage: "bash" },
            },
          ],
        }),
        grmr_sql: (e) => {
          let t = e.regex,
            a = e.COMMENT("--", "$"),
            d = [
              "abs",
              "acos",
              "array_agg",
              "asin",
              "atan",
              "avg",
              "cast",
              "ceil",
              "ceiling",
              "coalesce",
              "corr",
              "cos",
              "cosh",
              "count",
              "covar_pop",
              "covar_samp",
              "cume_dist",
              "dense_rank",
              "deref",
              "element",
              "exp",
              "extract",
              "first_value",
              "floor",
              "json_array",
              "json_arrayagg",
              "json_exists",
              "json_object",
              "json_objectagg",
              "json_query",
              "json_table",
              "json_table_primitive",
              "json_value",
              "lag",
              "last_value",
              "lead",
              "listagg",
              "ln",
              "log",
              "log10",
              "lower",
              "max",
              "min",
              "mod",
              "nth_value",
              "ntile",
              "nullif",
              "percent_rank",
              "percentile_cont",
              "percentile_disc",
              "position",
              "position_regex",
              "power",
              "rank",
              "regr_avgx",
              "regr_avgy",
              "regr_count",
              "regr_intercept",
              "regr_r2",
              "regr_slope",
              "regr_sxx",
              "regr_sxy",
              "regr_syy",
              "row_number",
              "sin",
              "sinh",
              "sqrt",
              "stddev_pop",
              "stddev_samp",
              "substring",
              "substring_regex",
              "sum",
              "tan",
              "tanh",
              "translate",
              "translate_regex",
              "treat",
              "trim",
              "trim_array",
              "unnest",
              "upper",
              "value_of",
              "var_pop",
              "var_samp",
              "width_bucket",
            ],
            y = d,
            u = [
              "abs",
              "acos",
              "all",
              "allocate",
              "alter",
              "and",
              "any",
              "are",
              "array",
              "array_agg",
              "array_max_cardinality",
              "as",
              "asensitive",
              "asin",
              "asymmetric",
              "at",
              "atan",
              "atomic",
              "authorization",
              "avg",
              "begin",
              "begin_frame",
              "begin_partition",
              "between",
              "bigint",
              "binary",
              "blob",
              "boolean",
              "both",
              "by",
              "call",
              "called",
              "cardinality",
              "cascaded",
              "case",
              "cast",
              "ceil",
              "ceiling",
              "char",
              "char_length",
              "character",
              "character_length",
              "check",
              "classifier",
              "clob",
              "close",
              "coalesce",
              "collate",
              "collect",
              "column",
              "commit",
              "condition",
              "connect",
              "constraint",
              "contains",
              "convert",
              "copy",
              "corr",
              "corresponding",
              "cos",
              "cosh",
              "count",
              "covar_pop",
              "covar_samp",
              "create",
              "cross",
              "cube",
              "cume_dist",
              "current",
              "current_catalog",
              "current_date",
              "current_default_transform_group",
              "current_path",
              "current_role",
              "current_row",
              "current_schema",
              "current_time",
              "current_timestamp",
              "current_path",
              "current_role",
              "current_transform_group_for_type",
              "current_user",
              "cursor",
              "cycle",
              "date",
              "day",
              "deallocate",
              "dec",
              "decimal",
              "decfloat",
              "declare",
              "default",
              "define",
              "delete",
              "dense_rank",
              "deref",
              "describe",
              "deterministic",
              "disconnect",
              "distinct",
              "double",
              "drop",
              "dynamic",
              "each",
              "element",
              "else",
              "empty",
              "end",
              "end_frame",
              "end_partition",
              "end-exec",
              "equals",
              "escape",
              "every",
              "except",
              "exec",
              "execute",
              "exists",
              "exp",
              "external",
              "extract",
              "false",
              "fetch",
              "filter",
              "first_value",
              "float",
              "floor",
              "for",
              "foreign",
              "frame_row",
              "free",
              "from",
              "full",
              "function",
              "fusion",
              "get",
              "global",
              "grant",
              "group",
              "grouping",
              "groups",
              "having",
              "hold",
              "hour",
              "identity",
              "in",
              "indicator",
              "initial",
              "inner",
              "inout",
              "insensitive",
              "insert",
              "int",
              "integer",
              "intersect",
              "intersection",
              "interval",
              "into",
              "is",
              "join",
              "json_array",
              "json_arrayagg",
              "json_exists",
              "json_object",
              "json_objectagg",
              "json_query",
              "json_table",
              "json_table_primitive",
              "json_value",
              "lag",
              "language",
              "large",
              "last_value",
              "lateral",
              "lead",
              "leading",
              "left",
              "like",
              "like_regex",
              "listagg",
              "ln",
              "local",
              "localtime",
              "localtimestamp",
              "log",
              "log10",
              "lower",
              "match",
              "match_number",
              "match_recognize",
              "matches",
              "max",
              "member",
              "merge",
              "method",
              "min",
              "minute",
              "mod",
              "modifies",
              "module",
              "month",
              "multiset",
              "national",
              "natural",
              "nchar",
              "nclob",
              "new",
              "no",
              "none",
              "normalize",
              "not",
              "nth_value",
              "ntile",
              "null",
              "nullif",
              "numeric",
              "octet_length",
              "occurrences_regex",
              "of",
              "offset",
              "old",
              "omit",
              "on",
              "one",
              "only",
              "open",
              "or",
              "order",
              "out",
              "outer",
              "over",
              "overlaps",
              "overlay",
              "parameter",
              "partition",
              "pattern",
              "per",
              "percent",
              "percent_rank",
              "percentile_cont",
              "percentile_disc",
              "period",
              "portion",
              "position",
              "position_regex",
              "power",
              "precedes",
              "precision",
              "prepare",
              "primary",
              "procedure",
              "ptf",
              "range",
              "rank",
              "reads",
              "real",
              "recursive",
              "ref",
              "references",
              "referencing",
              "regr_avgx",
              "regr_avgy",
              "regr_count",
              "regr_intercept",
              "regr_r2",
              "regr_slope",
              "regr_sxx",
              "regr_sxy",
              "regr_syy",
              "release",
              "result",
              "return",
              "returns",
              "revoke",
              "right",
              "rollback",
              "rollup",
              "row",
              "row_number",
              "rows",
              "running",
              "savepoint",
              "scope",
              "scroll",
              "search",
              "second",
              "seek",
              "select",
              "sensitive",
              "session_user",
              "set",
              "show",
              "similar",
              "sin",
              "sinh",
              "skip",
              "smallint",
              "some",
              "specific",
              "specifictype",
              "sql",
              "sqlexception",
              "sqlstate",
              "sqlwarning",
              "sqrt",
              "start",
              "static",
              "stddev_pop",
              "stddev_samp",
              "submultiset",
              "subset",
              "substring",
              "substring_regex",
              "succeeds",
              "sum",
              "symmetric",
              "system",
              "system_time",
              "system_user",
              "table",
              "tablesample",
              "tan",
              "tanh",
              "then",
              "time",
              "timestamp",
              "timezone_hour",
              "timezone_minute",
              "to",
              "trailing",
              "translate",
              "translate_regex",
              "translation",
              "treat",
              "trigger",
              "trim",
              "trim_array",
              "true",
              "truncate",
              "uescape",
              "union",
              "unique",
              "unknown",
              "unnest",
              "update",
              "upper",
              "user",
              "using",
              "value",
              "values",
              "value_of",
              "var_pop",
              "var_samp",
              "varbinary",
              "varchar",
              "varying",
              "versioning",
              "when",
              "whenever",
              "where",
              "width_bucket",
              "window",
              "with",
              "within",
              "without",
              "year",
              "add",
              "asc",
              "collation",
              "desc",
              "final",
              "first",
              "last",
              "view",
            ].filter((I) => !d.includes(I)),
            _ = {
              match: t.concat(/\b/, t.either(...y), /\s*\(/),
              relevance: 0,
              keywords: { built_in: y },
            };
          function p(I) {
            return t.concat(
              /\b/,
              t.either(...I.map((q) => q.replace(/\s+/, "\\s+"))),
              /\b/
            );
          }
          let L = {
            scope: "keyword",
            match: p([
              "create table",
              "insert into",
              "primary key",
              "foreign key",
              "not null",
              "alter table",
              "add constraint",
              "grouping sets",
              "on overflow",
              "character set",
              "respect nulls",
              "ignore nulls",
              "nulls first",
              "nulls last",
              "depth first",
              "breadth first",
            ]),
            relevance: 0,
          };
          return {
            name: "SQL",
            case_insensitive: !0,
            illegal: /[{}]|<\//,
            keywords: {
              $pattern: /\b[\w\.]+/,
              keyword: ((I, { exceptions: q, when: ae } = {}) => {
                let G = ae;
                return (
                  (q = q || []),
                  I.map((ve) =>
                    ve.match(/\|\d+$/) || q.includes(ve)
                      ? ve
                      : G(ve)
                      ? ve + "|0"
                      : ve
                  )
                );
              })(u, { when: (I) => I.length < 3 }),
              literal: ["true", "false", "unknown"],
              type: [
                "bigint",
                "binary",
                "blob",
                "boolean",
                "char",
                "character",
                "clob",
                "date",
                "dec",
                "decfloat",
                "decimal",
                "float",
                "int",
                "integer",
                "interval",
                "nchar",
                "nclob",
                "national",
                "numeric",
                "real",
                "row",
                "smallint",
                "time",
                "timestamp",
                "varchar",
                "varying",
                "varbinary",
              ],
              built_in: [
                "current_catalog",
                "current_date",
                "current_default_transform_group",
                "current_path",
                "current_role",
                "current_schema",
                "current_transform_group_for_type",
                "current_user",
                "session_user",
                "system_time",
                "system_user",
                "current_time",
                "localtime",
                "current_timestamp",
                "localtimestamp",
              ],
            },
            contains: [
              {
                scope: "type",
                match: p([
                  "double precision",
                  "large object",
                  "with timezone",
                  "without timezone",
                ]),
              },
              L,
              _,
              { scope: "variable", match: /@[a-z0-9][a-z0-9_]*/ },
              {
                scope: "string",
                variants: [
                  { begin: /'/, end: /'/, contains: [{ match: /''/ }] },
                ],
              },
              { begin: /"/, end: /"/, contains: [{ match: /""/ }] },
              e.C_NUMBER_MODE,
              e.C_BLOCK_COMMENT_MODE,
              a,
              {
                scope: "operator",
                match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
                relevance: 0,
              },
            ],
          };
        },
        grmr_swift: (e) => {
          let t = { match: /\s+/, relevance: 0 },
            a = e.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
            d = [e.C_LINE_COMMENT_MODE, a],
            y = { match: [/\./, E(...kt, ...wt)], className: { 2: "keyword" } },
            u = { match: x(/\./, E(..._t)), relevance: 0 },
            _ = _t.filter((he) => typeof he == "string").concat(["_|0"]),
            p = {
              variants: [
                {
                  className: "keyword",
                  match: E(
                    ..._t
                      .filter((he) => typeof he != "string")
                      .concat(At)
                      .map(mt),
                    ...wt
                  ),
                },
              ],
            },
            L = {
              $pattern: E(/\b\w+/, /#\w+/),
              keyword: _.concat(Ot),
              literal: Et,
            },
            I = [y, u, p],
            q = [
              { match: x(/\./, E(...xt)), relevance: 0 },
              { className: "built_in", match: x(/\b/, E(...xt), /(?=\()/) },
            ],
            ae = { match: /->/, relevance: 0 },
            G = [
              ae,
              {
                className: "operator",
                relevance: 0,
                variants: [{ match: Bt }, { match: `\\.(\\.|${gt})+` }],
              },
            ],
            ve = "([0-9]_*)+",
            xe = "([0-9a-fA-F]_*)+",
            Se = {
              className: "number",
              relevance: 0,
              variants: [
                { match: `\\b(${ve})(\\.(${ve}))?([eE][+-]?(${ve}))?\\b` },
                { match: `\\b0x(${xe})(\\.(${xe}))?([pP][+-]?(${ve}))?\\b` },
                { match: /\b0o([0-7]_*)+\b/ },
                { match: /\b0b([01]_*)+\b/ },
              ],
            },
            je = (he = "") => ({
              className: "subst",
              variants: [
                { match: x(/\\/, he, /[0\\tnr"']/) },
                { match: x(/\\/, he, /u\{[0-9a-fA-F]{1,8}\}/) },
              ],
            }),
            et = (he = "") => ({
              className: "subst",
              match: x(/\\/, he, /[\t ]*(?:[\r\n]|\r\n)/),
            }),
            Xe = (he = "") => ({
              className: "subst",
              label: "interpol",
              begin: x(/\\/, he, /\(/),
              end: /\)/,
            }),
            z = (he = "") => ({
              begin: x(he, /"""/),
              end: x(/"""/, he),
              contains: [je(he), et(he), Xe(he)],
            }),
            Y = (he = "") => ({
              begin: x(he, /"/),
              end: x(/"/, he),
              contains: [je(he), Xe(he)],
            }),
            pe = {
              className: "string",
              variants: [
                z(),
                z("#"),
                z("##"),
                z("###"),
                Y(),
                Y("#"),
                Y("##"),
                Y("###"),
              ],
            },
            Ke = [
              e.BACKSLASH_ESCAPE,
              {
                begin: /\[/,
                end: /\]/,
                relevance: 0,
                contains: [e.BACKSLASH_ESCAPE],
              },
            ],
            Pe = { begin: /\/[^\s](?=[^/\n]*\/)/, end: /\//, contains: Ke },
            Fe = (he) => {
              let Re = x(he, /\//),
                lt = x(/\//, he);
              return {
                begin: Re,
                end: lt,
                contains: [
                  ...Ke,
                  { scope: "comment", begin: `#(?!.*${lt})`, end: /$/ },
                ],
              };
            },
            Me = {
              scope: "regexp",
              variants: [Fe("###"), Fe("##"), Fe("#"), Pe],
            },
            Te = { match: x(/`/, st, /`/) },
            Oe = [
              Te,
              { className: "variable", match: /\$\d+/ },
              { className: "variable", match: `\\$${Lt}+` },
            ],
            Ve = [
              {
                match: /(@|#(un)?)available/,
                scope: "keyword",
                starts: {
                  contains: [
                    {
                      begin: /\(/,
                      end: /\)/,
                      keywords: en,
                      contains: [...G, Se, pe],
                    },
                  ],
                },
              },
              { scope: "keyword", match: x(/@/, E(...Jt), f(E(/\(/, /\s+/))) },
              { scope: "meta", match: x(/@/, st) },
            ],
            nt = {
              match: f(/\b[A-Z]/),
              relevance: 0,
              contains: [
                {
                  className: "type",
                  match: x(
                    /(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/,
                    Lt,
                    "+"
                  ),
                },
                { className: "type", match: Mt, relevance: 0 },
                { match: /[?!]+/, relevance: 0 },
                { match: /\.\.\./, relevance: 0 },
                { match: x(/\s+&\s+/, f(Mt)), relevance: 0 },
              ],
            },
            bt = {
              begin: /</,
              end: />/,
              keywords: L,
              contains: [...d, ...I, ...Ve, ae, nt],
            };
          nt.contains.push(bt);
          let pt = {
              begin: /\(/,
              end: /\)/,
              relevance: 0,
              keywords: L,
              contains: [
                "self",
                { match: x(st, /\s*:/), keywords: "_|0", relevance: 0 },
                ...d,
                Me,
                ...I,
                ...q,
                ...G,
                Se,
                pe,
                ...Oe,
                ...Ve,
                nt,
              ],
            },
            at = {
              begin: /</,
              end: />/,
              keywords: "repeat each",
              contains: [...d, nt],
            },
            ft = {
              begin: /\(/,
              end: /\)/,
              keywords: L,
              contains: [
                {
                  begin: E(f(x(st, /\s*:/)), f(x(st, /\s+/, st, /\s*:/))),
                  end: /:/,
                  relevance: 0,
                  contains: [
                    { className: "keyword", match: /\b_\b/ },
                    { className: "params", match: st },
                  ],
                },
                ...d,
                ...I,
                ...G,
                Se,
                pe,
                ...Ve,
                nt,
                pt,
              ],
              endsParent: !0,
              illegal: /["']/,
            },
            tt = {
              match: [/(func|macro)/, /\s+/, E(Te.match, st, Bt)],
              className: { 1: "keyword", 3: "title.function" },
              contains: [at, ft, t],
              illegal: [/\[/, /%/],
            },
            St = {
              match: [/\b(?:subscript|init[?!]?)/, /\s*(?=[<(])/],
              className: { 1: "keyword" },
              contains: [at, ft, t],
              illegal: /\[|%/,
            },
            ht = {
              match: [/operator/, /\s+/, Bt],
              className: { 1: "keyword", 3: "title" },
            },
            fe = {
              begin: [/precedencegroup/, /\s+/, Mt],
              className: { 1: "keyword", 3: "title" },
              contains: [nt],
              keywords: [...Ct, ...Et],
              end: /}/,
            },
            Tt = {
              begin: [
                /(struct|protocol|class|extension|enum|actor)/,
                /\s+/,
                st,
                /\s*/,
              ],
              beginScope: { 1: "keyword", 3: "title.class" },
              keywords: L,
              contains: [
                at,
                ...I,
                {
                  begin: /:/,
                  end: /\{/,
                  keywords: L,
                  contains: [
                    { scope: "title.class.inherited", match: Mt },
                    ...I,
                  ],
                  relevance: 0,
                },
              ],
            };
          for (let he of pe.variants) {
            let Re = he.contains.find((ct) => ct.label === "interpol");
            Re.keywords = L;
            let lt = [...I, ...q, ...G, Se, pe, ...Oe];
            Re.contains = [
              ...lt,
              { begin: /\(/, end: /\)/, contains: ["self", ...lt] },
            ];
          }
          return {
            name: "Swift",
            keywords: L,
            contains: [
              ...d,
              tt,
              St,
              {
                match: [
                  /class\b/,
                  /\s+/,
                  /func\b/,
                  /\s+/,
                  /\b[A-Za-z_][A-Za-z0-9_]*\b/,
                ],
                scope: { 1: "keyword", 3: "keyword", 5: "title.function" },
              },
              {
                match: [/class\b/, /\s+/, /var\b/],
                scope: { 1: "keyword", 3: "keyword" },
              },
              Tt,
              ht,
              fe,
              {
                beginKeywords: "import",
                end: /$/,
                contains: [...d],
                relevance: 0,
              },
              Me,
              ...I,
              ...q,
              ...G,
              Se,
              pe,
              ...Oe,
              ...Ve,
              nt,
              pt,
            ],
          };
        },
        grmr_typescript: (e) => {
          let t = e.regex,
            a = yt(e),
            d = He,
            y = [
              "any",
              "void",
              "number",
              "boolean",
              "string",
              "object",
              "never",
              "symbol",
              "bigint",
              "unknown",
            ],
            u = {
              begin: [/namespace/, /\s+/, e.IDENT_RE],
              beginScope: { 1: "keyword", 3: "title.class" },
            },
            _ = {
              beginKeywords: "interface",
              end: /\{/,
              excludeEnd: !0,
              keywords: { keyword: "interface extends", built_in: y },
              contains: [a.exports.CLASS_REFERENCE],
            },
            p = {
              $pattern: He,
              keyword: De.concat([
                "type",
                "interface",
                "public",
                "private",
                "protected",
                "implements",
                "declare",
                "abstract",
                "readonly",
                "enum",
                "override",
                "satisfies",
              ]),
              literal: Ye,
              built_in: ot.concat(y),
              "variable.language": vt,
            },
            L = { className: "meta", begin: "@" + d },
            I = (G, ve, xe) => {
              let Se = G.contains.findIndex((je) => je.label === ve);
              if (Se === -1) throw Error("can not find mode to replace");
              G.contains.splice(Se, 1, xe);
            };
          Object.assign(a.keywords, p), a.exports.PARAMS_CONTAINS.push(L);
          let q = a.contains.find((G) => G.scope === "attr"),
            ae = Object.assign({}, q, {
              match: t.concat(d, t.lookahead(/\s*\?:/)),
            });
          return (
            a.exports.PARAMS_CONTAINS.push([a.exports.CLASS_REFERENCE, q, ae]),
            (a.contains = a.contains.concat([L, u, _, ae])),
            I(a, "shebang", e.SHEBANG()),
            I(a, "use_strict", {
              className: "meta",
              relevance: 10,
              begin: /^\s*['"]use strict['"]/,
            }),
            (a.contains.find((G) => G.label === "func.def").relevance = 0),
            Object.assign(a, {
              name: "TypeScript",
              aliases: ["ts", "tsx", "mts", "cts"],
            }),
            a
          );
        },
        grmr_vbnet: (e) => {
          let t = e.regex,
            a = /\d{1,2}\/\d{1,2}\/\d{4}/,
            d = /\d{4}-\d{1,2}-\d{1,2}/,
            y = /(\d|1[012])(:\d+){0,2} *(AM|PM)/,
            u = /\d{1,2}(:\d{1,2}){1,2}/,
            _ = {
              className: "literal",
              variants: [
                { begin: t.concat(/# */, t.either(d, a), / *#/) },
                { begin: t.concat(/# */, u, / *#/) },
                { begin: t.concat(/# */, y, / *#/) },
                {
                  begin: t.concat(
                    /# */,
                    t.either(d, a),
                    / +/,
                    t.either(y, u),
                    / *#/
                  ),
                },
              ],
            },
            p = e.COMMENT(/'''/, /$/, {
              contains: [{ className: "doctag", begin: /<\/?/, end: />/ }],
            }),
            L = e.COMMENT(null, /$/, {
              variants: [{ begin: /'/ }, { begin: /([\t ]|^)REM(?=\s)/ }],
            });
          return {
            name: "Visual Basic .NET",
            aliases: ["vb"],
            case_insensitive: !0,
            classNameAliases: { label: "symbol" },
            keywords: {
              keyword:
                "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
              built_in:
                "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort",
              type: "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort",
              literal: "true false nothing",
            },
            illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
            contains: [
              { className: "string", begin: /"(""|[^/n])"C\b/ },
              {
                className: "string",
                begin: /"/,
                end: /"/,
                illegal: /\n/,
                contains: [{ begin: /""/ }],
              },
              _,
              {
                className: "number",
                relevance: 0,
                variants: [
                  {
                    begin:
                      /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/,
                  },
                  { begin: /\b\d[\d_]*((U?[SIL])|[%&])?/ },
                  { begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/ },
                  { begin: /&O[0-7_]+((U?[SIL])|[%&])?/ },
                  { begin: /&B[01_]+((U?[SIL])|[%&])?/ },
                ],
              },
              { className: "label", begin: /^\w+:/ },
              p,
              L,
              {
                className: "meta",
                begin:
                  /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
                end: /$/,
                keywords: {
                  keyword:
                    "const disable else elseif enable end externalsource if region then",
                },
                contains: [L],
              },
            ],
          };
        },
        grmr_wasm: (e) => {
          e.regex;
          let t = e.COMMENT(/\(;/, /;\)/);
          return (
            t.contains.push("self"),
            {
              name: "WebAssembly",
              keywords: {
                $pattern: /[\w.]+/,
                keyword: [
                  "anyfunc",
                  "block",
                  "br",
                  "br_if",
                  "br_table",
                  "call",
                  "call_indirect",
                  "data",
                  "drop",
                  "elem",
                  "else",
                  "end",
                  "export",
                  "func",
                  "global.get",
                  "global.set",
                  "local.get",
                  "local.set",
                  "local.tee",
                  "get_global",
                  "get_local",
                  "global",
                  "if",
                  "import",
                  "local",
                  "loop",
                  "memory",
                  "memory.grow",
                  "memory.size",
                  "module",
                  "mut",
                  "nop",
                  "offset",
                  "param",
                  "result",
                  "return",
                  "select",
                  "set_global",
                  "set_local",
                  "start",
                  "table",
                  "tee_local",
                  "then",
                  "type",
                  "unreachable",
                ],
              },
              contains: [
                e.COMMENT(/;;/, /$/),
                t,
                {
                  match: [/(?:offset|align)/, /\s*/, /=/],
                  className: { 1: "keyword", 3: "operator" },
                },
                { className: "variable", begin: /\$[\w_]+/ },
                {
                  match: /(\((?!;)|\))+/,
                  className: "punctuation",
                  relevance: 0,
                },
                {
                  begin: [/(?:func|call|call_indirect)/, /\s+/, /\$[^\s)]+/],
                  className: { 1: "keyword", 3: "title.function" },
                },
                e.QUOTE_STRING_MODE,
                { match: /(i32|i64|f32|f64)(?!\.)/, className: "type" },
                {
                  className: "keyword",
                  match:
                    /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/,
                },
                {
                  className: "number",
                  relevance: 0,
                  match:
                    /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
                },
              ],
            }
          );
        },
        grmr_xml: (e) => {
          let t = e.regex,
            a = t.concat(
              /[\p{L}_]/u,
              t.optional(/[\p{L}0-9_.-]*:/u),
              /[\p{L}0-9_.-]*/u
            ),
            d = {
              className: "symbol",
              begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/,
            },
            y = {
              begin: /\s/,
              contains: [
                {
                  className: "keyword",
                  begin: /#?[a-z_][a-z1-9_-]+/,
                  illegal: /\n/,
                },
              ],
            },
            u = e.inherit(y, { begin: /\(/, end: /\)/ }),
            _ = e.inherit(e.APOS_STRING_MODE, { className: "string" }),
            p = e.inherit(e.QUOTE_STRING_MODE, { className: "string" }),
            L = {
              endsWithParent: !0,
              illegal: /</,
              relevance: 0,
              contains: [
                { className: "attr", begin: /[\p{L}0-9._:-]+/u, relevance: 0 },
                {
                  begin: /=\s*/,
                  relevance: 0,
                  contains: [
                    {
                      className: "string",
                      endsParent: !0,
                      variants: [
                        { begin: /"/, end: /"/, contains: [d] },
                        { begin: /'/, end: /'/, contains: [d] },
                        { begin: /[^\s"'=<>`]+/ },
                      ],
                    },
                  ],
                },
              ],
            };
          return {
            name: "HTML, XML",
            aliases: [
              "html",
              "xhtml",
              "rss",
              "atom",
              "xjb",
              "xsd",
              "xsl",
              "plist",
              "wsf",
              "svg",
            ],
            case_insensitive: !0,
            unicodeRegex: !0,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                relevance: 10,
                contains: [
                  y,
                  p,
                  _,
                  u,
                  {
                    begin: /\[/,
                    end: /\]/,
                    contains: [
                      {
                        className: "meta",
                        begin: /<![a-z]/,
                        end: />/,
                        contains: [y, u, p, _],
                      },
                    ],
                  },
                ],
              },
              e.COMMENT(/<!--/, /-->/, { relevance: 10 }),
              { begin: /<!\[CDATA\[/, end: /\]\]>/, relevance: 10 },
              d,
              {
                className: "meta",
                end: /\?>/,
                variants: [
                  { begin: /<\?xml/, relevance: 10, contains: [p] },
                  { begin: /<\?[a-z][a-z0-9]+/ },
                ],
              },
              {
                className: "tag",
                begin: /<style(?=\s|>)/,
                end: />/,
                keywords: { name: "style" },
                contains: [L],
                starts: {
                  end: /<\/style>/,
                  returnEnd: !0,
                  subLanguage: ["css", "xml"],
                },
              },
              {
                className: "tag",
                begin: /<script(?=\s|>)/,
                end: />/,
                keywords: { name: "script" },
                contains: [L],
                starts: {
                  end: /<\/script>/,
                  returnEnd: !0,
                  subLanguage: ["javascript", "handlebars", "xml"],
                },
              },
              { className: "tag", begin: /<>|<\/>/ },
              {
                className: "tag",
                begin: t.concat(
                  /</,
                  t.lookahead(t.concat(a, t.either(/\/>/, />/, /\s/)))
                ),
                end: /\/?>/,
                contains: [
                  { className: "name", begin: a, relevance: 0, starts: L },
                ],
              },
              {
                className: "tag",
                begin: t.concat(/<\//, t.lookahead(t.concat(a, />/))),
                contains: [
                  { className: "name", begin: a, relevance: 0 },
                  { begin: />/, relevance: 0, endsParent: !0 },
                ],
              },
            ],
          };
        },
        grmr_yaml: (e) => {
          let t = "true false yes no null",
            a = "[\\w#;/?:@&=+$,.~*'()[\\]]+",
            d = {
              className: "string",
              relevance: 0,
              variants: [{ begin: /"/, end: /"/ }, { begin: /\S+/ }],
              contains: [
                e.BACKSLASH_ESCAPE,
                {
                  className: "template-variable",
                  variants: [
                    { begin: /\{\{/, end: /\}\}/ },
                    { begin: /%\{/, end: /\}/ },
                  ],
                },
              ],
            },
            y = e.inherit(d, {
              variants: [
                {
                  begin: /'/,
                  end: /'/,
                  contains: [{ begin: /''/, relevance: 0 }],
                },
                { begin: /"/, end: /"/ },
                { begin: /[^\s,{}[\]]+/ },
              ],
            }),
            u = {
              end: ",",
              endsWithParent: !0,
              excludeEnd: !0,
              keywords: t,
              relevance: 0,
            },
            _ = {
              begin: /\{/,
              end: /\}/,
              contains: [u],
              illegal: "\\n",
              relevance: 0,
            },
            p = {
              begin: "\\[",
              end: "\\]",
              contains: [u],
              illegal: "\\n",
              relevance: 0,
            },
            L = [
              {
                className: "attr",
                variants: [
                  { begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
                  { begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/ },
                  { begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/ },
                ],
              },
              { className: "meta", begin: "^---\\s*$", relevance: 10 },
              {
                className: "string",
                begin:
                  "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*",
              },
              {
                begin: "<%[%=-]?",
                end: "[%-]?%>",
                subLanguage: "ruby",
                excludeBegin: !0,
                excludeEnd: !0,
                relevance: 0,
              },
              { className: "type", begin: "!\\w+!" + a },
              { className: "type", begin: "!<" + a + ">" },
              { className: "type", begin: "!" + a },
              { className: "type", begin: "!!" + a },
              { className: "meta", begin: "&" + e.UNDERSCORE_IDENT_RE + "$" },
              { className: "meta", begin: "\\*" + e.UNDERSCORE_IDENT_RE + "$" },
              { className: "bullet", begin: "-(?=[ ]|$)", relevance: 0 },
              e.HASH_COMMENT_MODE,
              { beginKeywords: t, keywords: { literal: t } },
              {
                className: "number",
                begin:
                  "\\b[0-9]{4}(-[0-9][0-9]){0,2}([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?(\\.[0-9]*)?([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\\b",
              },
              {
                className: "number",
                begin: e.C_NUMBER_RE + "\\b",
                relevance: 0,
              },
              _,
              p,
              {
                className: "string",
                relevance: 0,
                begin: /'/,
                end: /'/,
                contains: [{ match: /''/, scope: "char.escape", relevance: 0 }],
              },
              d,
            ],
            I = [...L];
          return (
            I.pop(),
            I.push(y),
            (u.contains = I),
            {
              name: "YAML",
              case_insensitive: !0,
              aliases: ["yml"],
              contains: L,
            }
          );
        },
      });
      let Gt = O;
      for (let e of Object.keys(Kt)) {
        let t = e.replace("grmr_", "").replace("_", "-");
        Gt.registerLanguage(t, Kt[e]);
      }
      return Gt;
    })();
    typeof Wt == "object" && typeof Ut < "u" && (Ut.exports = hljs);
  });
  var Ht = $t((Dt, Xt) => {
    (function (N, S) {
      typeof Dt == "object" && typeof Xt < "u"
        ? S(Dt)
        : typeof define == "function" && define.amd
        ? define(["exports"], S)
        : S(
            ((N =
              typeof globalThis < "u" ? globalThis : N || self).FloatingUICore =
              {})
          );
    })(Dt, function (N) {
      "use strict";
      let S = ["top", "right", "bottom", "left"],
        P = ["start", "end"],
        i = S.reduce((b, A) => b.concat(A, A + "-" + P[0], A + "-" + P[1]), []),
        n = Math.min,
        r = Math.max,
        o = { left: "right", right: "left", bottom: "top", top: "bottom" },
        m = { start: "end", end: "start" };
      function C(b, A, Z) {
        return r(b, n(A, Z));
      }
      function s(b, A) {
        return typeof b == "function" ? b(A) : b;
      }
      function f(b) {
        return b.split("-")[0];
      }
      function g(b) {
        return b.split("-")[1];
      }
      function v(b) {
        return b === "x" ? "y" : "x";
      }
      function x(b) {
        return b === "y" ? "height" : "width";
      }
      function E(b) {
        return ["top", "bottom"].includes(f(b)) ? "y" : "x";
      }
      function W(b) {
        return v(E(b));
      }
      function R(b, A, Z) {
        Z === void 0 && (Z = !1);
        let $ = g(b),
          U = W(b),
          F = x(U),
          Q =
            U === "x"
              ? $ === (Z ? "end" : "start")
                ? "right"
                : "left"
              : $ === "start"
              ? "bottom"
              : "top";
        return A.reference[F] > A.floating[F] && (Q = w(Q)), [Q, w(Q)];
      }
      function c(b) {
        return b.replace(/start|end/g, (A) => m[A]);
      }
      function w(b) {
        return b.replace(/left|right|bottom|top/g, (A) => o[A]);
      }
      function k(b) {
        return typeof b != "number"
          ? (function (A) {
              return { top: 0, right: 0, bottom: 0, left: 0, ...A };
            })(b)
          : { top: b, right: b, bottom: b, left: b };
      }
      function B(b) {
        let { x: A, y: Z, width: $, height: U } = b;
        return {
          width: $,
          height: U,
          top: Z,
          left: A,
          right: A + $,
          bottom: Z + U,
          x: A,
          y: Z,
        };
      }
      function T(b, A, Z) {
        let { reference: $, floating: U } = b,
          F = E(A),
          Q = W(A),
          de = x(Q),
          ke = f(A),
          Ae = F === "y",
          se = $.x + $.width / 2 - U.width / 2,
          X = $.y + $.height / 2 - U.height / 2,
          le = $[de] / 2 - U[de] / 2,
          J;
        switch (ke) {
          case "top":
            J = { x: se, y: $.y - U.height };
            break;
          case "bottom":
            J = { x: se, y: $.y + $.height };
            break;
          case "right":
            J = { x: $.x + $.width, y: X };
            break;
          case "left":
            J = { x: $.x - U.width, y: X };
            break;
          default:
            J = { x: $.x, y: $.y };
        }
        switch (g(A)) {
          case "start":
            J[Q] -= le * (Z && Ae ? -1 : 1);
            break;
          case "end":
            J[Q] += le * (Z && Ae ? -1 : 1);
        }
        return J;
      }
      async function V(b, A) {
        var Z;
        A === void 0 && (A = {});
        let {
            x: $,
            y: U,
            platform: F,
            rects: Q,
            elements: de,
            strategy: ke,
          } = b,
          {
            boundary: Ae = "clippingAncestors",
            rootBoundary: se = "viewport",
            elementContext: X = "floating",
            altBoundary: le = !1,
            padding: J = 0,
          } = s(A, b),
          re = k(J),
          oe = de[le ? (X === "floating" ? "reference" : "floating") : X],
          ie = B(
            await F.getClippingRect({
              element:
                (Z = await (F.isElement == null ? void 0 : F.isElement(oe))) ==
                  null || Z
                  ? oe
                  : oe.contextElement ||
                    (await (F.getDocumentElement == null
                      ? void 0
                      : F.getDocumentElement(de.floating))),
              boundary: Ae,
              rootBoundary: se,
              strategy: ke,
            })
          ),
          we =
            X === "floating"
              ? {
                  x: $,
                  y: U,
                  width: Q.floating.width,
                  height: Q.floating.height,
                }
              : Q.reference,
          ue = await (F.getOffsetParent == null
            ? void 0
            : F.getOffsetParent(de.floating)),
          me = ((await (F.isElement == null ? void 0 : F.isElement(ue))) &&
            (await (F.getScale == null ? void 0 : F.getScale(ue)))) || {
            x: 1,
            y: 1,
          },
          be = B(
            F.convertOffsetParentRelativeRectToViewportRelativeRect
              ? await F.convertOffsetParentRelativeRectToViewportRelativeRect({
                  elements: de,
                  rect: we,
                  offsetParent: ue,
                  strategy: ke,
                })
              : we
          );
        return {
          top: (ie.top - be.top + re.top) / me.y,
          bottom: (be.bottom - ie.bottom + re.bottom) / me.y,
          left: (ie.left - be.left + re.left) / me.x,
          right: (be.right - ie.right + re.right) / me.x,
        };
      }
      function ye(b, A) {
        return {
          top: b.top - A.height,
          right: b.right - A.width,
          bottom: b.bottom - A.height,
          left: b.left - A.width,
        };
      }
      function Ne(b) {
        return S.some((A) => b[A] >= 0);
      }
      function ge(b) {
        let A = n(...b.map(($) => $.left)),
          Z = n(...b.map(($) => $.top));
        return {
          x: A,
          y: Z,
          width: r(...b.map(($) => $.right)) - A,
          height: r(...b.map(($) => $.bottom)) - Z,
        };
      }
      (N.arrow = (b) => ({
        name: "arrow",
        options: b,
        async fn(A) {
          let {
              x: Z,
              y: $,
              placement: U,
              rects: F,
              platform: Q,
              elements: de,
              middlewareData: ke,
            } = A,
            { element: Ae, padding: se = 0 } = s(b, A) || {};
          if (Ae == null) return {};
          let X = k(se),
            le = { x: Z, y: $ },
            J = W(U),
            re = x(J),
            oe = await Q.getDimensions(Ae),
            ie = J === "y",
            we = ie ? "top" : "left",
            ue = ie ? "bottom" : "right",
            me = ie ? "clientHeight" : "clientWidth",
            be = F.reference[re] + F.reference[J] - le[J] - F.floating[re],
            _e = le[J] - F.reference[J],
            qe = await (Q.getOffsetParent == null
              ? void 0
              : Q.getOffsetParent(Ae)),
            Ue = qe ? qe[me] : 0;
          (Ue && (await (Q.isElement == null ? void 0 : Q.isElement(qe)))) ||
            (Ue = de.floating[me] || F.floating[re]);
          let Qe = be / 2 - _e / 2,
            Ce = Ue / 2 - oe[re] / 2 - 1,
            Be = n(X[we], Ce),
            l = n(X[ue], Ce),
            h = Be,
            O = Ue - oe[re] - l,
            M = Ue / 2 - oe[re] / 2 + Qe,
            D = C(h, M, O),
            H =
              !ke.arrow &&
              g(U) != null &&
              M !== D &&
              F.reference[re] / 2 - (M < h ? Be : l) - oe[re] / 2 < 0,
            ee = H ? (M < h ? M - h : M - O) : 0;
          return {
            [J]: le[J] + ee,
            data: {
              [J]: D,
              centerOffset: M - D - ee,
              ...(H && { alignmentOffset: ee }),
            },
            reset: H,
          };
        },
      })),
        (N.autoPlacement = function (b) {
          return (
            b === void 0 && (b = {}),
            {
              name: "autoPlacement",
              options: b,
              async fn(A) {
                var Z, $, U;
                let {
                    rects: F,
                    middlewareData: Q,
                    placement: de,
                    platform: ke,
                    elements: Ae,
                  } = A,
                  {
                    crossAxis: se = !1,
                    alignment: X,
                    allowedPlacements: le = i,
                    autoAlignment: J = !0,
                    ...re
                  } = s(b, A),
                  oe =
                    X !== void 0 || le === i
                      ? (function (Ce, Be, l) {
                          return (
                            Ce
                              ? [
                                  ...l.filter((h) => g(h) === Ce),
                                  ...l.filter((h) => g(h) !== Ce),
                                ]
                              : l.filter((h) => f(h) === h)
                          ).filter(
                            (h) => !Ce || g(h) === Ce || (!!Be && c(h) !== h)
                          );
                        })(X || null, J, le)
                      : le,
                  ie = await V(A, re),
                  we = ((Z = Q.autoPlacement) == null ? void 0 : Z.index) || 0,
                  ue = oe[we];
                if (ue == null) return {};
                let me = R(
                  ue,
                  F,
                  await (ke.isRTL == null ? void 0 : ke.isRTL(Ae.floating))
                );
                if (de !== ue) return { reset: { placement: oe[0] } };
                let be = [ie[f(ue)], ie[me[0]], ie[me[1]]],
                  _e = [
                    ...((($ = Q.autoPlacement) == null
                      ? void 0
                      : $.overflows) || []),
                    { placement: ue, overflows: be },
                  ],
                  qe = oe[we + 1];
                if (qe)
                  return {
                    data: { index: we + 1, overflows: _e },
                    reset: { placement: qe },
                  };
                let Ue = _e
                    .map((Ce) => {
                      let Be = g(Ce.placement);
                      return [
                        Ce.placement,
                        Be && se
                          ? Ce.overflows.slice(0, 2).reduce((l, h) => l + h, 0)
                          : Ce.overflows[0],
                        Ce.overflows,
                      ];
                    })
                    .sort((Ce, Be) => Ce[1] - Be[1]),
                  Qe =
                    ((U = Ue.filter((Ce) =>
                      Ce[2].slice(0, g(Ce[0]) ? 2 : 3).every((Be) => Be <= 0)
                    )[0]) == null
                      ? void 0
                      : U[0]) || Ue[0][0];
                return Qe !== de
                  ? {
                      data: { index: we + 1, overflows: _e },
                      reset: { placement: Qe },
                    }
                  : {};
              },
            }
          );
        }),
        (N.computePosition = async (b, A, Z) => {
          let {
              placement: $ = "bottom",
              strategy: U = "absolute",
              middleware: F = [],
              platform: Q,
            } = Z,
            de = F.filter(Boolean),
            ke = await (Q.isRTL == null ? void 0 : Q.isRTL(A)),
            Ae = await Q.getElementRects({
              reference: b,
              floating: A,
              strategy: U,
            }),
            { x: se, y: X } = T(Ae, $, ke),
            le = $,
            J = {},
            re = 0;
          for (let oe = 0; oe < de.length; oe++) {
            let { name: ie, fn: we } = de[oe],
              {
                x: ue,
                y: me,
                data: be,
                reset: _e,
              } = await we({
                x: se,
                y: X,
                initialPlacement: $,
                placement: le,
                strategy: U,
                middlewareData: J,
                rects: Ae,
                platform: Q,
                elements: { reference: b, floating: A },
              });
            (se = ue ?? se),
              (X = me ?? X),
              (J = { ...J, [ie]: { ...J[ie], ...be } }),
              _e &&
                re <= 50 &&
                (re++,
                typeof _e == "object" &&
                  (_e.placement && (le = _e.placement),
                  _e.rects &&
                    (Ae =
                      _e.rects === !0
                        ? await Q.getElementRects({
                            reference: b,
                            floating: A,
                            strategy: U,
                          })
                        : _e.rects),
                  ({ x: se, y: X } = T(Ae, le, ke))),
                (oe = -1));
          }
          return { x: se, y: X, placement: le, strategy: U, middlewareData: J };
        }),
        (N.detectOverflow = V),
        (N.flip = function (b) {
          return (
            b === void 0 && (b = {}),
            {
              name: "flip",
              options: b,
              async fn(A) {
                var Z, $;
                let {
                    placement: U,
                    middlewareData: F,
                    rects: Q,
                    initialPlacement: de,
                    platform: ke,
                    elements: Ae,
                  } = A,
                  {
                    mainAxis: se = !0,
                    crossAxis: X = !0,
                    fallbackPlacements: le,
                    fallbackStrategy: J = "bestFit",
                    fallbackAxisSideDirection: re = "none",
                    flipAlignment: oe = !0,
                    ...ie
                  } = s(b, A);
                if ((Z = F.arrow) != null && Z.alignmentOffset) return {};
                let we = f(U),
                  ue = E(de),
                  me = f(de) === de,
                  be = await (ke.isRTL == null
                    ? void 0
                    : ke.isRTL(Ae.floating)),
                  _e =
                    le ||
                    (me || !oe
                      ? [w(de)]
                      : (function (D) {
                          let H = w(D);
                          return [c(D), H, c(H)];
                        })(de)),
                  qe = re !== "none";
                !le &&
                  qe &&
                  _e.push(
                    ...(function (D, H, ee, te) {
                      let j = g(D),
                        ne = (function (Ee, Ie, Ge) {
                          let Ze = ["left", "right"],
                            Le = ["right", "left"],
                            He = ["top", "bottom"],
                            De = ["bottom", "top"];
                          switch (Ee) {
                            case "top":
                            case "bottom":
                              return Ge ? (Ie ? Le : Ze) : Ie ? Ze : Le;
                            case "left":
                            case "right":
                              return Ie ? He : De;
                            default:
                              return [];
                          }
                        })(f(D), ee === "start", te);
                      return (
                        j &&
                          ((ne = ne.map((Ee) => Ee + "-" + j)),
                          H && (ne = ne.concat(ne.map(c)))),
                        ne
                      );
                    })(de, oe, re, be)
                  );
                let Ue = [de, ..._e],
                  Qe = await V(A, ie),
                  Ce = [],
                  Be = (($ = F.flip) == null ? void 0 : $.overflows) || [];
                if ((se && Ce.push(Qe[we]), X)) {
                  let D = R(U, Q, be);
                  Ce.push(Qe[D[0]], Qe[D[1]]);
                }
                if (
                  ((Be = [...Be, { placement: U, overflows: Ce }]),
                  !Ce.every((D) => D <= 0))
                ) {
                  var l, h;
                  let D = (((l = F.flip) == null ? void 0 : l.index) || 0) + 1,
                    H = Ue[D];
                  if (H) {
                    var O;
                    let te = X === "alignment" && ue !== E(H),
                      j = ((O = Be[0]) == null ? void 0 : O.overflows[0]) > 0;
                    if (!te || j)
                      return {
                        data: { index: D, overflows: Be },
                        reset: { placement: H },
                      };
                  }
                  let ee =
                    (h = Be.filter((te) => te.overflows[0] <= 0).sort(
                      (te, j) => te.overflows[1] - j.overflows[1]
                    )[0]) == null
                      ? void 0
                      : h.placement;
                  if (!ee)
                    switch (J) {
                      case "bestFit": {
                        var M;
                        let te =
                          (M = Be.filter((j) => {
                            if (qe) {
                              let ne = E(j.placement);
                              return ne === ue || ne === "y";
                            }
                            return !0;
                          })
                            .map((j) => [
                              j.placement,
                              j.overflows
                                .filter((ne) => ne > 0)
                                .reduce((ne, Ee) => ne + Ee, 0),
                            ])
                            .sort((j, ne) => j[1] - ne[1])[0]) == null
                            ? void 0
                            : M[0];
                        te && (ee = te);
                        break;
                      }
                      case "initialPlacement":
                        ee = de;
                    }
                  if (U !== ee) return { reset: { placement: ee } };
                }
                return {};
              },
            }
          );
        }),
        (N.hide = function (b) {
          return (
            b === void 0 && (b = {}),
            {
              name: "hide",
              options: b,
              async fn(A) {
                let { rects: Z } = A,
                  { strategy: $ = "referenceHidden", ...U } = s(b, A);
                switch ($) {
                  case "referenceHidden": {
                    let F = ye(
                      await V(A, { ...U, elementContext: "reference" }),
                      Z.reference
                    );
                    return {
                      data: {
                        referenceHiddenOffsets: F,
                        referenceHidden: Ne(F),
                      },
                    };
                  }
                  case "escaped": {
                    let F = ye(
                      await V(A, { ...U, altBoundary: !0 }),
                      Z.floating
                    );
                    return { data: { escapedOffsets: F, escaped: Ne(F) } };
                  }
                  default:
                    return {};
                }
              },
            }
          );
        }),
        (N.inline = function (b) {
          return (
            b === void 0 && (b = {}),
            {
              name: "inline",
              options: b,
              async fn(A) {
                let {
                    placement: Z,
                    elements: $,
                    rects: U,
                    platform: F,
                    strategy: Q,
                  } = A,
                  { padding: de = 2, x: ke, y: Ae } = s(b, A),
                  se = Array.from(
                    (await (F.getClientRects == null
                      ? void 0
                      : F.getClientRects($.reference))) || []
                  ),
                  X = (function (oe) {
                    let ie = oe.slice().sort((me, be) => me.y - be.y),
                      we = [],
                      ue = null;
                    for (let me = 0; me < ie.length; me++) {
                      let be = ie[me];
                      !ue || be.y - ue.y > ue.height / 2
                        ? we.push([be])
                        : we[we.length - 1].push(be),
                        (ue = be);
                    }
                    return we.map((me) => B(ge(me)));
                  })(se),
                  le = B(ge(se)),
                  J = k(de),
                  re = await F.getElementRects({
                    reference: {
                      getBoundingClientRect: function () {
                        if (
                          X.length === 2 &&
                          X[0].left > X[1].right &&
                          ke != null &&
                          Ae != null
                        )
                          return (
                            X.find(
                              (oe) =>
                                ke > oe.left - J.left &&
                                ke < oe.right + J.right &&
                                Ae > oe.top - J.top &&
                                Ae < oe.bottom + J.bottom
                            ) || le
                          );
                        if (X.length >= 2) {
                          if (E(Z) === "y") {
                            let _e = X[0],
                              qe = X[X.length - 1],
                              Ue = f(Z) === "top",
                              Qe = _e.top,
                              Ce = qe.bottom,
                              Be = Ue ? _e.left : qe.left,
                              l = Ue ? _e.right : qe.right;
                            return {
                              top: Qe,
                              bottom: Ce,
                              left: Be,
                              right: l,
                              width: l - Be,
                              height: Ce - Qe,
                              x: Be,
                              y: Qe,
                            };
                          }
                          let oe = f(Z) === "left",
                            ie = r(...X.map((_e) => _e.right)),
                            we = n(...X.map((_e) => _e.left)),
                            ue = X.filter((_e) =>
                              oe ? _e.left === we : _e.right === ie
                            ),
                            me = ue[0].top,
                            be = ue[ue.length - 1].bottom;
                          return {
                            top: me,
                            bottom: be,
                            left: we,
                            right: ie,
                            width: ie - we,
                            height: be - me,
                            x: we,
                            y: me,
                          };
                        }
                        return le;
                      },
                    },
                    floating: $.floating,
                    strategy: Q,
                  });
                return U.reference.x !== re.reference.x ||
                  U.reference.y !== re.reference.y ||
                  U.reference.width !== re.reference.width ||
                  U.reference.height !== re.reference.height
                  ? { reset: { rects: re } }
                  : {};
              },
            }
          );
        }),
        (N.limitShift = function (b) {
          return (
            b === void 0 && (b = {}),
            {
              options: b,
              fn(A) {
                let {
                    x: Z,
                    y: $,
                    placement: U,
                    rects: F,
                    middlewareData: Q,
                  } = A,
                  {
                    offset: de = 0,
                    mainAxis: ke = !0,
                    crossAxis: Ae = !0,
                  } = s(b, A),
                  se = { x: Z, y: $ },
                  X = E(U),
                  le = v(X),
                  J = se[le],
                  re = se[X],
                  oe = s(de, A),
                  ie =
                    typeof oe == "number"
                      ? { mainAxis: oe, crossAxis: 0 }
                      : { mainAxis: 0, crossAxis: 0, ...oe };
                if (ke) {
                  let me = le === "y" ? "height" : "width",
                    be = F.reference[le] - F.floating[me] + ie.mainAxis,
                    _e = F.reference[le] + F.reference[me] - ie.mainAxis;
                  J < be ? (J = be) : J > _e && (J = _e);
                }
                if (Ae) {
                  var we, ue;
                  let me = le === "y" ? "width" : "height",
                    be = ["top", "left"].includes(f(U)),
                    _e =
                      F.reference[X] -
                      F.floating[me] +
                      ((be && ((we = Q.offset) == null ? void 0 : we[X])) ||
                        0) +
                      (be ? 0 : ie.crossAxis),
                    qe =
                      F.reference[X] +
                      F.reference[me] +
                      (be
                        ? 0
                        : ((ue = Q.offset) == null ? void 0 : ue[X]) || 0) -
                      (be ? ie.crossAxis : 0);
                  re < _e ? (re = _e) : re > qe && (re = qe);
                }
                return { [le]: J, [X]: re };
              },
            }
          );
        }),
        (N.offset = function (b) {
          return (
            b === void 0 && (b = 0),
            {
              name: "offset",
              options: b,
              async fn(A) {
                var Z, $;
                let { x: U, y: F, placement: Q, middlewareData: de } = A,
                  ke = await (async function (Ae, se) {
                    let { placement: X, platform: le, elements: J } = Ae,
                      re = await (le.isRTL == null
                        ? void 0
                        : le.isRTL(J.floating)),
                      oe = f(X),
                      ie = g(X),
                      we = E(X) === "y",
                      ue = ["left", "top"].includes(oe) ? -1 : 1,
                      me = re && we ? -1 : 1,
                      be = s(se, Ae),
                      {
                        mainAxis: _e,
                        crossAxis: qe,
                        alignmentAxis: Ue,
                      } = typeof be == "number"
                        ? { mainAxis: be, crossAxis: 0, alignmentAxis: null }
                        : {
                            mainAxis: be.mainAxis || 0,
                            crossAxis: be.crossAxis || 0,
                            alignmentAxis: be.alignmentAxis,
                          };
                    return (
                      ie &&
                        typeof Ue == "number" &&
                        (qe = ie === "end" ? -1 * Ue : Ue),
                      we
                        ? { x: qe * me, y: _e * ue }
                        : { x: _e * ue, y: qe * me }
                    );
                  })(A, b);
                return Q === ((Z = de.offset) == null ? void 0 : Z.placement) &&
                  ($ = de.arrow) != null &&
                  $.alignmentOffset
                  ? {}
                  : { x: U + ke.x, y: F + ke.y, data: { ...ke, placement: Q } };
              },
            }
          );
        }),
        (N.rectToClientRect = B),
        (N.shift = function (b) {
          return (
            b === void 0 && (b = {}),
            {
              name: "shift",
              options: b,
              async fn(A) {
                let { x: Z, y: $, placement: U } = A,
                  {
                    mainAxis: F = !0,
                    crossAxis: Q = !1,
                    limiter: de = {
                      fn: (ie) => {
                        let { x: we, y: ue } = ie;
                        return { x: we, y: ue };
                      },
                    },
                    ...ke
                  } = s(b, A),
                  Ae = { x: Z, y: $ },
                  se = await V(A, ke),
                  X = E(f(U)),
                  le = v(X),
                  J = Ae[le],
                  re = Ae[X];
                if (F) {
                  let ie = le === "y" ? "bottom" : "right";
                  J = C(J + se[le === "y" ? "top" : "left"], J, J - se[ie]);
                }
                if (Q) {
                  let ie = X === "y" ? "bottom" : "right";
                  re = C(re + se[X === "y" ? "top" : "left"], re, re - se[ie]);
                }
                let oe = de.fn({ ...A, [le]: J, [X]: re });
                return {
                  ...oe,
                  data: {
                    x: oe.x - Z,
                    y: oe.y - $,
                    enabled: { [le]: F, [X]: Q },
                  },
                };
              },
            }
          );
        }),
        (N.size = function (b) {
          return (
            b === void 0 && (b = {}),
            {
              name: "size",
              options: b,
              async fn(A) {
                var Z, $;
                let { placement: U, rects: F, platform: Q, elements: de } = A,
                  { apply: ke = () => {}, ...Ae } = s(b, A),
                  se = await V(A, Ae),
                  X = f(U),
                  le = g(U),
                  J = E(U) === "y",
                  { width: re, height: oe } = F.floating,
                  ie,
                  we;
                X === "top" || X === "bottom"
                  ? ((ie = X),
                    (we =
                      le ===
                      ((await (Q.isRTL == null ? void 0 : Q.isRTL(de.floating)))
                        ? "start"
                        : "end")
                        ? "left"
                        : "right"))
                  : ((we = X), (ie = le === "end" ? "top" : "bottom"));
                let ue = oe - se.top - se.bottom,
                  me = re - se.left - se.right,
                  be = n(oe - se[ie], ue),
                  _e = n(re - se[we], me),
                  qe = !A.middlewareData.shift,
                  Ue = be,
                  Qe = _e;
                if (
                  ((Z = A.middlewareData.shift) != null &&
                    Z.enabled.x &&
                    (Qe = me),
                  ($ = A.middlewareData.shift) != null &&
                    $.enabled.y &&
                    (Ue = ue),
                  qe && !le)
                ) {
                  let Be = r(se.left, 0),
                    l = r(se.right, 0),
                    h = r(se.top, 0),
                    O = r(se.bottom, 0);
                  J
                    ? (Qe =
                        re -
                        2 *
                          (Be !== 0 || l !== 0 ? Be + l : r(se.left, se.right)))
                    : (Ue =
                        oe -
                        2 *
                          (h !== 0 || O !== 0 ? h + O : r(se.top, se.bottom)));
                }
                await ke({ ...A, availableWidth: Qe, availableHeight: Ue });
                let Ce = await Q.getDimensions(de.floating);
                return re !== Ce.width || oe !== Ce.height
                  ? { reset: { rects: !0 } }
                  : {};
              },
            }
          );
        });
    });
  });
  var Yt = $t((Rt, Qt) => {
    (function (N, S) {
      typeof Rt == "object" && typeof Qt < "u"
        ? S(Rt, Ht())
        : typeof define == "function" && define.amd
        ? define(["exports", "./floatingUICore"], S)
        : S(
            ((N =
              typeof globalThis < "u" ? globalThis : N || self).FloatingUIDOM =
              {}),
            N.FloatingUICore
          );
    })(Rt, function (N, S) {
      "use strict";
      let P = Math.min,
        i = Math.max,
        n = Math.round,
        r = Math.floor,
        o = (l) => ({ x: l, y: l });
      function m() {
        return typeof window < "u";
      }
      function C(l) {
        return g(l) ? (l.nodeName || "").toLowerCase() : "#document";
      }
      function s(l) {
        var h;
        return (
          (l == null || (h = l.ownerDocument) == null
            ? void 0
            : h.defaultView) || window
        );
      }
      function f(l) {
        var h;
        return (h = (g(l) ? l.ownerDocument : l.document) || window.document) ==
          null
          ? void 0
          : h.documentElement;
      }
      function g(l) {
        return !!m() && (l instanceof Node || l instanceof s(l).Node);
      }
      function v(l) {
        return !!m() && (l instanceof Element || l instanceof s(l).Element);
      }
      function x(l) {
        return (
          !!m() && (l instanceof HTMLElement || l instanceof s(l).HTMLElement)
        );
      }
      function E(l) {
        return (
          !(!m() || typeof ShadowRoot > "u") &&
          (l instanceof ShadowRoot || l instanceof s(l).ShadowRoot)
        );
      }
      function W(l) {
        let { overflow: h, overflowX: O, overflowY: M, display: D } = T(l);
        return (
          /auto|scroll|overlay|hidden|clip/.test(h + M + O) &&
          !["inline", "contents"].includes(D)
        );
      }
      function R(l) {
        return ["table", "td", "th"].includes(C(l));
      }
      function c(l) {
        return [":popover-open", ":modal"].some((h) => {
          try {
            return l.matches(h);
          } catch {
            return !1;
          }
        });
      }
      function w(l) {
        let h = k(),
          O = v(l) ? T(l) : l;
        return (
          ["transform", "translate", "scale", "rotate", "perspective"].some(
            (M) => !!O[M] && O[M] !== "none"
          ) ||
          (!!O.containerType && O.containerType !== "normal") ||
          (!h && !!O.backdropFilter && O.backdropFilter !== "none") ||
          (!h && !!O.filter && O.filter !== "none") ||
          [
            "transform",
            "translate",
            "scale",
            "rotate",
            "perspective",
            "filter",
          ].some((M) => (O.willChange || "").includes(M)) ||
          ["paint", "layout", "strict", "content"].some((M) =>
            (O.contain || "").includes(M)
          )
        );
      }
      function k() {
        return (
          !(typeof CSS > "u" || !CSS.supports) &&
          CSS.supports("-webkit-backdrop-filter", "none")
        );
      }
      function B(l) {
        return ["html", "body", "#document"].includes(C(l));
      }
      function T(l) {
        return s(l).getComputedStyle(l);
      }
      function V(l) {
        return v(l)
          ? { scrollLeft: l.scrollLeft, scrollTop: l.scrollTop }
          : { scrollLeft: l.scrollX, scrollTop: l.scrollY };
      }
      function ye(l) {
        if (C(l) === "html") return l;
        let h = l.assignedSlot || l.parentNode || (E(l) && l.host) || f(l);
        return E(h) ? h.host : h;
      }
      function Ne(l) {
        let h = ye(l);
        return B(h)
          ? l.ownerDocument
            ? l.ownerDocument.body
            : l.body
          : x(h) && W(h)
          ? h
          : Ne(h);
      }
      function ge(l, h, O) {
        var M;
        h === void 0 && (h = []), O === void 0 && (O = !0);
        let D = Ne(l),
          H = D === ((M = l.ownerDocument) == null ? void 0 : M.body),
          ee = s(D);
        if (H) {
          let te = b(ee);
          return h.concat(
            ee,
            ee.visualViewport || [],
            W(D) ? D : [],
            te && O ? ge(te) : []
          );
        }
        return h.concat(D, ge(D, [], O));
      }
      function b(l) {
        return l.parent && Object.getPrototypeOf(l.parent)
          ? l.frameElement
          : null;
      }
      function A(l) {
        let h = T(l),
          O = parseFloat(h.width) || 0,
          M = parseFloat(h.height) || 0,
          D = x(l),
          H = D ? l.offsetWidth : O,
          ee = D ? l.offsetHeight : M,
          te = n(O) !== H || n(M) !== ee;
        return te && ((O = H), (M = ee)), { width: O, height: M, $: te };
      }
      function Z(l) {
        return v(l) ? l : l.contextElement;
      }
      function $(l) {
        let h = Z(l);
        if (!x(h)) return o(1);
        let O = h.getBoundingClientRect(),
          { width: M, height: D, $: H } = A(h),
          ee = (H ? n(O.width) : O.width) / M,
          te = (H ? n(O.height) : O.height) / D;
        return (
          (ee && Number.isFinite(ee)) || (ee = 1),
          (te && Number.isFinite(te)) || (te = 1),
          { x: ee, y: te }
        );
      }
      let U = o(0);
      function F(l) {
        let h = s(l);
        return k() && h.visualViewport
          ? { x: h.visualViewport.offsetLeft, y: h.visualViewport.offsetTop }
          : U;
      }
      function Q(l, h, O, M) {
        h === void 0 && (h = !1), O === void 0 && (O = !1);
        let D = l.getBoundingClientRect(),
          H = Z(l),
          ee = o(1);
        h && (M ? v(M) && (ee = $(M)) : (ee = $(l)));
        let te = (function (Ge, Ze, Le) {
            return (
              Ze === void 0 && (Ze = !1), !(!Le || (Ze && Le !== s(Ge))) && Ze
            );
          })(H, O, M)
            ? F(H)
            : o(0),
          j = (D.left + te.x) / ee.x,
          ne = (D.top + te.y) / ee.y,
          Ee = D.width / ee.x,
          Ie = D.height / ee.y;
        if (H) {
          let Ge = s(H),
            Ze = M && v(M) ? s(M) : M,
            Le = Ge,
            He = b(Le);
          for (; He && M && Ze !== Le; ) {
            let De = $(He),
              Ye = He.getBoundingClientRect(),
              it = T(He),
              rt =
                Ye.left + (He.clientLeft + parseFloat(it.paddingLeft)) * De.x,
              ut = Ye.top + (He.clientTop + parseFloat(it.paddingTop)) * De.y;
            (j *= De.x),
              (ne *= De.y),
              (Ee *= De.x),
              (Ie *= De.y),
              (j += rt),
              (ne += ut),
              (Le = s(He)),
              (He = b(Le));
          }
        }
        return S.rectToClientRect({ width: Ee, height: Ie, x: j, y: ne });
      }
      function de(l, h) {
        let O = V(l).scrollLeft;
        return h ? h.left + O : Q(f(l)).left + O;
      }
      function ke(l, h, O) {
        O === void 0 && (O = !1);
        let M = l.getBoundingClientRect();
        return {
          x: M.left + h.scrollLeft - (O ? 0 : de(l, M)),
          y: M.top + h.scrollTop,
        };
      }
      function Ae(l, h, O) {
        let M;
        if (h === "viewport")
          M = (function (D, H) {
            let ee = s(D),
              te = f(D),
              j = ee.visualViewport,
              ne = te.clientWidth,
              Ee = te.clientHeight,
              Ie = 0,
              Ge = 0;
            if (j) {
              (ne = j.width), (Ee = j.height);
              let Ze = k();
              (!Ze || (Ze && H === "fixed")) &&
                ((Ie = j.offsetLeft), (Ge = j.offsetTop));
            }
            return { width: ne, height: Ee, x: Ie, y: Ge };
          })(l, O);
        else if (h === "document")
          M = (function (D) {
            let H = f(D),
              ee = V(D),
              te = D.ownerDocument.body,
              j = i(
                H.scrollWidth,
                H.clientWidth,
                te.scrollWidth,
                te.clientWidth
              ),
              ne = i(
                H.scrollHeight,
                H.clientHeight,
                te.scrollHeight,
                te.clientHeight
              ),
              Ee = -ee.scrollLeft + de(D),
              Ie = -ee.scrollTop;
            return (
              T(te).direction === "rtl" &&
                (Ee += i(H.clientWidth, te.clientWidth) - j),
              { width: j, height: ne, x: Ee, y: Ie }
            );
          })(f(l));
        else if (v(h))
          M = (function (D, H) {
            let ee = Q(D, !0, H === "fixed"),
              te = ee.top + D.clientTop,
              j = ee.left + D.clientLeft,
              ne = x(D) ? $(D) : o(1);
            return {
              width: D.clientWidth * ne.x,
              height: D.clientHeight * ne.y,
              x: j * ne.x,
              y: te * ne.y,
            };
          })(h, O);
        else {
          let D = F(l);
          M = { x: h.x - D.x, y: h.y - D.y, width: h.width, height: h.height };
        }
        return S.rectToClientRect(M);
      }
      function se(l, h) {
        let O = ye(l);
        return (
          !(O === h || !v(O) || B(O)) && (T(O).position === "fixed" || se(O, h))
        );
      }
      function X(l, h, O) {
        let M = x(h),
          D = f(h),
          H = O === "fixed",
          ee = Q(l, !0, H, h),
          te = { scrollLeft: 0, scrollTop: 0 },
          j = o(0);
        function ne() {
          j.x = de(D);
        }
        if (M || (!M && !H))
          if (((C(h) !== "body" || W(D)) && (te = V(h)), M)) {
            let Ie = Q(h, !0, H, h);
            (j.x = Ie.x + h.clientLeft), (j.y = Ie.y + h.clientTop);
          } else D && ne();
        H && !M && D && ne();
        let Ee = !D || M || H ? o(0) : ke(D, te);
        return {
          x: ee.left + te.scrollLeft - j.x - Ee.x,
          y: ee.top + te.scrollTop - j.y - Ee.y,
          width: ee.width,
          height: ee.height,
        };
      }
      function le(l) {
        return T(l).position === "static";
      }
      function J(l, h) {
        if (!x(l) || T(l).position === "fixed") return null;
        if (h) return h(l);
        let O = l.offsetParent;
        return f(l) === O && (O = O.ownerDocument.body), O;
      }
      function re(l, h) {
        let O = s(l);
        if (c(l)) return O;
        if (!x(l)) {
          let D = ye(l);
          for (; D && !B(D); ) {
            if (v(D) && !le(D)) return D;
            D = ye(D);
          }
          return O;
        }
        let M = J(l, h);
        for (; M && R(M) && le(M); ) M = J(M, h);
        return M && B(M) && le(M) && !w(M)
          ? O
          : M ||
              (function (D) {
                let H = ye(D);
                for (; x(H) && !B(H); ) {
                  if (w(H)) return H;
                  if (c(H)) return null;
                  H = ye(H);
                }
                return null;
              })(l) ||
              O;
      }
      let oe = {
        convertOffsetParentRelativeRectToViewportRelativeRect: function (l) {
          let { elements: h, rect: O, offsetParent: M, strategy: D } = l,
            H = D === "fixed",
            ee = f(M),
            te = !!h && c(h.floating);
          if (M === ee || (te && H)) return O;
          let j = { scrollLeft: 0, scrollTop: 0 },
            ne = o(1),
            Ee = o(0),
            Ie = x(M);
          if (
            (Ie || (!Ie && !H)) &&
            ((C(M) !== "body" || W(ee)) && (j = V(M)), x(M))
          ) {
            let Ze = Q(M);
            (ne = $(M)),
              (Ee.x = Ze.x + M.clientLeft),
              (Ee.y = Ze.y + M.clientTop);
          }
          let Ge = !ee || Ie || H ? o(0) : ke(ee, j, !0);
          return {
            width: O.width * ne.x,
            height: O.height * ne.y,
            x: O.x * ne.x - j.scrollLeft * ne.x + Ee.x + Ge.x,
            y: O.y * ne.y - j.scrollTop * ne.y + Ee.y + Ge.y,
          };
        },
        getDocumentElement: f,
        getClippingRect: function (l) {
          let { element: h, boundary: O, rootBoundary: M, strategy: D } = l,
            H = [
              ...(O === "clippingAncestors"
                ? c(h)
                  ? []
                  : (function (j, ne) {
                      let Ee = ne.get(j);
                      if (Ee) return Ee;
                      let Ie = ge(j, [], !1).filter(
                          (He) => v(He) && C(He) !== "body"
                        ),
                        Ge = null,
                        Ze = T(j).position === "fixed",
                        Le = Ze ? ye(j) : j;
                      for (; v(Le) && !B(Le); ) {
                        let He = T(Le),
                          De = w(Le);
                        De || He.position !== "fixed" || (Ge = null),
                          (
                            Ze
                              ? !De && !Ge
                              : (!De &&
                                  He.position === "static" &&
                                  Ge &&
                                  ["absolute", "fixed"].includes(
                                    Ge.position
                                  )) ||
                                (W(Le) && !De && se(j, Le))
                          )
                            ? (Ie = Ie.filter((Ye) => Ye !== Le))
                            : (Ge = He),
                          (Le = ye(Le));
                      }
                      return ne.set(j, Ie), Ie;
                    })(h, this._c)
                : [].concat(O)),
              M,
            ],
            ee = H[0],
            te = H.reduce((j, ne) => {
              let Ee = Ae(h, ne, D);
              return (
                (j.top = i(Ee.top, j.top)),
                (j.right = P(Ee.right, j.right)),
                (j.bottom = P(Ee.bottom, j.bottom)),
                (j.left = i(Ee.left, j.left)),
                j
              );
            }, Ae(h, ee, D));
          return {
            width: te.right - te.left,
            height: te.bottom - te.top,
            x: te.left,
            y: te.top,
          };
        },
        getOffsetParent: re,
        getElementRects: async function (l) {
          let h = this.getOffsetParent || re,
            O = this.getDimensions,
            M = await O(l.floating);
          return {
            reference: X(l.reference, await h(l.floating), l.strategy),
            floating: { x: 0, y: 0, width: M.width, height: M.height },
          };
        },
        getClientRects: function (l) {
          return Array.from(l.getClientRects());
        },
        getDimensions: function (l) {
          let { width: h, height: O } = A(l);
          return { width: h, height: O };
        },
        getScale: $,
        isElement: v,
        isRTL: function (l) {
          return T(l).direction === "rtl";
        },
      };
      function ie(l, h) {
        return (
          l.x === h.x &&
          l.y === h.y &&
          l.width === h.width &&
          l.height === h.height
        );
      }
      let we = S.detectOverflow,
        ue = S.offset,
        me = S.autoPlacement,
        be = S.shift,
        _e = S.flip,
        qe = S.size,
        Ue = S.hide,
        Qe = S.arrow,
        Ce = S.inline,
        Be = S.limitShift;
      return (
        (N.arrow = Qe),
        (N.autoPlacement = me),
        (N.autoUpdate = function (l, h, O, M) {
          M === void 0 && (M = {});
          let {
              ancestorScroll: D = !0,
              ancestorResize: H = !0,
              elementResize: ee = typeof ResizeObserver == "function",
              layoutShift: te = typeof IntersectionObserver == "function",
              animationFrame: j = !1,
            } = M,
            ne = Z(l),
            Ee = D || H ? [...(ne ? ge(ne) : []), ...ge(h)] : [];
          Ee.forEach((De) => {
            D && De.addEventListener("scroll", O, { passive: !0 }),
              H && De.addEventListener("resize", O);
          });
          let Ie =
              ne && te
                ? (function (De, Ye) {
                    let it,
                      rt = null,
                      ut = f(De);
                    function vt() {
                      var ot;
                      clearTimeout(it),
                        (ot = rt) == null || ot.disconnect(),
                        (rt = null);
                    }
                    return (
                      (function ot(yt, mt) {
                        yt === void 0 && (yt = !1),
                          mt === void 0 && (mt = 1),
                          vt();
                        let kt = De.getBoundingClientRect(),
                          { left: wt, top: At, width: _t, height: Et } = kt;
                        if ((yt || Ye(), !_t || !Et)) return;
                        let Ct = {
                            rootMargin:
                              -r(At) +
                              "px " +
                              -r(ut.clientWidth - (wt + _t)) +
                              "px " +
                              -r(ut.clientHeight - (At + Et)) +
                              "px " +
                              -r(wt) +
                              "px",
                            threshold: i(0, P(1, mt)) || 1,
                          },
                          Ot = !0;
                        function xt(Nt) {
                          let gt = Nt[0].intersectionRatio;
                          if (gt !== mt) {
                            if (!Ot) return ot();
                            gt
                              ? ot(!1, gt)
                              : (it = setTimeout(() => {
                                  ot(!1, 1e-7);
                                }, 1e3));
                          }
                          gt !== 1 ||
                            ie(kt, De.getBoundingClientRect()) ||
                            ot(),
                            (Ot = !1);
                        }
                        try {
                          rt = new IntersectionObserver(xt, {
                            ...Ct,
                            root: ut.ownerDocument,
                          });
                        } catch {
                          rt = new IntersectionObserver(xt, Ct);
                        }
                        rt.observe(De);
                      })(!0),
                      vt
                    );
                  })(ne, O)
                : null,
            Ge,
            Ze = -1,
            Le = null;
          ee &&
            ((Le = new ResizeObserver((De) => {
              let [Ye] = De;
              Ye &&
                Ye.target === ne &&
                Le &&
                (Le.unobserve(h),
                cancelAnimationFrame(Ze),
                (Ze = requestAnimationFrame(() => {
                  var it;
                  (it = Le) == null || it.observe(h);
                }))),
                O();
            })),
            ne && !j && Le.observe(ne),
            Le.observe(h));
          let He = j ? Q(l) : null;
          return (
            j &&
              (function De() {
                let Ye = Q(l);
                He && !ie(He, Ye) && O(),
                  (He = Ye),
                  (Ge = requestAnimationFrame(De));
              })(),
            O(),
            () => {
              var De;
              Ee.forEach((Ye) => {
                D && Ye.removeEventListener("scroll", O),
                  H && Ye.removeEventListener("resize", O);
              }),
                Ie?.(),
                (De = Le) == null || De.disconnect(),
                (Le = null),
                j && cancelAnimationFrame(Ge);
            }
          );
        }),
        (N.computePosition = (l, h, O) => {
          let M = new Map(),
            D = { platform: oe, ...O },
            H = { ...D.platform, _c: M };
          return S.computePosition(l, h, { ...D, platform: H });
        }),
        (N.detectOverflow = we),
        (N.flip = _e),
        (N.getOverflowAncestors = ge),
        (N.hide = Ue),
        (N.inline = Ce),
        (N.limitShift = Be),
        (N.offset = ue),
        (N.platform = oe),
        (N.shift = be),
        (N.size = qe),
        (window.FloatingUIDOM = N),
        N
      );
    });
  });
  (function () {
    function N(i) {
      let n = i.querySelector("[data-avatar-image]"),
        r = i.querySelector("[data-avatar-fallback]");
      if (n && r) {
        (n.style.display = "none"), (r.style.display = "none");
        let o = () => {
            (n.style.display = "none"), (r.style.display = "");
          },
          m = () => {
            (n.style.display = ""), (r.style.display = "none");
          };
        n.complete
          ? n.naturalWidth > 0 && n.naturalHeight > 0
            ? m()
            : o()
          : (n.addEventListener("load", m, { once: !0 }),
            n.addEventListener("error", o, { once: !0 }),
            setTimeout(() => {
              n.complete && !(n.naturalWidth > 0 && n.naturalHeight > 0) && o();
            }, 50));
      } else r ? (r.style.display = "") : n && (n.style.display = "");
    }
    function S(i = document) {
      i instanceof Element && i.matches("[data-avatar]") && N(i);
      for (let n of i.querySelectorAll("[data-avatar]")) N(n);
    }
    let P = (i) => {
      let n = i.detail.elt;
      n instanceof Element && requestAnimationFrame(() => S(n));
    };
    S(),
      document.addEventListener("DOMContentLoaded", () => S()),
      document.body.addEventListener("htmx:afterSwap", P),
      document.body.addEventListener("htmx:oobAfterSwap", P);
  })();
  (function () {
    function N(i) {
      if (!i || i._calendarInitialized) return;
      let n = i.querySelector("[data-calendar-month-display]"),
        r = i.querySelector("[data-calendar-weekdays]"),
        o = i.querySelector("[data-calendar-days]"),
        m = i.querySelector("[data-calendar-prev]"),
        C = i.querySelector("[data-calendar-next]"),
        s = i.closest("[data-calendar-wrapper]"),
        f = s ? s.querySelector("[data-calendar-hidden-input]") : null;
      if (!n || !r || !o || !m || !C || !f) {
        console.error(
          "Calendar init error: Missing required elements (or hidden input relative to wrapper).",
          i
        );
        return;
      }
      let g = i.dataset.localeTag || "en-US",
        v;
      try {
        v = Array.from({ length: 12 }, (Ne, ge) =>
          new Intl.DateTimeFormat(g, { month: "long", timeZone: "UTC" }).format(
            new Date(Date.UTC(2e3, ge, 1))
          )
        );
      } catch (Ne) {
        console.error(
          `Calendar: Error generating month names via Intl (locale: "${g}"). Falling back to English.`,
          Ne
        ),
          (v = [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
          ]);
      }
      let x = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];
      try {
        x = Array.from({ length: 7 }, (Ne, ge) =>
          new Intl.DateTimeFormat(g, { weekday: "short" }).format(
            new Date(Date.UTC(2e3, 0, ge))
          )
        );
      } catch (Ne) {
        console.error("Error generating calendar day names via Intl:", Ne);
      }
      let E = parseInt(i.dataset.initialMonth),
        W = parseInt(i.dataset.initialYear),
        R = null;
      i.dataset.selectedDate && (R = c(i.dataset.selectedDate));
      function c(Ne) {
        if (!Ne) return null;
        try {
          let ge = Ne.split("-"),
            b = parseInt(ge[0], 10),
            A = parseInt(ge[1], 10) - 1,
            Z = parseInt(ge[2], 10),
            $ = new Date(Date.UTC(b, A, Z));
          if (
            !isNaN($) &&
            $.getUTCFullYear() === b &&
            $.getUTCMonth() === A &&
            $.getUTCDate() === Z
          )
            return $;
        } catch {}
        return null;
      }
      function w() {
        let Ne = Math.max(0, Math.min(11, E)),
          b = `${v[Ne]} ${W}`;
        n.textContent = b;
      }
      function k() {
        (r.innerHTML = ""),
          x.forEach((Ne) => {
            let ge = document.createElement("div");
            (ge.className =
              "text-center text-xs text-muted-foreground font-medium"),
              (ge.textContent = Ne),
              r.appendChild(ge);
          });
      }
      function B() {
        o.innerHTML = "";
        let b = new Date(Date.UTC(W, E, 1)).getUTCDay(),
          A = new Date(Date.UTC(W, E + 1, 0)).getUTCDate(),
          Z = new Date(),
          $ = new Date(Date.UTC(Z.getFullYear(), Z.getMonth(), Z.getDate()));
        for (let U = 0; U < b; U++) {
          let F = document.createElement("div");
          (F.className = "h-8 w-8"), o.appendChild(F);
        }
        for (let U = 1; U <= A; U++) {
          let F = document.createElement("button");
          (F.type = "button"),
            (F.className =
              "inline-flex h-8 w-8 items-center justify-center rounded-md text-sm font-medium focus:outline-none focus:ring-1 focus:ring-ring"),
            (F.textContent = U),
            (F.dataset.day = U);
          let Q = new Date(Date.UTC(W, E, U)),
            de = R && Q.getTime() === R.getTime(),
            ke = Q.getTime() === $.getTime();
          de
            ? F.classList.add(
                "bg-primary",
                "text-primary-foreground",
                "hover:bg-primary/90"
              )
            : ke
            ? F.classList.add("bg-accent", "text-accent-foreground")
            : F.classList.add(
                "hover:bg-accent",
                "hover:text-accent-foreground"
              ),
            F.addEventListener("click", ye),
            o.appendChild(F);
        }
      }
      function T() {
        E--, E < 0 && ((E = 11), W--), w(), B();
      }
      function V() {
        E++, E > 11 && ((E = 0), W++), w(), B();
      }
      function ye(Ne) {
        let ge = parseInt(Ne.target.dataset.day);
        if (!ge) return;
        let b = new Date(Date.UTC(W, E, ge));
        R = b;
        let A = b.toISOString().split("T")[0];
        (f.value = A),
          f.dispatchEvent(new Event("change", { bubbles: !0 })),
          i.dispatchEvent(
            new CustomEvent("calendar-date-selected", {
              bubbles: !0,
              detail: { date: b },
            })
          ),
          B();
      }
      m.addEventListener("click", T),
        C.addEventListener("click", V),
        w(),
        k(),
        B(),
        (i._calendarInitialized = !0);
    }
    function S(i = document) {
      i instanceof Element && i.matches("[data-calendar-container]") && N(i);
      for (let n of i.querySelectorAll("[data-calendar-container]")) N(n);
    }
    let P = (i) => {
      let n = i.detail.elt;
      n instanceof Element && requestAnimationFrame(() => S(n));
    };
    S(),
      document.addEventListener("DOMContentLoaded", () => S()),
      document.body.addEventListener("htmx:afterSwap", P),
      document.body.addEventListener("htmx:oobAfterSwap", P);
  })();
  (function () {
    function N(i) {
      let n = i.querySelector(".carousel-track"),
        r = Array.from(n?.querySelectorAll(".carousel-item") || []);
      if (r.length === 0) return;
      let o = Array.from(i.querySelectorAll(".carousel-indicator")),
        m = i.querySelector(".carousel-prev"),
        C = i.querySelector(".carousel-next"),
        s = {
          currentIndex: 0,
          slideCount: r.length,
          autoplay: i.dataset.autoplay === "true",
          interval: parseInt(i.dataset.interval || 5e3),
          loop: i.dataset.loop === "true",
          autoplayInterval: null,
          isHovering: !1,
          touchStartX: 0,
        };
      function f() {
        n.style.transform = `translateX(-${s.currentIndex * 100}%)`;
      }
      function g() {
        o.forEach((w, k) => {
          k < s.slideCount
            ? (k === s.currentIndex
                ? (w.classList.add("bg-white"),
                  w.classList.remove("bg-white/50"))
                : (w.classList.remove("bg-white"),
                  w.classList.add("bg-white/50")),
              (w.style.display = ""))
            : (w.style.display = "none");
        });
      }
      function v() {
        m &&
          ((m.disabled = !s.loop && s.currentIndex === 0),
          m.classList.toggle("opacity-50", m.disabled),
          m.classList.toggle("cursor-not-allowed", m.disabled)),
          C &&
            ((C.disabled = !s.loop && s.currentIndex === s.slideCount - 1),
            C.classList.toggle("opacity-50", C.disabled),
            C.classList.toggle("cursor-not-allowed", C.disabled));
      }
      function x() {
        s.autoplayInterval && clearInterval(s.autoplayInterval),
          s.autoplay &&
            (s.autoplayInterval = setInterval(() => {
              s.isHovering || W();
            }, s.interval));
      }
      function E() {
        s.autoplayInterval &&
          (clearInterval(s.autoplayInterval), (s.autoplayInterval = null));
      }
      function W() {
        let w = s.currentIndex + 1;
        if (w >= s.slideCount)
          if (s.loop) w = 0;
          else return;
        c(w);
      }
      function R() {
        let w = s.currentIndex - 1;
        if (w < 0)
          if (s.loop) w = s.slideCount - 1;
          else return;
        c(w);
      }
      function c(w) {
        if (w < 0 || w >= s.slideCount)
          if (s.loop) w = (w + s.slideCount) % s.slideCount;
          else return;
        w !== s.currentIndex &&
          ((s.currentIndex = w),
          f(),
          g(),
          v(),
          s.autoplay && !s.isHovering && (E(), x()));
      }
      n &&
        (n.addEventListener(
          "touchstart",
          (w) => {
            s.touchStartX = w.touches[0].clientX;
          },
          { passive: !0 }
        ),
        n.addEventListener(
          "touchend",
          (w) => {
            let k = w.changedTouches[0].clientX,
              B = s.touchStartX - k;
            Math.abs(B) > 50 && (B > 0 ? W() : R());
          },
          { passive: !0 }
        )),
        o.forEach((w, k) => {
          k < s.slideCount && w.addEventListener("click", () => c(k));
        }),
        m && m.addEventListener("click", R),
        C && C.addEventListener("click", W),
        i.addEventListener("mouseenter", () => {
          (s.isHovering = !0), s.autoplay && E();
        }),
        i.addEventListener("mouseleave", () => {
          (s.isHovering = !1), s.autoplay && x();
        }),
        f(),
        g(),
        v(),
        s.autoplay && x();
    }
    function S(i = document) {
      i instanceof Element && i.matches(".carousel-component") && N(i);
      for (let n of i.querySelectorAll(".carousel-component")) N(n);
    }
    let P = (i) => {
      let n = i.detail.elt;
      n instanceof Element && requestAnimationFrame(() => S(n));
    };
    S(),
      document.addEventListener("DOMContentLoaded", () => S()),
      document.body.addEventListener("htmx:afterSwap", P),
      document.body.addEventListener("htmx:oobAfterSwap", P);
  })();
  window.chartInstances = window.chartInstances || {};
  (function () {
    if (!window.chartScriptInitialized) {
      let r = function () {
          let g = getComputedStyle(document.documentElement);
          return {
            foreground: g.getPropertyValue("--foreground").trim() || "#000",
            background: g.getPropertyValue("--background").trim() || "#fff",
            mutedForeground:
              g.getPropertyValue("--muted-foreground").trim() || "#666",
            border: g.getPropertyValue("--border").trim() || "#ccc",
          };
        },
        o = function (g) {
          if (!g || !g.id || !g.hasAttribute("data-chart-id")) return;
          window.chartInstances[g.id] && m(g);
          let v = g.getAttribute("data-chart-id"),
            x = document.getElementById(v);
          if (x)
            try {
              let E = JSON.parse(x.textContent),
                W = r();
              (Chart.defaults.elements.point.radius = 0),
                (Chart.defaults.elements.point.hoverRadius = 5);
              let R = ["pie", "doughnut", "bar", "radar"].includes(E.type),
                c = {
                  display: E.showLegend || !1,
                  labels: { color: W.foreground },
                },
                w = {
                  backgroundColor: W.background,
                  bodyColor: W.mutedForeground,
                  titleColor: W.foreground,
                  borderColor: W.border,
                  borderWidth: 1,
                },
                k =
                  E.type === "radar"
                    ? {
                        r: {
                          grid: {
                            color: W.border,
                            display: E.showYGrid !== !1,
                          },
                          ticks: {
                            color: W.mutedForeground,
                            backdropColor: "transparent",
                            display: E.showYLabels !== !1,
                          },
                          angleLines: {
                            color: W.border,
                            display: E.showXGrid !== !1,
                          },
                          pointLabels: {
                            color: W.foreground,
                            font: { size: 12 },
                          },
                          border: {
                            display: E.showYAxis !== !1,
                            color: W.border,
                          },
                          beginAtZero: !0,
                        },
                      }
                    : {
                        x: {
                          beginAtZero: !0,
                          display:
                            E.showXLabels !== !1 ||
                            E.showXGrid !== !1 ||
                            E.showXAxis !== !1,
                          border: {
                            display: E.showXAxis !== !1,
                            color: W.border,
                          },
                          ticks: {
                            display: E.showXLabels !== !1,
                            color: W.mutedForeground,
                          },
                          grid: {
                            display: E.showXGrid !== !1,
                            color: W.border,
                          },
                          stacked: E.stacked || !1,
                        },
                        y: {
                          offset: !0,
                          beginAtZero: !0,
                          display:
                            E.showYLabels !== !1 ||
                            E.showYGrid !== !1 ||
                            E.showYAxis !== !1,
                          border: {
                            display: E.showYAxis !== !1,
                            color: W.border,
                          },
                          ticks: {
                            display: E.showYLabels !== !1,
                            color: W.mutedForeground,
                          },
                          grid: {
                            display: E.showYGrid !== !1,
                            color: W.border,
                          },
                          stacked: E.stacked || !1,
                        },
                      },
                B = {
                  ...E,
                  options: {
                    responsive: !0,
                    maintainAspectRatio: !1,
                    interaction: {
                      intersect: !!R,
                      axis: "xy",
                      mode: R ? "nearest" : "index",
                    },
                    indexAxis: E.horizontal ? "y" : "x",
                    plugins: { legend: c, tooltip: w },
                    scales: k,
                  },
                };
              window.chartInstances[g.id] = new Chart(g, B);
            } catch {}
        },
        m = function (g) {
          if (!(!g || !g.id || !window.chartInstances[g.id]))
            try {
              window.chartInstances[g.id].destroy();
            } finally {
              delete window.chartInstances[g.id];
            }
        },
        C = function (g = document) {
          if (!(typeof Chart > "u"))
            for (let v of g.querySelectorAll("canvas[data-chart-id]")) o(v);
        },
        s = function () {
          typeof Chart < "u" ? C() : setTimeout(s, 100);
        };
      var N = r,
        S = o,
        P = m,
        i = C,
        n = s;
      document.addEventListener("DOMContentLoaded", s),
        document.body.addEventListener("htmx:beforeSwap", (g) => {
          let v = g.detail.elt;
          if (v instanceof Element) {
            for (let x of v.querySelectorAll("canvas[data-chart-id]")) m(x);
            v.matches("canvas[data-chart-id]") && m(v);
          }
        }),
        document.body.addEventListener("htmx:afterSwap", (g) => {
          let v = g.detail.elt;
          if (v instanceof Element) {
            let E = function (W = 1) {
              typeof Chart < "u"
                ? C(v)
                : W < 10 && setTimeout(() => E(W + 1), 100);
            };
            var x = E;
            E();
          }
        }),
        new MutationObserver(() => {
          let g;
          clearTimeout(g),
            (g = setTimeout(() => {
              for (let v of document.querySelectorAll("canvas[data-chart-id]"))
                window.chartInstances[v.id] && (m(v), o(v));
            }, 50));
        }).observe(document.documentElement, {
          attributes: !0,
          attributeFilter: ["class", "style"],
        }),
        (window.chartScriptInitialized = !0);
    }
  })();
  var cn = qt(Vt());
  (function () {
    function N(r, o = 1) {
      window.hljs
        ? r()
        : o < 20
        ? setTimeout(() => N(r, o + 1), 100)
        : console.error(
            "highlight.js (hljs) failed to load after several attempts."
          );
    }
    function S(r, o, m) {
      let C = document.createElement("textarea");
      (C.value = r),
        (C.style.position = "fixed"),
        (C.style.top = "-9999px"),
        (C.style.left = "-9999px"),
        document.body.appendChild(C),
        C.focus(),
        C.select();
      try {
        document.execCommand("copy") &&
          ((o.style.display = "inline"),
          (m.style.display = "none"),
          setTimeout(() => {
            (o.style.display = "none"), (m.style.display = "inline");
          }, 2e3));
      } catch (s) {
        console.error("Fallback copy failed", s);
      } finally {
        document.body.removeChild(C);
      }
    }
    function P(r) {
      if (!r || r._codeInitialized) return;
      let o = r.querySelector("[data-code-block]"),
        m = r.querySelector("[data-copy-button]"),
        C = r.querySelector("[data-icon-check]"),
        s = r.querySelector("[data-icon-clipboard]");
      if (
        (o &&
          window.hljs &&
          (o.classList.contains("hljs") || window.hljs.highlightElement(o)),
        m && o && C && s)
      ) {
        let f = m._copyListener;
        f && m.removeEventListener("click", f);
        let g = () => {
          let v = o.textContent || "",
            x = () => {
              (C.style.display = "inline"),
                (s.style.display = "none"),
                setTimeout(() => {
                  (C.style.display = "none"), (s.style.display = "inline");
                }, 2e3);
            };
          navigator.clipboard && window.isSecureContext
            ? navigator.clipboard
                .writeText(v)
                .then(x)
                .catch(() => S(v, C, s))
            : S(v, C, s);
        };
        m.addEventListener("click", g), (m._copyListener = g);
      }
      r._codeInitialized = !0;
    }
    function i(r = document) {
      r instanceof Element && r.matches("[data-code-component]") && P(r);
      for (let o of r.querySelectorAll("[data-code-component]")) P(o);
    }
    let n = (r) => {
      let o = r.detail.elt;
      o instanceof Element && N(() => i(o));
    };
    i(),
      document.addEventListener("DOMContentLoaded", () => {
        N(() => i());
      }),
      document.body.addEventListener("htmx:afterSwap", n),
      document.body.addEventListener("htmx:oobAfterSwap", n);
  })();
  (function () {
    function N(r) {
      if (!r || typeof r != "string") return null;
      let o = r.match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (!o) return null;
      let m = parseInt(o[1], 10),
        C = parseInt(o[2], 10) - 1,
        s = parseInt(o[3], 10),
        f = new Date(Date.UTC(m, C, s));
      return f.getUTCFullYear() === m &&
        f.getUTCMonth() === C &&
        f.getUTCDate() === s
        ? f
        : null;
    }
    function S(r, o, m) {
      if (!r || isNaN(r.getTime())) return "";
      let C = { timeZone: "UTC" };
      switch (o) {
        case "locale-short":
          C.dateStyle = "short";
          break;
        case "locale-long":
          C.dateStyle = "long";
          break;
        case "locale-full":
          C.dateStyle = "full";
          break;
        case "locale-medium":
        default:
          C.dateStyle = "medium";
          break;
      }
      try {
        return new Intl.DateTimeFormat(m, C).format(r);
      } catch (s) {
        console.error(
          `Error formatting date with Intl (locale: ${m}, format: ${o}, timezone: UTC):`,
          s
        );
        try {
          let f = { dateStyle: "medium", timeZone: "UTC" };
          return new Intl.DateTimeFormat(m, f).format(r);
        } catch (f) {
          console.error(
            `Error formatting date with fallback Intl (locale: ${m}, timezone: UTC):`,
            f
          );
          let g = r.getUTCFullYear(),
            v = (r.getUTCMonth() + 1).toString().padStart(2, "0"),
            x = r.getUTCDate().toString().padStart(2, "0");
          return `${g}-${v}-${x}`;
        }
      }
    }
    function P(r) {
      if (!r || r._datePickerInitialized) return;
      let o = r.id,
        m = r.querySelector("[data-datepicker-display]"),
        C = o + "-calendar-instance",
        s = document.getElementById(C),
        f = C + "-hidden",
        g = document.getElementById(f),
        v = s,
        x = g;
      if (!s || !g) {
        let k = r.getAttribute("aria-controls"),
          B = k ? document.getElementById(k) : null;
        if (
          B &&
          (v || (v = B.querySelector("[data-calendar-container]")), !x)
        ) {
          let T = B.querySelector("[data-calendar-wrapper]");
          x = T ? T.querySelector("[data-calendar-hidden-input]") : null;
        }
      }
      if (!m || !v || !x) {
        console.error("DatePicker init error: Missing required elements.", {
          datePickerID: o,
          displaySpan: m,
          calendar: v,
          hiddenInput: x,
        });
        return;
      }
      let E = r.dataset.displayFormat || "locale-medium",
        W = r.dataset.localeTag || "en-US",
        R = r.dataset.placeholder || "Select a date",
        c = (k) => {
          if (!k.detail || !k.detail.date || !(k.detail.date instanceof Date))
            return;
          let B = k.detail.date,
            T = S(B, E, W);
          (m.textContent = T), m.classList.remove("text-muted-foreground");
          let V = r
            .closest("[data-popover]")
            ?.querySelector("[data-popover-trigger]");
          V instanceof HTMLElement ? V.click() : r.click();
        },
        w = () => {
          if (x && x.value) {
            let k = N(x.value);
            if (k) {
              let B = S(k, E, W);
              m.textContent.trim() !== B &&
                ((m.textContent = B),
                m.classList.remove("text-muted-foreground"));
            } else
              (m.textContent = R), m.classList.add("text-muted-foreground");
          } else (m.textContent = R), m.classList.add("text-muted-foreground");
        };
      v.addEventListener("calendar-date-selected", c),
        w(),
        (r._datePickerInitialized = !0),
        (r._datePickerCleanup = () => {
          v && v.removeEventListener("calendar-date-selected", c);
        });
    }
    function i(r = document) {
      r instanceof Element && r.matches('[data-datepicker="true"]') && P(r),
        r.querySelectorAll('[data-datepicker="true"]').forEach((o) => {
          P(o);
        });
    }
    let n = (r) => {
      let o = r.detail.elt;
      o instanceof Element && requestAnimationFrame(() => i(o));
    };
    i(),
      document.addEventListener("DOMContentLoaded", () => i()),
      document.body.addEventListener("htmx:beforeSwap", (r) => {
        let o = r.detail.elt;
        if (o instanceof Element) {
          let m = (C) => {
            C.matches &&
              C.matches('[data-datepicker="true"]') &&
              C._datePickerCleanup &&
              (C._datePickerCleanup(),
              delete C._datePickerCleanup,
              delete C._datePickerInitialized);
          };
          o.matches && o.matches('[data-datepicker="true"]') && m(o),
            o.querySelectorAll &&
              o.querySelectorAll('[data-datepicker="true"]').forEach(m);
        }
      }),
      document.body.addEventListener("htmx:afterSwap", n),
      document.body.addEventListener("htmx:oobAfterSwap", n);
  })();
  (function () {
    function N(n) {
      let r = n.querySelectorAll("[data-drawer-trigger]"),
        o = n.querySelector("[data-drawer-content]"),
        m = n.querySelector("[data-drawer-backdrop]"),
        C = n.querySelectorAll("[data-drawer-close]"),
        s = o?.getAttribute("data-drawer-position") || "right";
      if (!o || !m) return;
      let f = {
        left: {
          enterFrom: "opacity-0 -translate-x-full",
          enterTo: "opacity-100 translate-x-0",
          leaveFrom: "opacity-100 translate-x-0",
          leaveTo: "opacity-0 -translate-x-full",
        },
        right: {
          enterFrom: "opacity-0 translate-x-full",
          enterTo: "opacity-100 translate-x-0",
          leaveFrom: "opacity-100 translate-x-0",
          leaveTo: "opacity-0 translate-x-full",
        },
        top: {
          enterFrom: "opacity-0 -translate-y-full",
          enterTo: "opacity-100 translate-y-0",
          leaveFrom: "opacity-100 translate-y-0",
          leaveTo: "opacity-0 -translate-y-full",
        },
        bottom: {
          enterFrom: "opacity-0 translate-y-full",
          enterTo: "opacity-100 translate-y-0",
          leaveFrom: "opacity-100 translate-y-0",
          leaveTo: "opacity-0 translate-y-full",
        },
      };
      if (n.dataset.drawerInitialized) return;
      (n.dataset.drawerInitialized = "true"),
        (o.style.transform =
          s === "left"
            ? "translateX(-100%)"
            : s === "right"
            ? "translateX(100%)"
            : s === "top"
            ? "translateY(-100%)"
            : "translateY(100%)"),
        (o.style.opacity = "0"),
        (m.style.opacity = "0"),
        (o.style.display = "none"),
        (m.style.display = "none");
      function g() {
        (m.style.display = "block"),
          (o.style.display = "block"),
          o.offsetWidth,
          (m.style.transition = "opacity 300ms ease-out"),
          (o.style.transition =
            "opacity 300ms ease-out, transform 300ms ease-out"),
          (m.style.opacity = "1"),
          (o.style.opacity = "1"),
          (o.style.transform = "translate(0)"),
          (document.body.style.overflow = "hidden"),
          m.addEventListener("click", v),
          document.addEventListener("keydown", E),
          document.addEventListener("click", x);
      }
      function v() {
        m.removeEventListener("click", v),
          document.removeEventListener("keydown", E),
          document.removeEventListener("click", x),
          (m.style.transition = "opacity 300ms ease-in"),
          (o.style.transition =
            "opacity 300ms ease-in, transform 300ms ease-in"),
          (m.style.opacity = "0"),
          s === "left"
            ? (o.style.transform = "translateX(-100%)")
            : s === "right"
            ? (o.style.transform = "translateX(100%)")
            : s === "top"
            ? (o.style.transform = "translateY(-100%)")
            : s === "bottom" && (o.style.transform = "translateY(100%)"),
          (o.style.opacity = "0"),
          setTimeout(() => {
            o.style.opacity === "0" &&
              ((m.style.display = "none"), (o.style.display = "none")),
              document.querySelector(
                '[data-component="drawer"] [data-drawer-backdrop][style*="display: block"]'
              ) || (document.body.style.overflow = "");
          }, 300);
      }
      function x(R) {
        o.style.display === "block" &&
          !o.contains(R.target) &&
          !Array.from(r).some((c) => c.contains(R.target)) &&
          v();
      }
      function E(R) {
        R.key === "Escape" && o.style.display === "block" && v();
      }
      r.forEach((R) => {
        R.removeEventListener("click", g), R.addEventListener("click", g);
      }),
        C.forEach((R) => {
          R.removeEventListener("click", v), R.addEventListener("click", v);
        });
      let W = o.querySelector("[data-drawer-inner]");
      W && (W.removeEventListener("click", S), W.addEventListener("click", S));
    }
    function S(n) {
      n.stopPropagation();
    }
    function P(n = document) {
      n instanceof Element && n.matches('[data-component="drawer"]') && N(n),
        n &&
          typeof n.querySelectorAll == "function" &&
          n.querySelectorAll('[data-component="drawer"]').forEach(N);
    }
    let i = (n) => {
      let r = n.detail.elt;
      r instanceof Element && requestAnimationFrame(() => P(r));
    };
    P(),
      document.addEventListener("DOMContentLoaded", () => P()),
      document.body.addEventListener("htmx:afterSwap", i),
      document.body.addEventListener("htmx:oobAfterSwap", i);
  })();
  (function () {
    function N(i) {
      let r = i.currentTarget.closest("[data-popover-id]");
      if (r) {
        let o = r.dataset.popoverId;
        window.closePopover
          ? window.closePopover(o, !0)
          : (console.warn("popover.Script's closePopover function not found."),
            document.body.click());
      }
    }
    function S(i = document) {
      i.querySelectorAll(
        "[data-dropdown-item]:not([data-dropdown-submenu-trigger])"
      ).forEach((r) => {
        r.removeEventListener("click", N), r.addEventListener("click", N);
      });
    }
    let P = (i) => {
      let n = i.detail.elt;
      n instanceof Element && requestAnimationFrame(() => S(n));
    };
    S(),
      document.addEventListener("DOMContentLoaded", () => S()),
      document.body.addEventListener("htmx:afterSwap", P),
      document.body.addEventListener("htmx:oobAfterSwap", P);
  })();
  (function () {
    function N(i) {
      i.hasAttribute("data-password-initialized") ||
        (i.setAttribute("data-password-initialized", "true"),
        i.addEventListener("click", function (n) {
          let r = i.getAttribute("data-toggle-password"),
            o = document.getElementById(r);
          if (o) {
            let m = i.querySelector(".icon-open"),
              C = i.querySelector(".icon-closed");
            o.type === "password"
              ? ((o.type = "text"),
                m.classList.add("hidden"),
                C.classList.remove("hidden"))
              : ((o.type = "password"),
                m.classList.remove("hidden"),
                C.classList.add("hidden"));
          }
        }));
    }
    function S(i = document) {
      i.querySelectorAll(
        "[data-toggle-password]:not([data-password-initialized])"
      ).forEach((r) => {
        N(r);
      });
    }
    let P = (i) => {
      let n = i.detail.elt;
      n instanceof Element && requestAnimationFrame(() => S(n));
    };
    S(),
      document.addEventListener("DOMContentLoaded", () => S()),
      document.body.addEventListener("htmx:afterSwap", P),
      document.body.addEventListener("htmx:oobAfterSwap", P);
  })();
  typeof window.inputOTPState > "u" && (window.inputOTPState = new WeakMap());
  (function () {
    if (window.inputOTPSystemInitialized) return;
    function N(n) {
      if (window.inputOTPState.has(n)) return;
      let r = n.querySelector("[data-input-otp-value-target]"),
        o = Array.from(n.querySelectorAll("[data-input-otp-slot]")).sort(
          (R, c) =>
            parseInt(R.dataset.inputIndex) - parseInt(c.dataset.inputIndex)
        );
      if (!r || o.length === 0) return;
      n.hasAttribute("autofocus") &&
        requestAnimationFrame(() => {
          let R = o[0];
          R && (R.focus(), R.select());
        });
      let m = () => {
          r.value = o.map((R) => R.value).join("");
        },
        C = () => o.findIndex((R) => !R.value),
        s = (R) => {
          R >= 0 &&
            R < o.length &&
            (o[R].focus(), setTimeout(() => o[R].select(), 0));
        },
        f = (R) => {
          let c = R.target,
            w = parseInt(c.dataset.inputIndex);
          if (c.value === " ") {
            c.value = "";
            return;
          }
          c.value.length > 1 && (c.value = c.value.slice(-1)),
            c.value && w < o.length - 1 && s(w + 1),
            m();
        },
        g = (R) => {
          let c = R.target,
            w = parseInt(c.dataset.inputIndex);
          if (R.key === "Backspace") {
            let k = c.value;
            w > 0 &&
              (R.preventDefault(),
              k
                ? ((c.value = ""), m(), s(w - 1))
                : ((o[w - 1].value = ""), m(), s(w - 1)));
          } else
            R.key === "ArrowLeft" && w > 0
              ? (R.preventDefault(), s(w - 1))
              : R.key === "ArrowRight" &&
                w < o.length - 1 &&
                (R.preventDefault(), s(w + 1));
        },
        v = (R) => {
          let c = R.target,
            w = parseInt(c.dataset.inputIndex),
            k = C();
          if (k !== -1 && w !== k) {
            s(k);
            return;
          }
          setTimeout(() => c.select(), 0);
        },
        x = (R) => {
          R.preventDefault();
          let w = (R.clipboardData || window.clipboardData)
              .getData("text")
              .replace(/\s/g, "")
              .split(""),
            k = 0,
            B = o.find((V) => V === document.activeElement);
          B && (k = parseInt(B.dataset.inputIndex));
          for (let V = 0; V < w.length && k < o.length; V++)
            (o[k].value = w[V]), k++;
          m();
          let T = C();
          T === -1 ? (T = o.length - 1) : T > 0 && T > k && (T = k),
            s(Math.min(T, o.length - 1));
        };
      for (let R of o)
        R.addEventListener("input", f),
          R.addEventListener("keydown", g),
          R.addEventListener("focus", v);
      n.addEventListener("paste", x);
      let E = r.id;
      if (E) {
        for (let R of document.querySelectorAll(`label[for="${E}"]`))
          if (!R.dataset.inputOtpListener) {
            let c = (w) => {
              w.preventDefault(), o.length > 0 && s(0);
            };
            R.addEventListener("click", c),
              (R.dataset.inputOtpListener = "true"),
              (R._inputOtpClickListener = c);
          }
      }
      if (n.dataset.value) {
        let R = n.dataset.value;
        for (let c = 0; c < o.length && c < R.length; c++) o[c].value = R[c];
        m();
      }
      let W = {
        slots: o,
        hiddenInput: r,
        handleInput: f,
        handleKeydown: g,
        handleFocus: v,
        handlePaste: x,
      };
      window.inputOTPState.set(n, W);
    }
    function S(n) {
      let r = window.inputOTPState.get(n);
      if (!r) return;
      for (let m of r.slots)
        m.removeEventListener("input", r.handleInput),
          m.removeEventListener("keydown", r.handleKeydown),
          m.removeEventListener("focus", r.handleFocus);
      n.removeEventListener("paste", r.handlePaste);
      let o = r.hiddenInput.id;
      if (o)
        for (let m of document.querySelectorAll(`label[for="${o}"]`))
          m._inputOtpClickListener &&
            (m.removeEventListener("click", m._inputOtpClickListener),
            delete m._inputOtpClickListener,
            delete m.dataset.inputOtpListener);
      window.inputOTPState.delete(n);
    }
    function P(n = document) {
      n instanceof Element && n.matches("[data-input-otp]") && N(n),
        n.querySelectorAll("[data-input-otp]").forEach(N);
    }
    let i = (n) => {
      let r = n.detail.elt;
      r instanceof Element && requestAnimationFrame(() => P(r));
    };
    document.addEventListener("DOMContentLoaded", () => P()),
      document.body.addEventListener("htmx:beforeSwap", (n) => {
        let r = n.detail.elt;
        if (
          r instanceof Element &&
          (r.matches && r.matches("[data-input-otp]") && S(r),
          r.querySelectorAll)
        )
          for (let o of r.querySelectorAll("[data-input-otp]")) S(o);
      }),
      P(),
      document.body.addEventListener("htmx:afterSwap", i),
      document.body.addEventListener("htmx:oobAfterSwap", i),
      (window.inputOTPSystemInitialized = !0);
  })();
  (function () {
    function N(i) {
      if (!i.hasAttribute("for") || !i.hasAttribute("data-disabled-style"))
        return;
      let n = i.getAttribute("for"),
        r = n ? document.getElementById(n) : null,
        o = i.getAttribute("data-disabled-style");
      if (!o) return;
      let m = o.split(" ").filter(Boolean);
      function C() {
        r && r.disabled ? i.classList.add(...m) : i.classList.remove(...m);
      }
      r &&
        new MutationObserver((f) => {
          for (let g of f)
            g.type === "attributes" && g.attributeName === "disabled" && C();
        }).observe(r, { attributes: !0, attributeFilter: ["disabled"] }),
        C();
    }
    function S(i = document) {
      i instanceof Element &&
        i.matches("label[for][data-disabled-style]") &&
        N(i);
      for (let n of i.querySelectorAll("label[for][data-disabled-style]")) N(n);
    }
    let P = (i) => {
      let n = i.detail.elt;
      n instanceof Element && requestAnimationFrame(() => S(n));
    };
    S(),
      document.addEventListener("DOMContentLoaded", () => S()),
      document.body.addEventListener("htmx:afterSwap", P),
      document.body.addEventListener("htmx:oobAfterSwap", P);
  })();
  typeof window.modalState > "u" && (window.modalState = { openModalId: null });
  (function () {
    function N(f, g = !1) {
      if (!f || f.style.display === "none") return;
      let v = f.querySelector("[data-modal-content]"),
        x = f.id;
      f.classList.remove("opacity-100"),
        f.classList.add("opacity-0"),
        v &&
          (v.classList.remove("scale-100", "opacity-100"),
          v.classList.add("scale-95", "opacity-0"));
      function E() {
        (f.style.display = "none"),
          window.modalState.openModalId === x &&
            ((window.modalState.openModalId = null),
            (document.body.style.overflow = ""));
      }
      g ? E() : setTimeout(E, 300);
    }
    function S(f) {
      if (!f) return;
      if (window.modalState.openModalId) {
        let v = document.getElementById(window.modalState.openModalId);
        v && v !== f && N(v, !0);
      }
      let g = f.querySelector("[data-modal-content]");
      (f.style.display = "flex"),
        (window.modalState.openModalId = f.id),
        (document.body.style.overflow = "hidden"),
        f.offsetHeight,
        f.classList.remove("opacity-0"),
        f.classList.add("opacity-100"),
        g &&
          (g.classList.remove("scale-95", "opacity-0"),
          g.classList.add("scale-100", "opacity-100"),
          setTimeout(() => {
            let v = g.querySelector(
              'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            v && v.focus();
          }, 50));
    }
    function P(f, g = !1) {
      let v = document.getElementById(f);
      v && N(v, g);
    }
    function i(f) {
      let g = document.getElementById(f);
      g && S(g);
    }
    function n(f) {
      let g = window.modalState.openModalId;
      if (!g) return;
      let v = document.getElementById(g);
      if (!v || v.getAttribute("data-disable-click-away") === "true") return;
      let x = v.querySelector("[data-modal-content]"),
        E = f.target.closest("[data-modal-trigger]");
      x &&
        !x.contains(f.target) &&
        (!E || E.getAttribute("data-modal-target-id") !== g) &&
        N(v);
    }
    function r(f) {
      if (f.key !== "Escape" || !window.modalState.openModalId) return;
      let g = document.getElementById(window.modalState.openModalId);
      g && g.getAttribute("data-disable-esc") !== "true" && N(g);
    }
    function o(f) {
      let g = f.getAttribute("data-modal-target-id");
      g &&
        f.addEventListener("click", () => {
          !f.hasAttribute("disabled") &&
            !f.classList.contains("opacity-50") &&
            i(g);
        });
    }
    function m(f) {
      f.addEventListener("click", () => {
        let g = f.getAttribute("data-modal-target-id");
        if (g) P(g);
        else {
          let v = f.closest("[data-modal]");
          v && v.id && N(v);
        }
      });
    }
    function C(f = document) {
      f instanceof Element && f.matches("[data-modal-trigger]") && o(f);
      for (let g of f.querySelectorAll("[data-modal-trigger]")) o(g);
      f instanceof Element && f.matches("[data-modal-close]") && m(f);
      for (let g of f.querySelectorAll("[data-modal-close]")) m(g);
    }
    let s = (f) => {
      let g = f.detail.elt;
      g instanceof Element && requestAnimationFrame(() => C(g));
    };
    typeof window.modalEventsInitialized > "u" &&
      (document.addEventListener("click", n),
      document.addEventListener("keydown", r),
      (window.modalEventsInitialized = !0)),
      C(),
      document.addEventListener("DOMContentLoaded", () => C()),
      document.body.addEventListener("htmx:afterSwap", s),
      document.body.addEventListener("htmx:oobAfterSwap", s);
  })();
  var dn = qt(Yt()),
    un = qt(Ht());
  typeof window.popoverState > "u" && (window.popoverState = new Map());
  (function () {
    if (window.popoverSystemInitialized) return;
    let N = document.querySelector("[data-popover-portal-container]");
    N ||
      ((N = document.createElement("div")),
      N.setAttribute("data-popover-portal-container", ""),
      (N.className = "fixed inset-0 z-[9999] pointer-events-none"),
      document.body.appendChild(N));
    let S = null;
    function P(c, w = 1) {
      window.FloatingUIDOM
        ? ((S = window.FloatingUIDOM), c())
        : w < 40
        ? setTimeout(() => P(c, w + 1), 50)
        : console.error(
            "Floating UI DOM failed to load after several attempts."
          );
    }
    function i(c) {
      let w = c.children;
      if (w.length === 0) return c;
      let k = c,
        B = 0;
      for (let T of w) {
        if (typeof T.getBoundingClientRect != "function") continue;
        let V = T.getBoundingClientRect(),
          ye = V.width * V.height;
        ye > B && ((B = ye), (k = T));
      }
      return k;
    }
    function n(c, w, k, B) {
      let { x: T, y: V } = k,
        ye = { top: "bottom", right: "left", bottom: "top", left: "right" }[
          w.split("-")[0]
        ];
      Object.assign(c.style, {
        left: T != null ? `${T}px` : "",
        top: V != null ? `${V}px` : "",
        right: "",
        bottom: "",
        [ye]: "-5px",
      });
      let Ne = window.getComputedStyle(B),
        ge = Ne.borderColor;
      switch (
        ((c.style.backgroundColor = Ne.backgroundColor),
        (c.style.borderTopColor = ge),
        (c.style.borderRightColor = ge),
        (c.style.borderBottomColor = ge),
        (c.style.borderLeftColor = ge),
        ye)
      ) {
        case "top":
          (c.style.borderBottomColor = "transparent"),
            (c.style.borderRightColor = "transparent");
          break;
        case "bottom":
          (c.style.borderTopColor = "transparent"),
            (c.style.borderLeftColor = "transparent");
          break;
        case "left":
          (c.style.borderTopColor = "transparent"),
            (c.style.borderRightColor = "transparent");
          break;
        case "right":
          (c.style.borderBottomColor = "transparent"),
            (c.style.borderLeftColor = "transparent");
          break;
      }
    }
    function r() {
      if (document.getElementById("popover-animations")) return;
      let c = document.createElement("style");
      (c.id = "popover-animations"),
        (c.textContent = `
            @keyframes popover-in { 0% { opacity: 0; transform: scale(0.95); } 100% { opacity: 1; transform: scale(1); } }
            @keyframes popover-out { 0% { opacity: 1; transform: scale(1); } 100% { opacity: 0; transform: scale(0.95); } }
            [data-popover-id].popover-animate-in { animation: popover-in 0.15s cubic-bezier(0.16, 1, 0.3, 1); }
            [data-popover-id].popover-animate-out { animation: popover-out 0.1s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
        `),
        document.head.appendChild(c);
    }
    function o(c) {
      if (!S || !c || !c.trigger || !c.content) return;
      let { computePosition: w, offset: k, flip: B, shift: T, arrow: V } = S,
        ye = i(c.trigger),
        Ne = c.content.querySelector("[data-popover-arrow]"),
        ge = c.content.dataset.popoverPlacement || "bottom",
        b = parseInt(c.content.dataset.popoverOffset) || (Ne ? 8 : 4),
        A = c.content.dataset.popoverMatchWidth === "true",
        Z = [k(b), B({ padding: 10 }), T({ padding: 10 })];
      Ne && Z.push(V({ element: Ne, padding: 5 })),
        w(ye, c.content, { placement: ge, middleware: Z }).then(
          ({ x: $, y: U, placement: F, middlewareData: Q }) => {
            if (
              (Object.assign(c.content.style, {
                left: `${$}px`,
                top: `${U}px`,
              }),
              A)
            ) {
              let de = ye.offsetWidth;
              c.content.style.setProperty("--popover-trigger-width", `${de}px`);
            }
            Ne && Q.arrow && n(Ne, F, Q.arrow, c.content);
          }
        );
    }
    function m(c, w) {
      if ((C(w), w.content.dataset.popoverDisableClickaway !== "true")) {
        let k = (B) => {
          !w.trigger.contains(B.target) &&
            !w.content.contains(B.target) &&
            f(c);
        };
        setTimeout(() => document.addEventListener("click", k), 0),
          (w.eventListeners.clickAway = k);
      }
      if (w.content.dataset.popoverDisableEsc !== "true") {
        let k = (B) => {
          B.key === "Escape" && f(c);
        };
        document.addEventListener("keydown", k), (w.eventListeners.esc = k);
      }
    }
    function C(c) {
      c.eventListeners.clickAway &&
        document.removeEventListener("click", c.eventListeners.clickAway),
        c.eventListeners.esc &&
          document.removeEventListener("keydown", c.eventListeners.esc),
        (c.eventListeners = {});
    }
    function s(c, w) {
      if (!S) return;
      let { autoUpdate: k } = S,
        B = document.getElementById(c);
      if (!B) return;
      let T = window.popoverState.get(c);
      if (!T)
        (T = {
          trigger: w,
          content: B,
          isOpen: !1,
          cleanup: null,
          hoverState: {},
          eventListeners: {},
        }),
          window.popoverState.set(c, T);
      else if (T.isOpen) return;
      (T.trigger = w), (T.content = B);
      let V = document.querySelector("[data-popover-portal-container]");
      V && B.parentNode !== V && V.appendChild(B),
        (B.style.display = "block"),
        B.classList.remove("popover-animate-out"),
        B.classList.add("popover-animate-in"),
        o(T),
        T.cleanup && T.cleanup(),
        (T.cleanup = k(i(w), B, () => o(T), { animationFrame: !0 })),
        m(c, T),
        (T.isOpen = !0);
    }
    function f(c, w = !1) {
      let k = window.popoverState.get(c);
      if (!k || !k.isOpen) return;
      k.cleanup && (k.cleanup(), (k.cleanup = null)), C(k);
      let B = k.content;
      function T() {
        (B.style.display = "none"),
          B.classList.remove("popover-animate-in", "popover-animate-out");
      }
      w
        ? T()
        : (B.classList.remove("popover-animate-in"),
          B.classList.add("popover-animate-out"),
          setTimeout(T, 150)),
        (k.isOpen = !1);
    }
    window.closePopover = f;
    function g(c, w) {
      let k = (B) => {
        B.stopPropagation(),
          window.popoverState.get(w)?.isOpen ? f(w) : s(w, c);
      };
      c.addEventListener("click", k), (c._popoverListener = k);
    }
    function v(c, w) {
      let k = document.getElementById(w);
      if (!k) return;
      let B = window.popoverState.get(w);
      if (!B) return;
      let T = parseInt(k.dataset.popoverHoverDelay) || 100,
        V = parseInt(k.dataset.popoverHoverOutDelay) || 200,
        ye = () => {
          clearTimeout(B.hoverState.leaveTimeout),
            (B.hoverState.enterTimeout = setTimeout(() => s(w, c), T));
        },
        Ne = (A) => {
          clearTimeout(B.hoverState.enterTimeout),
            (B.hoverState.leaveTimeout = setTimeout(() => {
              k.contains(A.relatedTarget) || f(w);
            }, V));
        },
        ge = () => clearTimeout(B.hoverState.leaveTimeout),
        b = (A) => {
          B.hoverState.leaveTimeout = setTimeout(() => {
            c.contains(A.relatedTarget) || f(w);
          }, V);
        };
      c.addEventListener("mouseenter", ye),
        c.addEventListener("mouseleave", Ne),
        k.addEventListener("mouseenter", ge),
        k.addEventListener("mouseleave", b),
        (c._popoverHoverListeners = {
          handleTriggerEnter: ye,
          handleTriggerLeave: Ne,
        }),
        (k._popoverHoverListeners = {
          handleContentEnter: ge,
          handleContentLeave: b,
        });
    }
    function x(c) {
      let w = c.dataset.popoverFor,
        k = document.getElementById(w);
      if (!w || !k || c._popoverListenerAttached) return;
      if (!window.popoverState.has(w))
        window.popoverState.set(w, {
          trigger: c,
          content: k,
          isOpen: !1,
          cleanup: null,
          hoverState: {},
          eventListeners: {},
        });
      else {
        let T = window.popoverState.get(w);
        (T.trigger = c), (T.content = k), T.isOpen && f(w, !0);
      }
      c._popoverListener && c.removeEventListener("click", c._popoverListener),
        c._popoverHoverListeners &&
          (c.removeEventListener(
            "mouseenter",
            c._popoverHoverListeners.handleTriggerEnter
          ),
          c.removeEventListener(
            "mouseleave",
            c._popoverHoverListeners.handleTriggerLeave
          )),
        k._popoverHoverListeners &&
          (k.removeEventListener(
            "mouseenter",
            k._popoverHoverListeners.handleContentEnter
          ),
          k.removeEventListener(
            "mouseleave",
            k._popoverHoverListeners.handleContentLeave
          )),
        delete c._popoverListener,
        delete c._popoverHoverListeners,
        k && delete k._popoverHoverListeners;
      let B = c.dataset.popoverType || "click";
      B === "click" ? g(c, w) : B === "hover" && v(c, w),
        (c._popoverListenerAttached = !0);
    }
    function E(c) {
      let w = (k) => {
        let B = k.dataset.popoverFor;
        B && f(B, !0),
          k._popoverListener &&
            k.removeEventListener("click", k._popoverListener),
          k._popoverHoverListeners &&
            (k.removeEventListener(
              "mouseenter",
              k._popoverHoverListeners.handleTriggerEnter
            ),
            k.removeEventListener(
              "mouseleave",
              k._popoverHoverListeners.handleTriggerLeave
            ));
        let T = document.getElementById(B);
        T &&
          T._popoverHoverListeners &&
          (T.removeEventListener(
            "mouseenter",
            T._popoverHoverListeners.handleContentEnter
          ),
          T.removeEventListener(
            "mouseleave",
            T._popoverHoverListeners.handleContentLeave
          ),
          delete T._popoverHoverListeners),
          delete k._popoverListener,
          delete k._popoverHoverListeners,
          delete k._popoverListenerAttached;
      };
      c.matches && c.matches("[data-popover-trigger]") && w(c),
        c.querySelectorAll &&
          c.querySelectorAll("[data-popover-trigger]").forEach(w);
    }
    function W(c = document) {
      if (
        S &&
        (c instanceof Element && c.matches("[data-popover-trigger]") && x(c),
        c && typeof c.querySelectorAll == "function")
      )
        for (let w of c.querySelectorAll("[data-popover-trigger]")) x(w);
    }
    let R = (c) => {
      let w = c.detail.elt;
      w instanceof Element && P(() => W(w));
    };
    W(),
      document.addEventListener("DOMContentLoaded", () => {
        P(() => {
          r(), W();
        });
      }),
      document.body.addEventListener("htmx:beforeSwap", (c) => {
        let w = c.detail.elt;
        w instanceof Element && E(w);
      }),
      document.body.addEventListener("htmx:afterSwap", R),
      document.body.addEventListener("htmx:oobAfterSwap", R),
      (window.popoverSystemInitialized = !0);
  })();
  (function () {
    function N(i) {
      if (!i) return;
      let n = i.querySelector("[data-progress-indicator]");
      if (!n) return;
      let r = parseFloat(i.getAttribute("aria-valuenow") || "0"),
        o = parseFloat(i.getAttribute("aria-valuemax") || "100");
      o <= 0 && (o = 100);
      let m = 0;
      o > 0 && (m = (Math.max(0, Math.min(r, o)) / o) * 100),
        (n.style.width = m + "%");
    }
    function S(i = document) {
      if (
        (i instanceof Element && i.matches('[role="progressbar"]') && N(i),
        i && typeof i.querySelectorAll == "function")
      )
        for (let n of i.querySelectorAll('[role="progressbar"]')) N(n);
    }
    let P = (i) => {
      let n = i.detail.elt;
      n instanceof Element && requestAnimationFrame(() => S(n));
    };
    S(),
      document.addEventListener("DOMContentLoaded", () => S()),
      document.body.addEventListener("htmx:afterSwap", P),
      document.body.addEventListener("htmx:oobAfterSwap", P);
  })();
  typeof window.ratingState > "u" && (window.ratingState = new WeakMap());
  (function () {
    function N(n) {
      if (!n) return;
      let r = window.ratingState.get(n);
      r && S(n, r), (n.dataset.ratingInitialized = "true");
      let o = {
          value: parseFloat(n.dataset.initialValue) || 0,
          precision: parseFloat(n.dataset.precision) || 1,
          readonly: n.dataset.readonly === "true",
          name: n.dataset.name || "",
          onlyInteger: n.dataset.onlyinteger === "true",
          maxValue: 0,
        },
        m = n.querySelector("[data-rating-input]"),
        C = Array.from(n.querySelectorAll("[data-rating-item]")),
        s = o.value,
        f = 0,
        g = { click: w, mouseover: R, mouseleave: c };
      function v() {
        let T = 0;
        for (let V of C) {
          let ye = parseInt(V.dataset.ratingValue, 10);
          !isNaN(ye) && ye > T && (T = ye);
        }
        (o.maxValue = Math.max(1, T)),
          (s = Math.max(0, Math.min(o.maxValue, s))),
          (s = Math.round(s / o.precision) * o.precision),
          x();
      }
      function x() {
        m && (m.value = s.toFixed(2));
      }
      function E(T) {
        for (let V of C) {
          let ye = parseInt(V.dataset.ratingValue, 10);
          if (isNaN(ye)) continue;
          let Ne = V.querySelector("[data-rating-item-foreground]");
          if (!Ne) continue;
          let ge = T > 0 ? T : s,
            b = ye <= Math.floor(ge),
            A = !b && ye - 1 < ge && ge < ye,
            Z = A ? (ge - Math.floor(ge)) * 100 : 0;
          Ne.style.width = b ? "100%" : A ? `${Z}%` : "0%";
        }
      }
      function W(T) {
        if (o.readonly) return;
        let V = T;
        o.onlyInteger
          ? (V = Math.round(V))
          : s === V && V % 1 === 0
          ? (V = Math.max(0, V - o.precision))
          : (V = Math.round(V / o.precision) * o.precision),
          (s = Math.max(0, Math.min(o.maxValue, V))),
          (f = 0),
          x(),
          E(0),
          n.dispatchEvent(
            new CustomEvent("rating-change", {
              bubbles: !0,
              detail: { name: o.name, value: s, maxValue: o.maxValue },
            })
          ),
          m &&
            (m.dispatchEvent(new Event("input", { bubbles: !0 })),
            m.dispatchEvent(new Event("change", { bubbles: !0 })));
      }
      function R(T) {
        if (o.readonly) return;
        let V = T.target.closest("[data-rating-item]");
        V && ((f = parseInt(V.dataset.ratingValue, 10)), isNaN(f) || E(f));
      }
      function c() {
        o.readonly || ((f = 0), E(0));
      }
      function w(T) {
        if (o.readonly) return;
        let V = T.target.closest("[data-rating-item]");
        if (!V) return;
        let ye = parseInt(V.dataset.ratingValue, 10);
        isNaN(ye) || W(ye);
      }
      if ((v(), E(0), o.readonly)) {
        n.style.cursor = "default";
        for (let T of C) T.style.cursor = "default";
      } else
        n.addEventListener("click", g.click),
          n.addEventListener("mouseover", g.mouseover),
          n.addEventListener("mouseleave", g.mouseleave);
      let k = new MutationObserver(() => {
        try {
          n.querySelectorAll("[data-rating-item]").length !== C.length &&
            ((C = Array.from(n.querySelectorAll("[data-rating-item]"))),
            v(),
            E(f > 0 ? f : 0));
        } catch (T) {
          console.error("Error in rating MutationObserver:", T);
        }
      });
      k.observe(n, { childList: !0, subtree: !0 });
      let B = { handlers: g, observer: k, items: C };
      window.ratingState.set(n, B);
    }
    function S(n, r) {
      !n ||
        !r ||
        (!n.dataset.readonly === "true" &&
          (n.removeEventListener("click", r.handlers.click),
          n.removeEventListener("mouseover", r.handlers.mouseover),
          n.removeEventListener("mouseleave", r.handlers.mouseleave)),
        r.observer && r.observer.disconnect(),
        window.ratingState.delete(n),
        n.removeAttribute("data-rating-initialized"));
    }
    function P(n = document) {
      n instanceof Element && n.matches("[data-rating-component]") && N(n),
        n &&
          typeof n.querySelectorAll == "function" &&
          n.querySelectorAll("[data-rating-component]").forEach(N);
    }
    let i = (n) => {
      let r = n.detail.elt;
      r instanceof Element && requestAnimationFrame(() => P(r));
    };
    P(),
      document.addEventListener("DOMContentLoaded", () => P()),
      document.body.addEventListener("htmx:beforeCleanup", (n) => {
        let r = n.detail.elt;
        if (r instanceof Element) {
          if (
            r.matches &&
            r.matches("[data-rating-component][data-rating-initialized]")
          ) {
            let o = window.ratingState.get(r);
            o && S(r, o);
          }
          if (r.querySelectorAll)
            for (let o of r.querySelectorAll(
              "[data-rating-component][data-rating-initialized]"
            )) {
              let m = window.ratingState.get(o);
              m && S(o, m);
            }
        }
      }),
      document.body.addEventListener("htmx:afterSwap", i),
      document.body.addEventListener("htmx:oobAfterSwap", i);
  })();
  (function () {
    function N(i) {
      if (!i || i.hasAttribute("data-initialized")) return;
      i.setAttribute("data-initialized", "true");
      let n = i.querySelector("button.select-trigger");
      if (!n) {
        console.error(
          "Select box: Trigger button (.select-trigger) not found in wrapper",
          i
        );
        return;
      }
      let r = n.dataset.contentId,
        o = r ? document.getElementById(r) : null,
        m = n.querySelector(".select-value"),
        C = n.querySelector('input[type="hidden"]');
      if (!o || !m || !C) {
        console.error(
          "Select box: Missing required elements for initialization.",
          {
            wrapper: i,
            contentID: r,
            contentExists: !!o,
            valueElExists: !!m,
            hiddenInputExists: !!C,
          }
        );
        return;
      }
      let s = o.querySelector('.select-item[data-selected="true"]');
      if (s) {
        let v = s.querySelector(".select-item-text");
        v &&
          ((m.textContent = v.textContent),
          m.classList.remove("text-muted-foreground")),
          C && (C.value = s.getAttribute("data-value") || "");
      }
      function f() {
        o.querySelectorAll(".select-item").forEach((v) => {
          v.getAttribute("data-selected") === "true"
            ? (v.classList.add("bg-accent", "text-accent-foreground"),
              v.classList.remove("bg-muted"))
            : v.classList.remove(
                "bg-accent",
                "text-accent-foreground",
                "bg-muted"
              );
        });
      }
      function g(v) {
        if (!v || v.getAttribute("data-disabled") === "true") return;
        let x = v.getAttribute("data-value"),
          E = v.querySelector(".select-item-text");
        o.querySelectorAll(".select-item").forEach((R) => {
          R.setAttribute("data-selected", "false"),
            R.classList.remove(
              "bg-accent",
              "text-accent-foreground",
              "bg-muted"
            );
          let c = R.querySelector(".select-check");
          c && c.classList.replace("opacity-100", "opacity-0");
        }),
          v.setAttribute("data-selected", "true"),
          v.classList.add("bg-accent", "text-accent-foreground");
        let W = v.querySelector(".select-check");
        W && W.classList.replace("opacity-0", "opacity-100"),
          m &&
            E &&
            ((m.textContent = E.textContent),
            m.classList.remove("text-muted-foreground")),
          C &&
            x !== null &&
            ((C.value = x),
            C.dispatchEvent(new Event("change", { bubbles: !0 }))),
          window.closePopover
            ? window.closePopover(r, !0)
            : console.warn("closePopover function not found");
      }
      o.addEventListener("click", (v) => {
        let x = v.target.closest(".select-item");
        x && g(x);
      }),
        o.addEventListener("keydown", (v) => {
          let x = v.target.closest(".select-item");
          x &&
            (v.key === "Enter" || v.key === " ") &&
            (v.preventDefault(), g(x));
        }),
        o.addEventListener("mouseover", (v) => {
          let x = v.target.closest(".select-item");
          !x ||
            x.getAttribute("data-disabled") === "true" ||
            (o.querySelectorAll(".select-item").forEach((E) => {
              E.classList.remove(
                "bg-accent",
                "text-accent-foreground",
                "bg-muted"
              );
            }),
            x.getAttribute("data-selected") !== "true" &&
              x.classList.add("bg-accent", "text-accent-foreground"));
        }),
        o.addEventListener("mouseleave", f);
    }
    function S(i = document) {
      let n = i.querySelectorAll(".select-container:not([data-initialized])");
      i instanceof Element &&
      i.matches(".select-container") &&
      !i.hasAttribute("data-initialized")
        ? N(i)
        : n.forEach(N);
    }
    let P = (i) => {
      let n = i.detail.elt;
      n instanceof Element && requestAnimationFrame(() => S(n));
    };
    S(),
      document.addEventListener("DOMContentLoaded", () => S()),
      document.body.addEventListener("htmx:afterSwap", P),
      document.body.addEventListener("htmx:oobAfterSwap", P);
  })();
  (function () {
    function N(i) {
      if (i.hasAttribute("data-initialized")) return;
      i.setAttribute("data-initialized", "true");
      let n = i.id;
      if (!n) return;
      let r = document.querySelectorAll(
        `[data-slider-value][data-slider-value-for="${n}"]`
      );
      function o() {
        r.forEach((m) => {
          m.textContent = i.value;
        });
      }
      o(), i.addEventListener("input", o);
    }
    function S(i = document) {
      i instanceof Element &&
        i.matches('input[type="range"][data-slider-input]') &&
        N(i);
      for (let n of i.querySelectorAll(
        'input[type="range"][data-slider-input]:not([data-initialized])'
      ))
        N(n);
    }
    let P = (i) => {
      let n = i.detail.elt;
      n instanceof Element && requestAnimationFrame(() => S(n));
    };
    S(),
      document.addEventListener("DOMContentLoaded", () => S()),
      document.body.addEventListener("htmx:afterSwap", P),
      document.body.addEventListener("htmx:oobAfterSwap", P);
  })();
  (function () {
    function N(i) {
      if (i.hasAttribute("data-initialized")) return;
      i.setAttribute("data-initialized", "true");
      let n = i.dataset.tabsId;
      if (!n) return;
      let r = Array.from(
          i.querySelectorAll(`[data-tabs-trigger][data-tabs-id="${n}"]`)
        ),
        o = Array.from(
          i.querySelectorAll(`[data-tabs-content][data-tabs-id="${n}"]`)
        ),
        m = i.querySelector(`[data-tabs-marker][data-tabs-id="${n}"]`);
      function C(g) {
        !m ||
          !g ||
          ((m.style.width = g.offsetWidth + "px"),
          (m.style.height = g.offsetHeight + "px"),
          (m.style.left = g.offsetLeft + "px"));
      }
      function s(g) {
        let v = null;
        for (let x of r) {
          let E = x.dataset.tabsValue === g;
          (x.dataset.state = E ? "active" : "inactive"),
            x.classList.toggle("text-foreground", E),
            x.classList.toggle("bg-background", E),
            x.classList.toggle("shadow-xs", E),
            E && (v = x);
        }
        for (let x of o) {
          let E = x.dataset.tabsValue === g;
          (x.dataset.state = E ? "active" : "inactive"),
            x.classList.toggle("hidden", !E);
        }
        C(v);
      }
      let f = r.find((g) => g.dataset.state === "active") || r[0];
      f && s(f.dataset.tabsValue);
      for (let g of r)
        g.addEventListener("click", () => {
          s(g.dataset.tabsValue);
        });
    }
    function S(i = document) {
      i instanceof Element && i.matches("[data-tabs]") && N(i);
      for (let n of i.querySelectorAll("[data-tabs]:not([data-initialized])"))
        N(n);
    }
    let P = (i) => {
      let n = i.detail.elt;
      n instanceof Element && requestAnimationFrame(() => S(n));
    };
    S(),
      document.addEventListener("DOMContentLoaded", () => S()),
      document.body.addEventListener("htmx:afterSwap", P),
      document.body.addEventListener("htmx:oobAfterSwap", P);
  })();
  (function () {
    function N(i) {
      if (
        i.hasAttribute("data-initialized") ||
        (i.setAttribute("data-initialized", "true"),
        !(i.dataset.autoResize === "true"))
      )
        return;
      let o = window.getComputedStyle(i).minHeight;
      function m() {
        (i.style.height = o), (i.style.height = `${i.scrollHeight}px`);
      }
      m(), i.addEventListener("input", m);
    }
    function S(i = document) {
      i instanceof Element && i.matches("textarea[data-textarea]") && N(i);
      for (let n of i.querySelectorAll(
        "textarea[data-textarea]:not([data-initialized])"
      ))
        N(n);
    }
    let P = (i) => {
      let n = i.detail.elt;
      n instanceof Element && requestAnimationFrame(() => S(n));
    };
    S(),
      document.addEventListener("DOMContentLoaded", () => S()),
      document.body.addEventListener("htmx:afterSwap", P),
      document.body.addEventListener("htmx:oobAfterSwap", P);
  })();
  (function () {
    if (typeof window.toastHandler > "u") {
      let P = function (r) {
          if (window.toasts.has(r)) return;
          let o = parseInt(r.dataset.duration || "0"),
            m = r.querySelector("[data-toast-progress]"),
            C = r.querySelector("[data-toast-dismiss]"),
            s = {
              timer: null,
              remaining: o,
              startTime: Date.now(),
              progress: m,
              paused: !1,
            };
          window.toasts.set(r, s);
          function f() {
            clearTimeout(s.timer),
              r.classList.remove("toast-enter-active"),
              r.classList.add("toast-leave-active"),
              r.addEventListener(
                "transitionend",
                () => {
                  r.remove(), window.toasts.delete(r);
                },
                { once: !0 }
              );
          }
          function g(E) {
            E <= 0 ||
              (clearTimeout(s.timer),
              (s.startTime = Date.now()),
              (s.remaining = E),
              (s.paused = !1),
              (s.timer = setTimeout(f, E)),
              s.progress &&
                ((s.progress.style.transition = `width ${E}ms linear`),
                s.progress.offsetWidth,
                (s.progress.style.width = "0%")));
          }
          function v() {
            if (
              !(s.paused || s.remaining <= 0) &&
              (clearTimeout(s.timer),
              (s.remaining -= Date.now() - s.startTime),
              (s.paused = !0),
              s.progress)
            ) {
              let E = window.getComputedStyle(s.progress).width;
              (s.progress.style.transition = "none"),
                (s.progress.style.width = E);
            }
          }
          function x() {
            !s.paused || s.remaining <= 0 || g(s.remaining);
          }
          o > 0 &&
            (r.addEventListener("mouseenter", v),
            r.addEventListener("mouseleave", x)),
            C && C.addEventListener("click", f),
            setTimeout(() => {
              r.classList.add("toast-enter-active"),
                s.progress && (s.progress.style.width = "100%"),
                g(o);
            }, 50);
        },
        i = function (r = document) {
          let o = [];
          r instanceof Element &&
            r.matches("[data-toast]") &&
            (window.toasts.has(r) || o.push(r)),
            r &&
              typeof r.querySelectorAll == "function" &&
              r.querySelectorAll("[data-toast]").forEach((m) => {
                window.toasts.has(m) || o.push(m);
              }),
            o.forEach(P);
        };
      var N = P,
        S = i;
      (window.toastHandler = !0), (window.toasts = new Map());
      let n = (r) => {
        let o = r.detail.elt;
        o instanceof Element && requestAnimationFrame(() => i(o));
      };
      i(),
        document.addEventListener("DOMContentLoaded", () => i()),
        document.body.addEventListener("htmx:afterSwap", n),
        document.body.addEventListener("htmx:oobAfterSwap", n);
    }
  })();
})();
/*!
  Highlight.js v11.11.1 (git: 08cb242e7d)
  (c) 2006-2024 Josh Goebel <hello@joshgoebel.com> and other contributors
  License: BSD-3-Clause
 */
